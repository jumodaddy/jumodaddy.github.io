<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id737566"/>Összefoglalás</h1></div></div></div><p>Ebben a fejezetben különböző módszereket vizsgáltunk meg arra vonatkozóan, hogy az előzetes tudás hogyan segítheti az ágenst abban, hogy új tapasztalatokból tanuljon. Mivel az előzetes tudás zöme inkább a relációs modellekkel, és nem attribútumalapú modellekkel van megadva, a relációs modellekből tanuló rendszerekkel is foglalkoztunk. Az alábbiakban összefoglaljuk a fontos tudnivalókat.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Az előzetes tudás felhasználása a tanulásnál a <span class="strong"><strong>kumulatív tanulás</strong></span>hoz (<span class="strong"><strong>cumulative learning</strong></span>) vezet, ahol az ágens az új tudás beszerzésével javítja a tanulási képességét.</p></li><li class="listitem"><p>Az előzetes tudás segít a tanulásban, mert a különben konzisztens hipotéziseket eliminálja, és a példák magyarázatának „kitöltésével” rövidebb hipotézisekhez vezet. Ezek a tulajdonságok javítják a tanulás minta- és számítási komplexitását.</p></li><li class="listitem"><p>Az előzetes tudás által betöltött különböző – <span class="strong"><strong>vonzatkényszer</strong></span>ek (<span class="strong"><strong>entailment constraint</strong></span>s) formájában kifejezett – logikai szerepeknek a megértése segít a különféle tanulási módszerek definiálásában.</p></li><li class="listitem"><p>A <span class="strong"><strong>magyarázatalapú tanulás</strong></span> (<span class="strong"><strong>MAT</strong></span>) (<span class="strong"><strong>explanation-based learning</strong></span>, <span class="strong"><strong>EBL</strong></span>) az egyedi példákból úgy emeli ki az általános szabályokat, hogy a példákat először megmagyarázza, majd a magyarázatot általánosítja. Ezzel a deduktív módszerrel az elsődleges tudást hasznos, hatékony, speciális rendeltetésű szaktudássá változtatjuk.</p></li><li class="listitem"><p>A <span class="strong"><strong>relevanciaalapú tanulás</strong></span> (<span class="strong"><strong>RAT</strong></span>) (<span class="strong"><strong>relevance-based learning</strong></span>, <span class="strong"><strong>RBL</strong></span>) az előzetes tudást meghatározások formájában használja a releváns attribútumok azonosítására. Ily módon egy redukált hipotézisteret generál, és a tanulási folyamatot meggyorsítja. A RAT lehetővé teszi az egyedi példák deduktív általánosítását is.</p></li><li class="listitem"><p>A <span class="strong"><strong>tudásalapú induktív tanulás</strong></span> (<span class="strong"><strong>TIT</strong></span>) (<span class="strong"><strong>knowledge-based inductive learning</strong></span>, <span class="strong"><strong>KBIL</strong></span>) induktív hipotéziseket keres, amelyek a háttértudás segítségével megmagyarázzák a megfigyelések halmazát.</p></li><li class="listitem"><p>Az <span class="strong"><strong>induktív logikai programozás</strong></span>i (<span class="strong"><strong>ILP</strong></span>) (<span class="strong"><strong>inductive logic programming</strong></span>) technikák a TIT-hez folyamodnak, az elsőrendű logikában kifejezett háttértudást felhasználva. Az ILP-módszerek olyan relációs tudás megtanulására is alkalmasak, amelyet az attribútumalapú rendszerekben nem lehet kifejezni.</p></li><li class="listitem"><p>Az ILP felülről lefelé megközelítéssel, a nagyon általános szabályok finomításával, vagy pedig lentről felfelé megközelítéssel, a deduktív folyamat invertálásával valósítható meg.</p></li><li class="listitem"><p>Az ILP-módszerek természetes módon generálnak új predikátumokat is, amelyekkel új elméletek tömören kifejezhetők, és általános célú tudományos elméletformáló rendszerekként is ígéretesnek mutatkoznak.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id737701"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>Bár az előzetes tudás felhasználása a tanulásban természetes témának tűnhet a tudományfilozófusok számára, mostanáig meglepően kevés formális eredmény született. Nelson Goodman filozófus a <span class="emphasis"><em>Fact, Fiction, and Forecast</em></span> c. művében megcáfolta azt a korábbi feltételezést, miszerint az indukció nem más, mint egy univerzálisan kvantifikált kijelentés megfelelően sok példájának a megszemlélése és hipotézisként való elfogadása (Goodman, 1954). </p><p>Vegyük például azt a hipotézist, hogy „Minden smaragd zölék”, ahol a <span class="strong"><strong>zölék</strong></span> azt jelenti, hogy „zöld, ha <span class="emphasis"><em>t</em></span> idő előtt figyeljük meg, utána azonban kék”. A <span class="emphasis"><em>t</em></span> idő előtt bármikor példák millióit láthatnánk, amelyek mind alátámasztják, hogy a smaragdok zölékek, negatív példák nélkül, mégis hezitálnánk a szabályt elfogadni. A jelenség csakis az indukciós folyamat szempontjából releváns a priori tudás szerepével magyarázható. Goodman a hasznosítható a priori tudás teljes választékát javasolja, a meghatározások <span class="strong"><strong>tú</strong></span><span class="strong"><strong>lzott hipotézis</strong></span>nek (<span class="strong"><strong>overhypothesis</strong></span>) nevezett változatát is beleértve. Sajnos a gépi tanulással foglalkozó korai kutatásnál Goodman munkájára nem figyeltek fel.</p><p>A MAT gyökerei a tervkészítésnél használt <code class="code">STRIPS</code> módszereihez nyúlnak vissza (Fikes és társai, 1972). Egy terv elkészítésével a terv egy általánosított változatát a tervek könyvtárában tárolták, és később <span class="strong"><strong>makróoperátor</strong></span>ként (<span class="strong"><strong>macro-operator</strong></span>) a tervkészítésnél felhasználták. Hasonló ötletek Anderson ACT<sup>*</sup> architektúrájában is megjelentek, <span class="strong"><strong>tudáskompilálás</strong></span> (<span class="strong"><strong>knowledge compilation</strong></span>) címen (Anderson, 1983) és <code class="code">SOAR</code> architektúrájában <span class="strong"><strong>tudásdarabolás</strong></span> (<span class="strong"><strong>chunking</strong></span>) címen (Laird és társai, 1986). A <span class="strong"><strong>sémabeszerzés</strong></span> (<span class="strong"><strong>schema acquisition</strong></span>) (DeJong, 1981), az <span class="strong"><strong>analitikus általánosítás</strong></span> (<span class="strong"><strong>analytical general</strong></span><span class="strong"><strong>ization</strong></span>) (Mitchell, 1982) és a <span class="strong"><strong>kényszeralapú általánosítás</strong></span> (<span class="strong"><strong>constraint-based generalization</strong></span>) (Minton, 1984) a MAT tanulás irányában jelentkező és a (Mitchell és társai, 1986; DeJong és Mooney, 1986) publikációk stimulálta gyorsan növekvő érdeklődésnek közvetlen előfutárai voltak. A szövegben bemutatott MAT algoritmust Hirsh (Hirsh, 1987) vezette be, aki azt is megmutatta, hogy az algoritmust hogyan kell egy logikai programozási rendszerbe ágyazni. Van Harmelen és Bundy a MAT-ot a programelemző rendszerekben (Jones és társai, 1993) használt <span class="strong"><strong>részleges kiértékelő</strong></span> (<span class="strong"><strong>partial evaluation</strong></span>) módszer variánsaként magyarázzák (Van Harmelen és Bundy, 1988).</p><p>Az utóbbi időben a szigorú elemzés és a kísérleti kutatás a MAT jobb megértéséhez vezetett a problémamegoldás sebességében mért lehetséges költségeinek és előnyeinek terén. Minton azt mutatta meg, hogy hacsak tekintélyes munkát nem fektetünk bele, a MAT a programot lényegesen lelassíthatja (Minton, 1988). Tambe hasonló problémákkal küszködött a tudásdarabolásnál, és a szabálynyelv kifejezőerejének a mérséklését javasolta, hogy a szabályok munkamemóriához való illesztésének jelentős költségét minimálizáljuk (Tambe és társai, 1990). Erős a párhuzam ezen kutatás és az elsőrendű logika leszűkített változatának következtetési komplexitására vonatkozó jelenlegi eredményei között (lásd 9. fejezet). A MAT várható nyereségének formális valószínűségi elemzése a (Greiner, 1989; Subramanian és Feldman, 1990) munkákban található. Egy kiváló áttekintés Dietterichtől származik (Dietterich, 1990).</p><p>Ahelyett hogy a példákat mint az általánosítás fókuszpontjait tekintenénk, új problémák megoldására közvetlenül felhasználhatók az <span class="strong"><strong>analógiás következtetés</strong></span> (<span class="strong"><strong>analogical </strong></span><span class="strong"><strong>reasoning</strong></span>) elnevezésű megközelítésben. Az ilyen következtetésnek több változata is létezik. Idetartozik a hasonlóság mértékén alapuló plauzíbilis következtetés (Gentner, 1983) és a meghatározásokon alapuló deduktív következtetés (Davies és Russell, 1987), amely azonban megkívánja a példa jelenlétét ahhoz, hogy a belőle kialakított „lusta” MAT a régi példa általánosítását az új probléma szükségletei szerint irányítsa. Az analógiás következtetésnek ezt az utóbbi formáját általában meg lehet találni az <span class="strong"><strong>esetalapú következtetés</strong></span>nél (<span class="strong"><strong>case-based reasoning</strong></span>) (Kolodner, 1993) és a <span class="strong"><strong>származtatási an</strong></span><span class="strong"><strong>alógiá</strong></span>nál (<span class="strong"><strong>derivational analogy</strong></span>) (Veloso és Carbonell, 1993).</p><p>A releváns információval funkcionális függőségek formájában először az adatbázis-kutatásnál foglalkoztak, ahol ez a nagy attribútumhalmazok kezelhető részhalmazokra való strukturálásának eszköze volt. Funkcionális függőségeket analógiás következtetésre Carbonell és Collins, majd logikai színezettel Bobrow és Raphael használtak (Carbonell és Collins, 1973; Bobrow és Raphael, 1974). Davies és Russell (Davies, 1985; Davies és Russell, 1987) a függőségeket másoktól függetlenül újra felfedezték, és az analógiás következtetés szempontjából teljes körű logikai elemzésnek vetették alá. A függőségeket deklaratív elfogultság céljából Russell és Grosof használták (Russell és Grosof, 1987). A meghatározások és a leszűkített szótárral rendelkező hipotézistér közötti ekvivalenciát Russell (Russell, 1988) bizonyította be. A meghatározásokat tanuló algoritmust és az RADFT megnövelt hatékonyságát először a <code class="code">FOCUS</code> algoritmusban mutatták be (Almuallim és Dietterich, 1991). Tadepalli a meghatározások tanulására egy ügyes algoritmust közölt, amely a tanulási sebességben igen lényeges javulást mutat (Tadepalli, 1993). </p><p>Az a gondolat, hogy az induktív tanulás kivitelezhető inverz dedukcióval W. S. Jevonsig vezethető vissza (Jevons, 1874), aki azt írta, hogy: „Mind a formális logika, mind a valószínűség-elmélet tanulmányozása arra az álláspontra juttatott engem, hogy egy olyan dolog, mint egy külön indukciós módszer, a dedukcióval szembeállítva nincs, és az indukció egyszerűen a dedukció egy fordított alkalmazása.” A számítástudományi elemzések Gordon Plotkin figyelemre méltó PhD-disszertációjával kezdődtek Edinburghban (Plotkin, 1971). Bár Plotkin számos, a mai ILP területén használt tételt és módszert dolgozott ki, az indukció egyes részproblémáira vonatkozó bizonyos eldönthetetlenségi eredmények elvették a kedvét. A MIS (Shapiro, 1981) újból bevezette a logikai programok tanulási problémáját, azonban ezt főleg az automatikus hibakeresés elméletéhez való hozzájárulásának tekintették. A szabályindukció kutatása, vagyis az olyan rendszerek, mint az ID3 (Quinlan, 1986) és CN2 (Clark és Niblett, 1989) a <code class="code">FOIL</code>-hoz vezettek (Quinlan, 1990), amely első ízben tette lehetővé relációs szabályok gyakorlati indukcióját. A területet Muggleton és Buntine pezsdítették fel (Muggleton és Buntine, 1988). <code class="code">CIGOL</code> programjuk az inverz rezolúció nem egészen teljes változatát tartalmazta, és új predikátumok generálására is alkalmas volt.<sup>[<a id="id737882" href="#ftn.id737882" class="footnote">193</a>]</sup> A predikátum felfedezésével Wirth és O’Rorke is foglalkoztak (Wirth és O’Rorke, 1991). A következő nagyobb rendszer a <code class="code">GOLEM</code> volt (Muggleton és Feng, 1990), amely a Plotkin-féle relatíve legkevésbé általános általánosítás ötletén alapuló lefedő algoritmust használja. A <code class="code">FOIL</code> fentről lefelé módon, míg a <code class="code">CIGOL</code> és a <code class="code">GOLEM</code> lentről felfelé módon dolgoztak. E korszak más rendszerei az <code class="code">ITOU</code> (Rouveirol és Puget, 1989) és a <code class="code">CLINT</code> (De Raedt, 1992) rendszerek voltak. Újabban a <code class="code">PROGOL</code> (Muggleton, 1995) az inverz vonzatreláció egy hibrid (fentről lefelé és lentről felfelé) megközelítését valósította meg, és a rendszert számos gyakorlati problémára alkalmazták, különösképpen a biológiában és a természetes nyelvfeldolgozásban. Muggleton a <code class="code">PROGOL</code> egy kiterjesztését írja le (Muggleton, 2000), sztochasztikus logikai programok alakjában reprezentált bizonytalanság kezelésére.</p><p class="Tartalom3">Az ILP-módszerek formális elemzését (Muggleton, 1991) tartalmazza, míg a (Muggleton, 1992) egy nagy cikkgyűjtemény. A módszerek és az alkalmazások nagy gyűjteménye a (Lavrac és Dzeroski, 1994) könyv. A terület történetéről és a jövő kihívásairól újabb áttekintést ad (Page és Srinivasan, 2002). Haussler korai komplexitási eredményei azt sugallták, hogy az elsőrendű állítások tanulása reménytelenül bonyolult (Haussler, 1989). A klózokra vonatkozó különböző szintaktikai korlátozások jobb megértésével azonban pozitív eredmények is megjelentek, még a rekurziót tartalmazó klózokra is (Dzeroski és társai, 1992). Az ILP komplexitási eredményeiről Kietz és Dzeroski, valamint Cohen és Page írtak átfogó cikkeket (Kietz és Dzeroski, 1994; Cohen és Page, 1995).</p><p class="Tartalom3">Bár az ILP jelenleg a konstruktív indukció problémájának domináló megközelítése, nem csak ezzel próbálkoztak. Az ún. <span class="strong"><strong>felfedező rendszer</strong></span>ek (<span class="strong"><strong>discovery system</strong></span>s) célja az új koncepciók tudományos felfedezésének általában a koncepció definícióterében történő közvetlen keresés útján történő modellezése. Doug Lenat AM (Automated Mathematician) programja (Davis és Lenat, 1982) szakértő szabályok formájában megfogalmazott felfedező heurisztikákat használt arra, hogy elemi számelméleti koncepciók és sejtések keresését irányítsa. Éles ellentétben a matematikai következtetésre kifejlesztett rendszerekkel, az AM nélkülözte a bizonyítás fogalmát, és csak sejtés szinten tudott működni. A program újra felfedezte a Goldbach-sejtést és az egyértelmű prímtényezőkre bontást. Az AM architektúráját később az <code class="code">EURISKO</code> rendszerben (Lenat, 1983) általánosították, a rendszert a saját felfedező heurisztikákat átírni képes szabályokkal bővítve. Az <code class="code">EURISKO</code>-t más, a matematikai felfedezéstől eltérő tartományokban is alkalmazták, de az AM-nél kisebb sikerrel. Az AM és az <code class="code">EURISKO</code> módszertana vitatott, lásd (Ritchie és Hanna, 1984; Lenat és Brown, 1984).</p><p class="Tartalom3">A felfedező rendszerek egy másik csoportja a valós fizikai adatokkal való munkát célozza és új törvények felfedezését kísérli meg. A <code class="code">DALTON</code>, a <code class="code">GLAUBER</code> és a <code class="code">STAHL</code> (Langley és társai, 1987) olyan szabályalapú rendszerek, amelyek fizikai rendszerekből származó adatokban kvantitatív összefüggéseket keresnek. Mindegyik rendszer képes volt egy tudomány történetéből jól ismert felfedezés újbóli meghozatalára. A probabilisztikus technikákon – különösképpen az új kategóriákat felfedező klaszterező algoritmusokon – alapuló felfedező rendszerekkel a 20. fejezetben foglalkozunk.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id737959"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>19.1.	</strong></span></p><p>Mutassa ki a konjunktív normál formába való átalakításával és a rezolúció alkalmazásával, hogy a <a class="xref" href="ch19s04.md#ID_799_oldal">„Tanulás releváns információ alapján”</a> részben található és a brazilokra vonatkozó konklúzió helyes.</p><p><span class="strong"><strong>19.2.	</strong></span></p><p>Az alábbi meghatározás mindegyikére írja fel a meghatározás logikai reprezentációját, és magyarázza meg, hogy a meghatározás miért igaz (ha igaz egyáltalán).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A postai kód meghatározza a megyét.</p></li><li class="listitem"><p>A külső kialakítás és a névleges érték meghatározzák az érme tömegét.</p></li><li class="listitem"><p>Adott program esetén a bemenetek meghatározzák a kimeneteket.</p></li><li class="listitem"><p>A klíma, a táplálkozás, a fizikai gyakorlat és a metabolizmus meghatározzák, hogy valaki fogyni vagy súlyban gyarapodni fog.</p></li><li class="listitem"><p>A kopaszságot (vagy annak hiányát) az anyai ágon az egyik nagyszülőnek a kopaszsága határozza meg.</p></li></ol></div><p><span class="strong"><strong>19.3.	</strong></span></p><p>Hasznos lenne a meghatározásoknak egy valószínűségi verziója? Javasoljon egy definíciót.</p><p><span class="strong"><strong>19.4.	</strong></span></p><p>Pótolja a <span class="emphasis"><em>C</em></span><sub>1</sub> és/vagy <span class="emphasis"><em>C</em></span><sub>2</sub> klózok értékét az alábbi klózhalmazban, figyelembe véve, hogy <span class="emphasis"><em>C</em></span> a <span class="emphasis"><em>C</em></span><sub>1</sub> és a <span class="emphasis"><em>C</em></span><sub>2</sub> rezolvense:</p><p>(a)	<span class="emphasis"><em>C </em></span>=<span class="emphasis"><em> Igaz</em></span> ⇒ <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>), <span class="emphasis"><em>C</em></span><sub>1 </sub>= <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) ⇒ <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), <span class="emphasis"><em>C</em></span><sub>2 </sub>= ??</p><p>(b)	<span class="emphasis"><em>C </em></span>= <span class="emphasis"><em>Igaz</em></span> ⇒ <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>), <span class="emphasis"><em>C</em></span><sub>1 </sub>= ??, <span class="emphasis"><em>C</em></span><sub>2 </sub>= ??</p><p>(c)	<span class="emphasis"><em>C </em></span>= <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) ⇒ <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>y</em></span>)), <span class="emphasis"><em>C</em></span><sub>1 </sub>= ??, <span class="emphasis"><em>C</em></span><sub>2 </sub>= ??</p><p>Ha több megoldás is lehetséges, a különböző eseteket külön példákkal illusztrálja.</p><p><span class="strong"><strong>19.5.	</strong></span></p><div class="informalexample"><p/><p>Tegyük fel, hogy egy rezolúciós lépést végrehajtó logikai programot írunk. Legyen tehát a <span class="emphasis"><em>Rezolválás</em></span>(<span class="emphasis"><em>c</em></span><sub>1</sub>, <span class="emphasis"><em>c</em></span><sub>2</sub>, <span class="emphasis"><em>c</em></span>) sikeres, ha a <span class="emphasis"><em>c</em></span> a <span class="emphasis"><em>c</em></span><sub>1</sub> és a <span class="emphasis"><em>c</em></span><sub>2</sub> rezolválásának az eredménye. Rendes körülmények között a <span class="emphasis"><em>Rezolválás</em></span>-t a tételbizonyítás részeként fogjuk használni úgy, hogy meghívjuk a <span class="emphasis"><em>c</em></span> rezolvens generálására, miközben a <span class="emphasis"><em>c</em></span><sub>1</sub> és a <span class="emphasis"><em>c</em></span><sub>2</sub> változóba konkrét klózértékeket helyettesítünk be. Tegyük most fel, hogy az eljárást a behelyettesített <span class="emphasis"><em>c</em></span>-vel és a szabad <span class="emphasis"><em>c</em></span><sub>1</sub>-gyel, valamint  <span class="emphasis"><em>c</em></span><sub>2</sub>-vel hívjuk meg. Megszületik-e az inverz rezolúciós lépés helyes eredménye? Szükséges-e a logikai program valamilyen speciális átalakítása, hogy az inverz lépés helyesen működjön?</p><p/></div><p><span class="strong"><strong>19.6.	</strong></span></p><p>Tegyük fel, hogy a <code class="code">FOIL</code> program egy klózhoz egy literált úgy add hozzá, hogy egy bináris <span class="emphasis"><em>P</em></span> predikátumot használ, és hogy az előbbi literálok (a klóz fejrészét beleértve) öt különböző változót tartalmaznak. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Hány funkcionálisan különböző literált lehet generálni? A két literál funkcionálisan egybeesik, ha csupán az általuk tartalmazott új változók neveiben különböznek.</p></li><li class="listitem"><p>Meg tudna adni általános képletet a különböző, <span class="emphasis"><em>r</em></span> argumentummal rendelkező predikátumot használó literálok számának meghatározására, ha előzőleg <span class="emphasis"><em>n</em></span> változót használtunk? </p></li><li class="listitem"><p>A <code class="code">FOIL</code> miért nem enged olyan literálokat használni, amelyek az előzőleg használt változókat nem tartalmazzák?</p></li></ol></div><p><span class="strong"><strong>19.7.	</strong></span></p><p>A 19.11. ábrán látható családfa adatainak vagy annak részhalmazának felhasználásával alkalmazza az <span class="emphasis"><em>Őse</em></span> predikátum megtanulására a <code class="code">FOIL</code> algoritmust.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id737882" href="#id737882" class="para">193</a>] </sup> Az inverz rezolúciós módszer (Russell, 1986)-ben is megjelenik, a teljes algoritmust egy lábjegyzetben közlik.</p></div></div></div></body></html>
