<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="A visszalépéses keresés alkalmazása kényszerkielégítési problémákra"><div class="titlepage"><div><div><h1 class="title"><a id="id562694"/>A visszalépéses keresés alkalmazása kényszerkielégítési problémákra</h1></div></div></div><a id="ID_187_oldal"/><p>Az előző alfejezetben keresési problémaként fogalmaztuk meg a kényszerkielégítési problémákat. Ezt a megfogalmazást felhasználva a 3. és a 4. fejezetben bemutatott bármely keresési eljárással megoldhatók a kényszerkielégítési problémák. Tegyük fel, hogy alkalmazzuk a szélességi keresést az előző fejezetben megadott általános CSP-megfogalmazásra. Hamarosan valami szörnyűség tűnik fel: a fa tetején az elágazási tényező <span class="emphasis"><em>nd</em></span>, mert a <span class="emphasis"><em>d</em></span> érték bármelyike hozzárendelhető az <span class="emphasis"><em>n</em></span> változó bármelyikéhez. A következő szinten az elágazási tényező (<span class="emphasis"><em>n</em></span> – 1)<span class="emphasis"><em>d</em></span> és így tovább az <span class="emphasis"><em>n</em></span> szint során. Egy <span class="emphasis"><em>n</em></span>!· <span class="emphasis"><em>d<sup>n</sup> </em></span>levelű fát építünk fel, noha csupán <span class="emphasis"><em>d<sup>n</sup> </em></span>lehetséges teljes hozzárendelés van!</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Látszólag racionális, valójában naiv problémamegfogalmazásunk elhanyagolta az összes kényszerkielégítési probléma egy döntő közös tulajdonságát: a<span class="strong"><strong> kommutativitás</strong></span>t (<span class="strong"><strong>commutativity</strong></span>). Egy probléma akkor kommutatív, ha a végeredmény szempontjából közömbös, hogy cselekvések egy adott sorozatát milyen sorrendben alkalmazzuk. Ilyenek a kényszerkielégítési problémák is, mert a változók hozzárendelése során a sorrendtől függetlenül ugyanazt a parciális hozzárendelést kapjuk. Ezért tehát<span class="emphasis"><em> mindegyik kényszerkielégítési problémamegoldó a következő állapot generálásakor a keresési fa minden csomópontjában csak </em></span>egyetlen<span class="emphasis"><em> változó lehetséges hozzárendeléseit veszi tekintetbe.</em></span> Az ausztráliai térképszínezési probléma keresési fájának gyökércsomópontjában választhatunk a <span class="emphasis"><em>DA </em></span>=<span class="emphasis"><em> vörös</em></span>, a<span class="emphasis"><em> DA </em></span>=<span class="emphasis"><em> zöld</em></span> és a <span class="emphasis"><em>DA </em></span>=<span class="emphasis"><em> kék </em></span>közül, de sohasem merül fel választási lehetőségként a <span class="emphasis"><em>DA </em></span>=<span class="emphasis"><em> vörös </em></span>vagy az <span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> kék</em></span>. A levelek száma ezzel a megszorítással már a remélt <span class="emphasis"><em>d<sup>n</sup></em></span>.</p></div><div class="figure"><a id="id562804"/><p class="title"><strong>5.3. ábra - Egy egyszerű visszalépéses keresési algoritmus kényszerkielégítési problémákhoz. Az algoritmus a 3. fejezet rekurzív mélységi keresőjén alapul. A <code class="code">HOZZÁRENDELETLEN-VÁLTOZÓ-KIVÁLASZTÁSA</code> és a <code class="code">TARTOMÁNY-ÉRTÉKEK-SORRENDEZÉSE</code> függvények használhatók a szövegben bemutatott általános célú heurisztikák megvalósítására.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-03.png" alt="Egy egyszerű visszalépéses keresési algoritmus kényszerkielégítési problémákhoz. Az algoritmus a 3. fejezet rekurzív mélységi keresőjén alapul. A HOZZÁRENDELETLEN-VÁLTOZÓ-KIVÁLASZTÁSA és a TARTOMÁNY-ÉRTÉKEK-SORRENDEZÉSE függvények használhatók a szövegben bemutatott általános célú heurisztikák megvalósítására."/></div></div></div><div class="figure"><a id="id562821"/><p class="title"><strong>5.4. ábra - Részlet a keresési fából, amelyet az egyszerű visszalépéses keresés generált az 5.1. ábrán bemutatott térképszínezési problémához</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-04.png" alt="Részlet a keresési fából, amelyet az egyszerű visszalépéses keresés generált az 5.1. ábrán bemutatott térképszínezési problémához"/></div></div></div><p>A <span class="strong"><strong>visszalépéses keresés</strong></span> (<span class="strong"><strong>backtracking search</strong></span>) kifejezést olyan mélységi keresésekre használjuk, melyek egyszerre csak egy változóhoz rendelnek értéket, és visszalépnek, ha már nincs megengedett hozzárendelési lehetőség. Az algoritmus az 5.3. ábrán látható. Vegyük észre, hogy az algoritmus lényegében a 115–116. oldalon leírt egyenkénti módszert használja az inkrementális következő állapot generálásra. Továbbá a következő állapot generálásakor kifejti az aktuális állapotot, nem pedig egyszerűen másolja. A kényszerkielégítési problémák szokásos reprezentációja miatt nincs szükség a <code class="code">VISSZALÉPÉSES-KERESÉS</code> algoritmus kiegészítésére tárgyterület-specifikus kezdeti állapottal, állapotátmenet-függvénnyel vagy célteszttel. Az 5.4. ábrán látható egy részlet az ausztráliai színezési problémához generált keresési fából (a változó-hozzárendelések sorrendje <span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÉT</em></span>,<span class="emphasis"><em> Q</em></span>,<span class="emphasis"><em> </em></span>…).</p><p>Az egyszerű visszalépéses keresés a 3. fejezet terminológiája szerint nem informált algoritmus, tehát nem is várjuk el, hogy nagy problémák esetén is hatékony legyen. Az 5.5. ábra első oszlopában bemutatott néhány eredmény megerősíti várakozásainkat.</p><div class="figure"><a id="id562863"/><p class="title"><strong>5.5. ábra - Az egyes CSP-algoritmusok teljesítménye különböző problémák megoldásában. Az algoritmusok balról jobbra haladva a következők: egyszerű visszalépéses, MRV-heurisztikával bővített visszalépéses, előrenéző ellenőrzés, MRV-heurisztikával kiegészített előrenéző ellenőrzés és a minimális konfliktusok lokális keresése. Az egyes cellákban a probléma megoldása során elvégzett konzisztencia-ellenőrzések száma található (öt futtatás mediánértékéből meghatározva); figyeljünk fel arra, hogy a két jobb felső cella kivételével mindegyik érték ezrekben van megadva (ezt jelzi a K betű). Az első probléma az Amerikai Egyesült Államok 50 államát tartalmazó térkép négy színnel történő színezése. A többi probléma a (Bacchus és van Run, 1995)-ből származik (1. táblázat). A második probléma az <span class="emphasis"><em>n</em></span>-királynő megoldásához szükséges ellenőrzések száma (<span class="emphasis"><em>n</em></span> értékeire 2-től 50-ig összegezve). A harmadik az 5.13. feladatban is szereplő „zebrarejtvény”. A maradék kettő mesterséges véletlenszerűen generált problémák. (A min-konfliktusok algoritmus ezeken nem futott.) Az eredmények azt érzékeltetik, hogy az MRV-heurisztikával kombinált előrenéző ellenőrzés mindegyik probléma esetén jobban teljesít, mint a többi visszalépéses algoritmus, de nem minden esetben jobb a min-konfliktusokat használó helyi keresésnél.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-05.png" alt="Az egyes CSP-algoritmusok teljesítménye különböző problémák megoldásában. Az algoritmusok balról jobbra haladva a következők: egyszerű visszalépéses, MRV-heurisztikával bővített visszalépéses, előrenéző ellenőrzés, MRV-heurisztikával kiegészített előrenéző ellenőrzés és a minimális konfliktusok lokális keresése. Az egyes cellákban a probléma megoldása során elvégzett konzisztencia-ellenőrzések száma található (öt futtatás mediánértékéből meghatározva); figyeljünk fel arra, hogy a két jobb felső cella kivételével mindegyik érték ezrekben van megadva (ezt jelzi a K betű). Az első probléma az Amerikai Egyesült Államok 50 államát tartalmazó térkép négy színnel történő színezése. A többi probléma a (Bacchus és van Run, 1995)-ből származik (1. táblázat). A második probléma az n-királynő megoldásához szükséges ellenőrzések száma (n értékeire 2-től 50-ig összegezve). A harmadik az 5.13. feladatban is szereplő „zebrarejtvény”. A maradék kettő mesterséges véletlenszerűen generált problémák. (A min-konfliktusok algoritmus ezeken nem futott.) Az eredmények azt érzékeltetik, hogy az MRV-heurisztikával kombinált előrenéző ellenőrzés mindegyik probléma esetén jobban teljesít, mint a többi visszalépéses algoritmus, de nem minden esetben jobb a min-konfliktusokat használó helyi keresésnél."/></div></div></div><p>A 4. fejezetben a nem informált keresési algoritmusok gyenge teljesítményét a probléma ismeretéből származó tárgyterület-specifikus heurisztika bevezetésével orvosoltuk. Az derül azonban ki, hogy a kényszerkielégítési problémák hatékonyan megoldhatók ilyen tárgyterület-specifikus tudás nélkül is. Olyan általános célú eljárások alakíthatók ki, amelyek az alábbi kérdéseket vizsgálják:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A következő lépésben melyik változóhoz rendeljünk értéket, és milyen sorrendben próbálkozzunk az értékekkel?</p></li><li class="listitem"><p>Milyen következményei vannak a jelenlegi változó-hozzárendeléseknek a még hozzárendeletlen változók számára?</p></li><li class="listitem"><p>Ha egy út sikertelennek bizonyul (azaz egy olyan állapothoz jutunk, ahol egy változónak nincs megengedhető értéke), a következő utak során el tudja-e kerülni a keresés ezt a hibát?</p></li></ol></div><p>A következő pontokban megpróbáljuk sorra megválaszolni ezeket a kérdéseket.</p><div class="section" title="Változó- és értékrendezés"><div class="titlepage"><div><div><h2 class="title"><a id="id562899"/>Változó- és értékrendezés</h2></div></div></div><p>A visszalépéses algoritmus tartalmazza az alábbi sort:</p><p><code class="code"><em><span class="remark">var</span></em> ← Hozzárendeletlen-Változó-Kiválasztás(Változók[<em><span class="remark">csp</span></em>], <em><span class="remark">hozzárendelések</span></em>, <em><span class="remark">csp</span></em>)</code></p><p>Alapértelmezés szerint a <code class="code">HOZZÁRENDELETLEN-VÁLTOZÓ-KIVÁLASZTÁS</code> egyszerűen kiválasztja a <code class="code">VÁLTOZÓK</code>[<span class="emphasis"><em>csp</em></span>] lista sorrendje szerinti következő hozzárendeletlen változót. A statikus változó-hozzárendelés ritkán vezet a leghatékonyabb kereséshez. Például miután kiválasztottuk az <span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös </em></span>és az <span class="emphasis"><em>ÉT </em></span>=<span class="emphasis"><em> zöld</em></span> hozzárendeléseket, csak egyetlen értéket rendelhetünk <span class="emphasis"><em>DA</em></span>-hoz, tehát ésszerű lenne inkább a <span class="emphasis"><em>DA </em></span>=<span class="emphasis"><em> kék </em></span>hozzárendelést elvégezni, mintsem <span class="emphasis"><em>Q</em></span> számára keresni értéket. Sőt miután <span class="emphasis"><em>DA</em></span> értéket kapott, kényszerítve vagyunk <span class="emphasis"><em>Q, ÚDW </em></span>és <span class="emphasis"><em>V </em></span>értékeinek kiválasztásakor. Ezt az intuitív ötletet (a legkevesebb „megengedett” értékkel rendelkező változó kiválasztását) nevezik <span class="strong"><strong>legkevesebb fennmaradó érték</strong></span> (<span class="strong"><strong>minimum remaining values</strong></span>, <span class="strong"><strong>MRV</strong></span>) heurisztikának. Nevezték már „legkorlátozottabb változó” vagy „meghiúsulást előre” heurisztikának is (az utóbbi névnek az a magyarázata, hogy azt a változót emeli ki, amelyik legvalószínűbben fog hamarosan hibához vezetni, ezáltal megnyesve a keresési fát). Ha van egy <span class="emphasis"><em>X </em></span>változó, amelynek egyetlen megengedett értéke sincs, akkor az MRV-heurisztika ki fogja választani <span class="emphasis"><em>X</em></span>-et, és azonnal kideríti a hibát, elkerülve ezzel a többi változó közötti értelmetlen keresgélést, ami mindig kudarcra vezet, amikor <span class="emphasis"><em>X</em></span> végül is kiválasztódik. Az 5.5. ábra második, BT+MRV címkéjű oszlopa ennek a heurisztikának a teljesítményét mutatja. Az egyszerű visszalépéses keresésnél a teljesítmény a problémától függően mintegy 3…3000-szer jobb lehet. Vegyük észre, hogy a teljesítménymértékünk nem tartalmazza a heurisztikus értékek kiszámításának többletköltségét. A következő pontban bemutatunk egy módszert, amellyel kezelhetővé válik ez a költség.</p><p>Az MRV-heurisztika semmit sem segít abban, hogy melyik régiót válasszuk ki elsőként Ausztrália kiszínezésekor, mert a kiinduláskor mindegyik régiónak három megengedett színe van. Ebben az esetben segíthet a <span class="strong"><strong>fokszám-heurisztika</strong></span> (<span class="strong"><strong>degree heuristics</strong></span>). Ez azáltal kísérli meg a későbbi választások elágazási tényezőjét csökkenteni, hogy azt a változót választja ki, amely a legtöbbször szerepel a hozzárendeletlen változókra vonatkozó kényszerekben. Az 5.1. ábrán <span class="emphasis"><em>DA</em></span> a legnagyobb fokszámú változó (fokszáma 5), az összes többi változó fokszáma 2 vagy 3, leszámítva <span class="emphasis"><em>T</em></span>-t, amelyé nulla. Valójában, ha már egyszer <span class="emphasis"><em>DA</em></span>-t kiválasztottuk, a fokszám-heurisztika alkalmazása a problémát egyetlen hibás lépés nélkül oldja meg: mindegyik választási pontnál bármelyik konzisztens színt is választjuk, mindenképpen visszalépés nélkül jutunk egy megoldáshoz. A legkevesebb fennmaradó érték heurisztika általában jobban irányít, de a patthelyzetek eldöntéséhez hasznos segítség lehet a fokszám-heurisztika.</p><p>Miután az algoritmus már kiválasztott egy változót, el kell döntenie, hogy milyen sorrendben vizsgálja meg ennek értékeit. Erre néha a <span class="strong"><strong>legkevésbé-korlátozó-érték</strong></span> (<span class="strong"><strong>least-constraining-value</strong></span>) heurisztika lehet hasznos. Ez a heurisztika előnyben részesíti azt az értéket, amely a legkevesebb választást zárja ki a kényszergráfban a szomszédos változóknál. Például tegyük fel, hogy az 5.1. ábra esetében már létrehoztuk az <span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span> és az <span class="emphasis"><em>ÉT </em></span>=<span class="emphasis"><em> zöld</em></span> parciális hozzárendelést, és most <span class="emphasis"><em>Q</em></span> számára akarunk értéket találni. A kék rossz választás volna, mert ez kizárja <span class="emphasis"><em>Q</em></span> szomszédjának, <span class="emphasis"><em>DA</em></span>-nak utolsó megengedett értékét. A legkevésbé korlátozó heurisztika ezért a kékkel szemben a vöröset részesíti előnyben. Általában véve a heurisztika megpróbálja a későbbi változó-hozzárendelések számára a lehető legnagyobb szabadságot meghagyni. Természetesen ha egy probléma összes megoldását meg szeretnénk találni, és nem elégszünk meg csupán eggyel, akkor a sorrend közömbös, hiszen úgyis minden értéknek sorra kell kerülnie. Ugyanez igaz akkor is, ha a problémának nincsen megoldása.</p></div><div class="section" title="Az információ terjesztése a kényszereken keresztül"><div class="titlepage"><div><div><h2 class="title"><a id="id563063"/>Az információ terjesztése a kényszereken keresztül</h2></div></div></div><p>A keresési algoritmusunk eddig csak akkor foglalkozott egy változóra vonatkozó kényszerrel, ha a változót a <code class="code">HOZZÁRENDELETLEN-VÁLTOZÓ-KIVÁLASZTÁS</code> kiválasztotta. De ha néhány kényszert a keresés folyamán korábban vagy akár még a keresés megkezdése előtt megvizsgálunk, akkor drasztikusan csökkenthető a keresési tér mérete.</p><div class="section" title="Előrenéző ellenőrzés"><div class="titlepage"><div><div><h3 class="title"><a id="id563073"/>Előrenéző ellenőrzés</h3></div></div></div><p>A kényszerek keresés közbeni jobb felhasználásának egyik módszerét <span class="strong"><strong>előrenéző ellenőrzés</strong></span>nek (<span class="strong"><strong>forward checking</strong></span>) nevezzük. Az előrenéző ellenőrzési folyamat minden egyes alkalommal, amikor egy <span class="emphasis"><em>X</em></span> változó értéket kap, minden, az <span class="emphasis"><em>X</em></span>-hez kényszerrel kötött, hozzárendeletlen <span class="emphasis"><em>Y</em></span>-t megvizsgál, és <span class="emphasis"><em>Y </em></span>tartományából törli az <span class="emphasis"><em>X</em></span> számára választott értékkel inkonzisztens értékeket. Az 5.6. ábra bemutatja az előrenéző ellenőrzéses keresés menetét a térképszínezési probléma során. Két fontos dolgot kell megemlítenünk ezzel a példával kapcsolatban. Először is vegyük észre, hogy miután elvégeztük az <span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span> és a <span class="emphasis"><em>Q </em></span>=<span class="emphasis"><em> zöld</em></span> hozzárendeléseket, <span class="emphasis"><em>ÉT</em></span> és <span class="emphasis"><em>DA </em></span>tartományai egyetlen elemre szűkültek, és azzal, hogy az <span class="emphasis"><em>NyA</em></span>-ból és a <span class="emphasis"><em>Q</em></span>-ból származó információt terjesztettük, teljesen megszüntettük az ezen változók szerinti elágazást. Az MRV-heurisztika, amely az előrenéző ellenőrzés nyilvánvaló partnere, automatikusan <span class="emphasis"><em>DA</em></span>-t és <span class="emphasis"><em>ÉT</em></span>-t választja következőnek. (Tulajdonképpen még hatékonyabb eljárássá tehetjük az előrenéző ellenőrzést, ha az MRV-heurisztika munkájához szükséges információt inkrementálisan számítjuk.) A másik dolog, amire érdemes felfigyelni, az az, hogy a <span class="emphasis"><em>V </em></span>=<span class="emphasis"><em> kék </em></span>hozzárendelés után <span class="emphasis"><em>DA</em></span> tartománya üres lett. Ezért az előrenéző ellenőrzés megállapítja, hogy a {<span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span>,<span class="emphasis"><em> Q </em></span>=<span class="emphasis"><em>zöld</em></span>,<span class="emphasis"><em> V </em></span>=<span class="emphasis"><em> kék</em></span>} részleges hozzárendelés inkonzisztens a probléma kényszereivel, és az algoritmus azonnal visszalép.</p></div><div class="section" title="A kényszerek terjesztése"><div class="titlepage"><div><div><h3 class="title"><a id="id563175"/>A kényszerek terjesztése</h3></div></div></div><p>Az előrenéző ellenőrzés ugyan sok inkonzisztenciát észrevesz, de nem mindet. Például nézzük csak az 5.6. ábra harmadik sorát. Az látható itt, hogy amikor <span class="emphasis"><em>DA vörös</em></span> és <span class="emphasis"><em>Q zöld</em></span>, mind <span class="emphasis"><em>ÉT</em></span>-nek, mind <span class="emphasis"><em>DA</em></span>-nak kéknek kell lennie. De ezek szomszédosak, és nem lehet azonos az értékük. Az előrenéző ellenőrzés nem veszi észre ezt az inkonzisztenciát, mert nem néz elég messze előre. A <span class="strong"><strong>kényszer</strong></span>ek<span class="strong"><strong> terjesztése</strong></span> (<span class="strong"><strong>constraint propagation</strong></span>) általános kifejezés jelöli azt, ha az egyik változó kényszerének a többi változót érintő következményeit terjesztjük: esetünkben<span class="emphasis"><em> NyA</em></span>-ról<span class="emphasis"><em> Q</em></span>-ra és<span class="emphasis"><em> ÉT</em></span>-ről<span class="emphasis"><em> DA</em></span>-ra kell terjeszteni (ahogy ezt már az előrenéző ellenőrzés is megtette), majd az<span class="emphasis"><em> ÉT</em></span> és<span class="emphasis"><em> DA</em></span> közti kényszerre, hogy észrevehessük az inkonzisztenciát. Ezt pedig gyorsan szeretnénk tenni: semmi értelme a keresés méretét csökkenteni, ha több időt töltünk a kényszerek terjesztésével, mint az egyszerű kereséssel tennénk.</p><div class="figure"><a id="id563231"/><p class="title"><strong>5.6. ábra - A térképszínezés folyamata előrenéző ellenőrzéses keresés esetén. Az első hozzárendelés az <span class="emphasis"><em>NyA</em></span> = <span class="emphasis"><em>vörös,</em></span> majd az előrenéző ellenőrzés törli a <span class="emphasis"><em>vörös</em></span> értéket a szomszédos <span class="emphasis"><em>ÉT</em></span> és <span class="emphasis"><em>DA</em></span> változók tartományaiból. A <span class="emphasis"><em>Q </em></span>=<span class="emphasis"><em> zöld</em></span> hozzárendelés után a <span class="emphasis"><em>zöld</em></span> is kikerül az <span class="emphasis"><em>ÉT</em></span>, <span class="emphasis"><em>DA</em></span> és <span class="emphasis"><em>ÚDW</em></span> változók tartományaiból. A <span class="emphasis"><em>V </em></span>=<span class="emphasis"><em> kék</em></span>-et követően a <span class="emphasis"><em>kék</em></span> is törlődik a <span class="emphasis"><em>DA</em></span> és <span class="emphasis"><em>ÚDW</em></span> változók tartományaiból, és <span class="emphasis"><em>DA</em></span> számára nem marad megengedett érték.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-06.png" alt="A térképszínezés folyamata előrenéző ellenőrzéses keresés esetén. Az első hozzárendelés az NyA = vörös, majd az előrenéző ellenőrzés törli a vörös értéket a szomszédos ÉT és DA változók tartományaiból. A Q = zöld hozzárendelés után a zöld is kikerül az ÉT, DA és ÚDW változók tartományaiból. A V = kék-et követően a kék is törlődik a DA és ÚDW változók tartományaiból, és DA számára nem marad megengedett érték."/></div></div></div><p>Az <span class="strong"><strong>élkonzisztencia</strong></span> (<span class="strong"><strong>arc consistency</strong></span>) alapul szolgálhat egy gyors, az előrenéző ellenőrzésnél lényegesen erősebb kényszerterjesztéshez. Az „él” itt a kényszergráf <span class="emphasis"><em>irányított</em></span> éleit jelenti, amilyen például a <span class="emphasis"><em>DA</em></span>-ból az <span class="emphasis"><em>ÚDW</em></span>-be mutató él. Ha adott <span class="emphasis"><em>DA</em></span> és <span class="emphasis"><em>ÚDW</em></span> aktuális tartománya, akkor ez az él konzisztens, ha <span class="emphasis"><em>DA</em></span> <span class="emphasis"><em>mindegyik x</em></span> értékéhez található egy <span class="emphasis"><em>x</em></span>-szel konzisztens <span class="emphasis"><em>valamilyen y</em></span> érték <span class="emphasis"><em>ÚDW</em></span>-ben. Az 5.6. ábra harmadik sorában <span class="emphasis"><em>DA </em></span>és <span class="emphasis"><em>ÚDW </em></span>pillanatnyi tartománya rendre a {<span class="emphasis"><em>kék</em></span>}, illetve a {<span class="emphasis"><em>vörös, kék</em></span>}. A <span class="emphasis"><em>DA </em></span>= <span class="emphasis"><em>kék </em></span>esetén található egy konzisztens hozzárendelés <span class="emphasis"><em>ÚDW</em></span>-hez, nevezetesen az <span class="emphasis"><em>ÚDW </em></span>= <span class="emphasis"><em>vörös</em></span>; ezért a <span class="emphasis"><em>DA</em></span>-ből <span class="emphasis"><em>ÚDW</em></span>-be mutató él konzisztens. Viszont az <span class="emphasis"><em>ÚDW</em></span>-ből a <span class="emphasis"><em>DA</em></span>-ba mutató él nem konzisztens, mert az <span class="emphasis"><em>ÚDW </em></span>= {<span class="emphasis"><em>kék</em></span>} hozzárendelésnél a <span class="emphasis"><em>DA</em></span>-hoz nem tudunk színt találni. Az él úgy tehető konzisztenssé, hogy az <span class="emphasis"><em>ÚDW </em></span>tartományából töröljük a <span class="emphasis"><em>kék </em></span>értéket.</p><p>A <span class="emphasis"><em>DA</em></span>-ból <span class="emphasis"><em>ÚT</em></span>-be mutató él mentén is alkalmazhatjuk a keresési folyamat ugyanazon fázisában az élkonzisztenciát. Az 5.6. ábra harmadik sora szerint mindkét változó értéktartománya {<span class="emphasis"><em>kék</em></span>}. Ez azt eredményezi, hogy törölnünk kell a <span class="emphasis"><em>kék</em></span>-et <span class="emphasis"><em>DA </em></span>tartományából, amely ezzel kiürül. Az élkonzisztencia ellenőrzés tehát lehetővé teszi, hogy korábban észrevegyük az egyszerű előrenéző ellenőrzés által fel nem fedett inkonzisztenciát.</p><p>Az élkonzisztencia-ellenőrzés alkalmazható előfeldolgozó lépésként a keresés megkezdése előtt, vagy a keresési folyamat minden egyes hozzárendelését követő terjesztési lépésként (az előrenéző ellenőrzéshez hasonlóan). (Az utóbbi algoritmust <span class="emphasis"><em>Élkonzisztencia fenntartásának</em></span> is, angol rövidítéssel MAC-nak nevezik.) Mindkét esetben addig kell <span class="emphasis"><em>ismételve</em></span> alkalmazni a folyamatot, amíg nem marad inkonzisztencia. Erre azért van szükség, mert amikor egy élinkonzisztenciát eltávolítandó egy érték kikerül egy változó tartományából, az ehhez a változóhoz mutató éleknél új inkonzisztencia jöhet létre. Az AC-3, az élkonzisztencia teljes algoritmusa egy sort használ annak nyilvántartására, hogy mely élek inkonzisztenciáját kell még ellenőriznie (lásd 5.7. ábra). Minden egyes (<span class="emphasis"><em>X<sub>i</sub></em></span>, <span class="emphasis"><em>X<sub>j</sub></em></span>) élet sorban egyenként levesszük a tennivalók listájáról és ellenőrizzük; ha pedig <span class="emphasis"><em>X<sub>i</sub> </em></span>tartományának bármely változóját törölni kell, akkor minden <span class="emphasis"><em>X<sub>i</sub> </em></span>-be mutató (<span class="emphasis"><em>X<sub>k</sub></em></span>, <span class="emphasis"><em>X<sub>i</sub></em></span>) élet visszateszünk ellenőrzésre a sorba. Az élkonzisztencia-ellenőrzés komplexitása az alábbiak szerint vizsgálható: egy bináris kényszerkielégítési problémában legfeljebb <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) él van; minden egyes (<span class="emphasis"><em>X<sub>k</sub></em></span>, <span class="emphasis"><em>X<sub>i</sub></em></span>) él csak <span class="emphasis"><em>d</em></span> alkalommal kerülhet napirendre, mert <span class="emphasis"><em>X<sub>i</sub></em></span>-ben<span class="emphasis"><em> </em></span>összesen <span class="emphasis"><em>d</em></span> törölhető érték van; egy él konzisztenciájának ellenőrzése elvégezhető <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d</em></span><sup>2</sup>)<span class="emphasis"><em> </em></span>időben; tehát a legrosszabb esetben vett teljes idő <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup><span class="emphasis"><em>d</em></span><sup>3</sup>). Ez ugyan lényegesen költségesebb, mint az előretekintő ellenőrzés, de az extra költség általában kifizetődik.<sup>[<a id="id564501" href="#ftn.id564501" class="footnote">48</a>]</sup></p><a id="ID_193_oldal"/><div class="figure"><a id="id564522"/><p class="title"><strong>5.7. ábra - Az AC-3 élkonzisztencia algoritmus. Az AC-3 alkalmazását követően vagy mindegyik él élkonzisztens, vagy néhány változó tartománya üres, azaz a kényszerkielégítési probléma nem hozható élkonzisztens alakra (tehát nem oldható meg). Az „AC-3” nevet az algoritmus kitalálója (Mackworth, 1977) vezette be, mert ezt az algoritmust mutatta be cikkében harmadikként.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-07.png" alt="Az AC-3 élkonzisztencia algoritmus. Az AC-3 alkalmazását követően vagy mindegyik él élkonzisztens, vagy néhány változó tartománya üres, azaz a kényszerkielégítési probléma nem hozható élkonzisztens alakra (tehát nem oldható meg). Az „AC-3” nevet az algoritmus kitalálója (Mackworth, 1977) vezette be, mert ezt az algoritmust mutatta be cikkében harmadikként."/></div></div></div><p>Mivel a kényszerkielégítési problémák speciális esetként tartalmazzák a 3SAT-ot, ezért nem várhatjuk, hogy polinom idejű algoritmust találunk annak eldöntésére, hogy egy adott kényszerkielégítési probléma konzisztens-e. Ebből arra következtethetünk, hogy az élkonzisztencia nem tár fel minden lehetséges inkonzisztenciát. Például az 5.1. ábrán az {<span class="emphasis"><em>NyA </em></span>=<span xml:lang="pl" class="emphasis"><em> vörös, ÚDW </em></span>=<span class="emphasis"><em> vörös</em></span>} részleges hozzárendelés inkonzisztens, de az AC-3 nem találja meg. Definiálható a terjesztés erősebb formája is, amit <span class="bold"><strong><span class="emphasis"><em>k</em></span>-konzisztenciá</strong></span>nak (<span class="bold"><strong><span class="emphasis"><em>k-</em></span>consistency</strong></span>) nevezünk. Egy kényszerkielégítési probléma akkor <span class="emphasis"><em>k</em></span>-konzisztens, ha bármely <span class="emphasis"><em>k – </em></span>1<span class="emphasis"><em> </em></span>változóból álló halmaz és ezen változók bármely konzisztens hozzárendelése esetén mindig lehet a <span class="emphasis"><em>k</em></span>-adik változónak konzisztens értéket találni. Az 1-konzisztencia például azt jelenti, hogy mindegyik individuális változó önmagában véve is konzisztens; ezt <span class="strong"><strong>csomópont-konzisztenciá</strong></span>nak (<span class="strong"><strong>node consistency</strong></span>) is nevezik. A 2-konzisztencia ugyanaz, mint az élkonzisztencia. A 3-konzisztencia azt jelenti, hogy egymás melletti változók bármely párja mindig kiterjeszthető egy szomszédos változóra; ezt <span class="strong"><strong>útvonal-konzisztenciá</strong></span>nak (<span class="strong"><strong>path consistency</strong></span>) is nevezik.</p><p>Egy gráf <span class="bold"><strong>erősen <span class="emphasis"><em>k-</em></span>konzisztens </strong></span>akkor, ha <span class="emphasis"><em>k</em></span>-konzisztens, valamint (<span class="emphasis"><em>k – </em></span>1)-konzisztens, (<span class="emphasis"><em>k – </em></span>2)-konzisztens és így tovább le egészen az 1-konzisztenciáig. Tegyük fel most, hogy van egy <span class="emphasis"><em>n</em></span> csomópontból álló kényszerkielégítési problémánk, és tegyük erősen <span class="emphasis"><em>n</em></span>-konzisztenssé (azaz <span class="emphasis"><em>k</em></span>-konzisztenssé <span class="emphasis"><em>k </em></span>=<span class="emphasis"><em> n</em></span> esetében). Ekkor visszalépés nélkül megoldhatjuk a problémát. Először egy konzisztens értéket választunk <span class="emphasis"><em>X</em></span><sub>1</sub> számára. Ezután garanciánk van arra, hogy tudunk <span class="emphasis"><em>X</em></span><sub>2</sub> számára értéket választani, mert a gráf 2-konzisztens, <span class="emphasis"><em>X</em></span><sub>3</sub> számára, mert a gráf 3-konzisztens és így tovább. Minden egyes <span class="emphasis"><em>X<sub>i </sub></em></span>változó esetén csak <span class="emphasis"><em>d</em></span> értéket kell ellenőriznünk a tartományból, hogy egy X<sub>1 </sub>,..., <span class="emphasis"><em>X</em></span><sub><span class="emphasis"><em>i</em></span>–1</sub>-gyel konzisztens értéket találjunk. Garanciánk van tehát arra, hogy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>nd</em></span>) időben megoldást találunk. Persze semmit sem adnak ingyen: az <span class="emphasis"><em>n</em></span>-konzisztenciát biztosító bármely algoritmus legrosszabb esetben <span class="emphasis"><em>n</em></span>-ben exponenciális lesz.</p><p>Az <span class="emphasis"><em>n</em></span>-konzisztencia és az élkonzisztencia között egy széles köztes mező húzódik: az erősebb konzisztencia-ellenőrzések futtatása tovább fog tartani, de több eredménnyel jár az elágazási tényező csökkentésében és az inkonzisztens részleges hozzárendelések felderítésében. Ki lehet számolni a legkisebb olyan <span class="emphasis"><em>k</em></span> értéket, melyre a <span class="emphasis"><em>k</em></span>-konzisztencia ellenőrzésének futtatása visszalépés nélküli problémamegoldást tesz lehetővé (lásd 5.4. alfejezet), de ez gyakran nem célszerű. A legmegfelelőbb konzisztencia-ellenőrzési szint kiválasztása valójában leginkább empirikus tudomány.</p></div><div class="section" title="Speciális kényszerek kezelése"><div class="titlepage"><div><div><h3 class="title"><a id="id564701"/>Speciális kényszerek kezelése</h3></div></div></div><p>A kényszerek bizonyos típusai gyakran fordulnak elő a valós problémákban és speciális célú algoritmusokkal jóval hatékonyabban kezelhetők, mint az eddig leírt általános célú módszerekkel. Például a <span class="emphasis"><em>MindKül</em></span> kényszer azt állítja, hogy a benne szereplő öszszes változóknak mind különböző értéket kell felvennie (ahogy a betűrejtvényes példában láttuk). A <span class="emphasis"><em>MindKül</em></span> kényszer inkonzisztencia-ellenőrzésére egy egyszerű módszer az, hogy ha <span class="emphasis"><em>m</em></span> változó szerepel a kényszerben, és ha ezeknek együttesen <span class="emphasis"><em>n</em></span> különböző értéke lehet, akkor <span class="emphasis"><em>m </em></span>&gt;<span class="emphasis"><em> n </em></span>esetén a kényszert nem lehet kielégíteni.</p><p>Ez a következő egyszerű algoritmushoz vezet: először vegyünk ki a kényszerből minden változót, amelynek egyelemű tartománya van, és vegyük ki ezeknek a változóknak az értékeit a megmaradó változók tartományaiból. Ismételjük ezt a lépést mindaddig, amíg van ilyen változónk. Ha bármely ponton egy üres tartomány jön létre, vagy több változónk marad, mint értékünk a tartományban, akkor egy inkonzisztenciát derítettünk fel.</p><p>Ezt a módszert használhatjuk arra, hogy az 5.1. ábra {<span class="emphasis"><em>NyA </em></span>=<span xml:lang="pl" class="emphasis"><em> vörös, ÚDW </em></span>=<span class="emphasis"><em> vörös</em></span>} részleges hozzárendelésében észrevegyük az inkonzisztenciát. Figyeljünk fel arra, hogy a <span class="emphasis"><em>DA</em></span>,<span class="emphasis"><em> </em></span>az <span class="emphasis"><em>ÚT </em></span>és a <span class="emphasis"><em>Q </em></span>változók lényegében egy <span class="emphasis"><em>MindKül</em></span> kényszerrel vannak összekötve, mert mindegyik párnak különböző színűnek kell lennie. Miután alkalmaztuk az AC-3-at a részleges hozzárendelésre, az egyes változók tartománya a {<span class="emphasis"><em>zöld</em></span>, <span class="emphasis"><em>kék</em></span>} tartományra szűkült le. Azaz három változónk van és csupán két színünk, tehát megszegtük a <span class="emphasis"><em>MindKül</em></span> kényszert. Tehát a magasabb szintű kényszerekre alkalmazott egyszerű konzisztencia-ellenőrzések néha hatékonyabbak, mintha az ekvivalens bináris kényszerek halmazára vizsgáltuk volna az élkonzisztenciát.</p><p>A legfontosabb magasabb rendű kényszer talán az <span class="strong"><strong>erőforráskényszer</strong></span> (<span class="strong"><strong>resource constraint</strong></span>), amit néha <span class="emphasis"><em>legfeljebb</em></span> kényszernek is neveznek. Jelölje például <span class="emphasis"><em>PA</em></span><sub>1</sub>, ..., <span class="emphasis"><em>PA</em></span><sub>4</sub> rendre négy feladathoz hozzárendelt személyzet számát. Azt a kényszert, miszerint öszszesen nem lehet 10-nél több embernek feladatot adni, így írhatjuk fel: <span class="emphasis"><em>legfeljebb</em></span>(10, <span class="emphasis"><em>PA</em></span><sub>1</sub>, <span class="emphasis"><em>PA</em></span><sub>2</sub>, <span class="emphasis"><em>PA</em></span><sub>3</sub>, <span class="emphasis"><em>PA</em></span><sub>4</sub>). Az inkonzisztenciát egyszerűen ki lehet mutatni az aktuális tartományok minimális értékeinek összegzésével: ha például mindegyik változó tartománya a {3, 4, 5, 6}, akkor a <span class="emphasis"><em>legfeljebb </em></span>kényszert nem lehet kielégíteni. A konzisztenciát azáltal is érvényesíthetjük, hogy töröljük bármely tartomány maximális értékét, amely nem konzisztens az összes többi tartomány minimális értékével. Így ha példánkban mindegyik változónak {2, 3, 4, 5, 6} a tartománya, akkor az 5 és a 6 értékeket mindegyik tartományból törölni lehet.</p><p>A nagy erőforrás-korlátozott egész értékű problémáknál – ilyenek például az emberek ezreit és járművek százait mozgató logisztikai problémák – általában nem tehető meg az, hogy mindegyik változó tartományát egy nagy egészhalmazzal ábrázoljuk, majd ezt a halmazt a konzisztencia-ellenőrző módszerek segítségével fokozatosan csökkentjük. Ehelyett a tartományokat az alsó és a felső határaikkal ábrázoljuk, és határterjesztés segítségével kezeljük. Tegyük fel például, hogy két repülőjárat van, a 271-es és a 272-es, amelyekre a repülőgépek kapacitása rendre 165 és 385. A repülőjárat utasszámának kezdeti tartománya tehát</p><p><code class="code"><em><span class="remark">Járat</span></em>271<em><span class="remark"> </span></em>∈ [0, 165] és <em><span class="remark">Járat</span></em>272 ∈ [0, 385]</code></p><p>Tegyük fel most, hogy van egy külön korlát, miszerint a két járatnak együtt 420 embert kell szállítania. <span class="emphasis"><em>Járat</em></span>271<span class="emphasis"><em> </em></span>+<span class="emphasis"><em> Járat</em></span>272 ∈ [420, 420]. A határkényszereket terjesztve a tartományokat a következőkre csökkentjük:</p><p><code class="code"><em><span class="remark">Járat</span></em>271<em><span class="remark"> </span></em>∈ [35, 165] és <em><span class="remark">Járat</span></em>272 ∈ [225, 385]</code></p><p>Akkor nevezünk egy kényszerkielégítési problémát határkonzisztensnek, ha minden <span class="emphasis"><em>X</em></span> változóra ennek a változónak mind az alsó, mind a felső határértékére található minden <span class="emphasis"><em>Y</em></span> változóhoz olyan érték, amely kielégíti az <span class="emphasis"><em>X</em></span> és <span class="emphasis"><em>Y</em></span> közti kényszereket. Ezt a fajta <span class="strong"><strong>kényszerterjesztés</strong></span>t (<span class="strong"><strong>bound propagation</strong></span>) széles körben használják a gyakorlati kényszerkielégítési problémák során.</p></div></div><div class="section" title="Intelligens visszalépés: visszanézni"><div class="titlepage"><div><div><h2 class="title"><a id="id564903"/>Intelligens visszalépés: visszanézni</h2></div></div></div><p>Az 5.3. ábra <code class="code">VISSZALÉPÉSES-KERESÉS</code> algoritmusa egy elég egyszerű intézkedést alkalmaz akkor, amikor egy keresési ág meghiúsul: visszalép az előző változóra, és megpróbál számára egy másik értéket találni. Ezt <span class="strong"><strong>időrendi visszalépés</strong></span>nek (<span class="strong"><strong>chronological backtracking</strong></span>) nevezik, mert a <span class="emphasis"><em>legutolsó</em></span> döntési pontot keresi fel újra. Ebben az alrészben látni fogjuk, hogy adódik erre sokkal jobb módszer is.</p><p>Nézzük meg, mi történik, amikor az egyszerű visszalépéses algoritmust az 5.1. ábrán látható problémára alkalmazzuk rögzített változósorrenddel (<span class="emphasis"><em>Q</em></span>,<span class="emphasis"><em> ÚDW</em></span>,<span class="emphasis"><em> V</em></span>,<span class="emphasis"><em> T, DA</em></span>,<span class="emphasis"><em> NyA</em></span>,<span class="emphasis"><em> ÚT</em></span>). Tegyük fel, hogy már létrehoztuk a {<span class="emphasis"><em>Q </em></span>=<span class="emphasis"><em> vörös, ÚDW = zöld</em></span>,<span class="emphasis"><em> V </em></span>=<span class="emphasis"><em> kék</em></span>,<span class="emphasis"><em> T </em></span>=<span class="emphasis"><em> vörös</em></span>} hozzárendelést. Amikor a következő változóval, <span class="emphasis"><em>DA</em></span>-val próbálkozunk, azt látjuk, hogy mindegyik érték sérti a kényszert. Visszalépünk <span class="emphasis"><em>T</em></span>-re, és egy új színt keresünk Tasmania számára. Ez nyilvánvalóan butaság: Tasmania átszínezése nem oldja meg a Dél-Ausztráliával kapcsolatos problémát.</p><p>A visszalépéses megközelítés intelligens alkalmazása lenne, ha ahhoz a változóhalmazhoz mennénk vissza, amely a <span class="emphasis"><em>meghiúsulást okozta</em></span>. Ezt a halmazt <span class="strong"><strong>konfliktushalmaz</strong></span>nak (<span class="strong"><strong>conflict set</strong></span>) nevezik; esetünkben a <span class="emphasis"><em>DA</em></span>-hoz tartozó konfliktushalmaz a {<span class="emphasis"><em>Q, ÚDW, V</em></span>}. Általános esetben egy <span class="emphasis"><em>X</em></span> változó konfliktushalmaza a korábban értéket kapott változók egy halmaza, melyeket <span class="emphasis"><em>X</em></span>-hez kényszerek kötnek. A <span class="strong"><strong>visszaugrás </strong></span>(<span class="strong"><strong>backjump</strong></span><span class="strong"><strong>ing</strong></span>) a konfliktushalmaz-beli legutolsó változóhoz lép vissza; esetünkben a visszaugrás átugorná Tasmaniát, és <span class="emphasis"><em>V</em></span> számára próbálna új értéket keresni. Ezt egyszerű implementálni a <code class="code">VISSZALÉPÉSES-KERESÉS</code> olyan módosításával, hogy az összegyűjtse a konfliktushalmazt, miközben hozzárendelhető értékeket keres. Ha nem talál ilyen értéket, akkor a konfliktushalmaz legutolsó elemét kell visszaadnia (a meghiúsulás jelzésével együtt).</p><p>Az éles szemű olvasónak feltűnhetett, hogy az előrenéző ellenőrzés a konfliktushalmazt minden külön munka nélkül előállíthatja: mindig amikor az előrenéző ellenőrzés <span class="emphasis"><em>X</em></span> egy hozzárendelésén alapulva <span class="emphasis"><em>Y</em></span> tartományából kitöröl egy elemet, <span class="emphasis"><em>X</em></span>-et hozzá kell adnia <span class="emphasis"><em>Y</em></span> konfliktushalmazához. Ezenkívül még minden esetben, amikor az utolsó értéket törli <span class="emphasis"><em>Y</em></span> tartományából, az <span class="emphasis"><em>Y</em></span> konfliktushalmazában szereplő változókat hozzá kell adnia <span class="emphasis"><em>X</em></span> konfliktushalmazához. Ezek után mihelyt <span class="emphasis"><em>Y</em></span>-hoz jutunk, már azonnal ismerni fogjuk, hogy hova lépjünk vissza, ha erre szükség van.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A sasszemű olvasónak valami furcsaság is feltűnhetett: a visszaugrás akkor következik be, amikor egy tartomány minden értéke konfliktusban van az aktuális hozzárendelésekkel, de az előrenéző ellenőrzés felismeri ezt az eseményt, és megakadályozza, hogy valaha is ilyen csomóponthoz jussunk! Valóban, meg lehet mutatni, hogy <span class="emphasis"><em>a visszaugrás által levágott minden ágat az előrenéző ellenőrzés is levágja</em></span>. Tehát az egyszerű visszaugrás redundáns az előrenéző ellenőrzés során, vagy pontosabban szólva, egy olyan keresésnél, amely erősebb konzisztencia-ellenőrzést, például MAC-ot használ.</p></div><p>Az előző bekezdés megfigyelése ellenére a visszaugrás mögötti ötlet továbbra is használható marad: lépjünk vissza a hiba helyére. A visszaugrás akkor veszi észre a kudarcot, amikor egy változó értéktartománya üressé válik, de sok esetben egy ág már sokkal korábban levágásra lett ítélve. Tekintsük ismét az {<span class="emphasis"><em>NyA </em></span>=<span xml:lang="pl" class="emphasis"><em> vörös, ÚDW </em></span>=<span class="emphasis"><em> vörös</em></span>} részleges hozzárendelést (amelyik, korábbi megjegyzéseink értelmében, inkonzisztens). Tegyük fel, hogy a <span class="emphasis"><em>T </em></span>=<span class="emphasis"><em> vörös</em></span>-t próbáljuk, majd az <span class="emphasis"><em>ÚT</em></span>,<span class="emphasis"><em> Q</em></span>,<span class="emphasis"><em> V</em></span>,<span class="emphasis"><em> DA-</em></span>kra alkalmazzunk<span class="emphasis"><em> </em></span>hozzárendeléseket. Tudjuk, hogy az utóbbi négy változó esetén semmilyen hozzárendelés sem lesz jó, így végül <span class="emphasis"><em>ÚT</em></span> próbálgatásánál kifogyunk az értékekből. A kérdés most az, hogy hova lépjünk vissza? A visszaugrás nem fog működni, mert <span class="emphasis"><em>ÚT</em></span>-nek <span class="emphasis"><em>igenis</em></span> van az előző hozzárendelésekkel konzisztens értéke: <span class="emphasis"><em>ÚT</em></span> esetén nincsen teljes konfliktushalmaz a megelőző változók között, amely felelős lenne a kudarcért. Tudjuk azonban, hogy a négy változó, <span class="emphasis"><em>ÚT</em></span>,<span class="emphasis"><em> Q</em></span>,<span class="emphasis"><em> V</em></span>,<span class="emphasis"><em> </em></span>és <span class="emphasis"><em>DA</em></span> <span class="emphasis"><em>együttvéve</em></span> a megelőző változók egy halmaza miatt hiúsul meg, és ezek azok a változók, amelyek közvetlenül konfliktusban állnak a kérdéses néggyel. Ennek alapján <span class="emphasis"><em>ÚT</em></span> konfliktushalmazának egy mélyebb megértéséhez jutottunk: a konfliktushalmaz a megelőző változók azon halmaza, ami <span class="emphasis"><em>bármely következő változóval együtt</em></span> felelős <span class="emphasis"><em>ÚT</em></span> konzisztens megoldásának kudarcáért. Esetünkben ez a halmaz az <span class="emphasis"><em>NyA</em></span> és az <span class="emphasis"><em>ÚDW</em></span>, tehát az algoritmusnak <span class="emphasis"><em>ÚDW</em></span>-hez kell visszalépnie átugorva Tasmaniát. A konfliktushalmaz ilyen definíciójára támaszkodó visszaugrási algoritmust nevezzük <span class="strong"><strong>konfliktusvezérelt visszaugrás</strong></span>nak (<span class="strong"><strong>conflict-directed backjumping</strong></span>).</p><p>Magyarázatot kell most adnunk arra, hogy miként lehet kiszámítani ezeket az újfajta konfliktushalmazokat. A módszer valójában nagyon egyszerű. Egy keresési ág „terminálási” kudarca mindig azért következik be, mert egy változó tartománya kiürül, ennek a változónak pedig egy szokásos konfliktushalmaza van. Példánkban <span class="emphasis"><em>DA</em></span> hiúsul meg, és konfliktushalmaza (mondjuk) az {<span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÚT</em></span>,<span class="emphasis"><em> Q</em></span>}. Visszaugrunk <span class="emphasis"><em>Q</em></span>-ra, és <span class="emphasis"><em>Q beépíti </em></span>saját közvetlen konfliktushalmazába (ami az {<span class="emphasis"><em>ÚT</em></span>,<span class="emphasis"><em> ÚDW</em></span>}) <span class="emphasis"><em>DA</em></span> konfliktushalmazát (leszámítva persze <span class="emphasis"><em>Q</em></span>-t magát), és így előáll az {<span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÚT</em></span>,<span class="emphasis"><em> ÚDW</em></span>} konfliktushalmaz. Azaz <span class="emphasis"><em>Q</em></span>-tól számítva tovább már nincsen megoldás feltételezve {<span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÚT</em></span>,<span class="emphasis"><em> ÚDW</em></span>} korábbi hozzárendeléseit. Tehát visszalépünk <span class="emphasis"><em>ÚT</em></span>-re, amelyik a legutóbbi ezek közül. <span class="emphasis"><em>ÚT</em></span> felveszi {<span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÚT</em></span>,<span class="emphasis"><em> ÚDW</em></span>} – {<span class="emphasis"><em>ÚT</em></span>}-t a saját közvetlen konfliktushalmazába, {<span class="emphasis"><em>NyA</em></span>}-ba, és előáll az {<span class="emphasis"><em>NyA</em></span>,<span class="emphasis"><em> ÚDW</em></span>} konfliktushalmaz (ahogy az előző bekezdésben állítottuk). Foglaljuk össze az eddig mondottakat: jelölje <span class="emphasis"><em>X<sub>j</sub></em></span> az aktuális változót és <span class="emphasis"><em>conf</em></span>(<span class="emphasis"><em>X<sub>j</sub></em></span>) a saját konfliktushalmazát. Ha <span class="emphasis"><em>X</em></span><sub><span class="emphasis"><em>j</em></span> </sub>minden lehetséges értéke meghiúsul, ugorjunk vissza a <span class="emphasis"><em>conf</em></span>(<span class="emphasis"><em>X<sub>j</sub></em></span>)-beli legutolsó <span class="emphasis"><em>X<sub>i</sub></em></span> értékre és legyen</p><p><code class="code"><em><span class="remark">conf</span></em>(<em><span class="remark">X<sub>i</sub></span></em>) ← <em><span class="remark">conf</span></em>(<em><span class="remark">X<sub>i</sub></span></em>) ∪ <em><span class="remark">conf</span></em>(<em><span class="remark">X<sub>j</sub></span></em>) – {<em><span class="remark">X<sub>i</sub></span></em>}</code></p><p>A konfliktusvezérelt visszaugrás a keresési fa megfelelő helyére visz vissza, de nem akadályozza meg, hogy ugyanazt a hibát elkövessük a fa egy másik ágán. A <span class="strong"><strong>kényszertanulás</strong></span> (<span class="strong"><strong>constraint learning</strong></span>) a konfliktusból kiemelt új kényszer megtanulásával módosítja a kényszerkielégítési problémát.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id564501" href="#id564501" class="para">48</a>] </sup> A Mohr és Henderson (Mohr és Henderson, 1986) bemutatta AC-4 algoritmus <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup><span class="emphasis"><em>d</em></span><sup>2</sup>) alatt fut. (Lásd 5.10. feladat.)</p></div></div></div></body></html>
