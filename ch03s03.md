<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Megoldások keresése"><div class="titlepage"><div><div><h1 class="title"><a id="id545250"/>Megoldások keresése</h1></div></div></div><p>Az előzőkben láttuk, hogyan kell egy problémát definiálni. A hátralévő lépés – a megoldás megkeresése – az állapottérben végrehajtott kereséssel történik. Ebben a részben olyan keresési technikákkal foglalkozunk, amelyek egy explicit <span class="strong"><strong>keresési fá</strong></span>t (<span class="strong"><strong>search tree</strong></span>) használnak, amelyet az állapotteret együttesen definiáló kezdeti állapotból és az állapotátmenet-függvényből generálnak. Általánosságban, ha egy állapotot több úton is elérhetünk, inkább keresési <span class="emphasis"><em>gráfról,</em></span> mint keresési <span class="emphasis"><em>fáról</em></span> beszélünk. Ezzel az igen fontos bonyolítással később a 3.5. alfejezetben foglalkozunk. </p><div class="figure"><a id="id545273"/><p class="title"><strong>3.6. ábra - Az Arad és Bukarest közötti útkeresési probléma részleges keresési fái. A kifejtett csomópontokat árnyékoltuk, a legenerált, de még ki nem fejtett csomópontok vastagon keretezettek, a még le nem generált csomópontokat pedig halvány szaggatott vonalak jelzik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-06.png" alt="Az Arad és Bukarest közötti útkeresési probléma részleges keresési fái. A kifejtett csomópontokat árnyékoltuk, a legenerált, de még ki nem fejtett csomópontok vastagon keretezettek, a még le nem generált csomópontokat pedig halvány szaggatott vonalak jelzik."/></div></div></div><p>A 3.6. ábrán láthatjuk az Arad és Bukarest közötti útkereső probléma keresési fájának egy kezdeti kifejtését. A keresési fa gyökere az a <span class="strong"><strong>keresési csomópont</strong></span> (<span class="strong"><strong>search node</strong></span>), amely a <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Arad</em></span>) kezdeti állapotnak felel meg. Az első lépés annak ellenőrzése, hogy vajon ez célállapot-e. Nyilvánvalóan nem az, de fontos ellenőrizni, hogy meg tudjuk oldani az olyan beugrató problémákat is, mint amilyen például az „Aradról indulva jussunk el Aradra”. Mivel ez nem célállapot, egyéb állapotokat is meg kell vizsgálnunk. Ezt az aktuális állapot <span class="strong"><strong>kifejtés</strong></span>ével (<span class="strong"><strong>expanding</strong></span>) tesszük, azaz az állapotátmenet-függvénynek az aktuális állapotra történő alkalmazásával, amivel az állapotok egy új halmazát <span class="strong"><strong>generáljuk</strong></span> (<span class="strong"><strong>generating</strong></span>). Ebben az esetben három új állapotot kapunk: <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Nagyszeben</em></span>), <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Temesvár</em></span>) és <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Nagyzerénd</em></span>). Most el kell döntenünk, hogy a három lehetőség közül melyik utat kövessük.</p><p>A keresés lényege a következő: egy lehetőséget kiválasztani, és a többit későbbre halasztani arra az eshetőségre, ha az első választás nem vezetne megoldásra. Tételezzük fel, hogy elsőnek Nagyszebent választjuk. Ellenőrizzük, hogy ez célállapot-e (nem az), majd kifejtjük, aminek hatására a <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Arad</em></span>), <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Fogaras</em></span>), <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Nagyvárad</em></span>) és <span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>RimnicuVilcea</em></span>) állapotokat kapjuk. Ezek után e négy közül bármelyiket választhatjuk, vagy akár vissza is mehetünk és választhatjuk Nagyzeréndet vagy Temesvárt. Folytatjuk a kiválasztást, a célállapot-ellenőrzést és a kifejtést, míg egy megoldást nem találunk, vagy amíg el nem fogynak a kifejtendő állapotok. A kifejtendő állapot kiválasztását a <span class="strong"><strong>keresési stratégia</strong></span> (<span class="strong"><strong>search strategy</strong></span>) határozza meg. Az általános fakereső algoritmus informális megfogalmazását a 3.7. ábra mutatja.</p><div class="figure"><a id="id545383"/><p class="title"><strong>3.7. ábra - Az általános fakeresési algoritmus informális leírása</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-07.png" alt="Az általános fakeresési algoritmus informális leírása"/></div></div></div><p>Fontos megkülönböztetni az állapotteret és a keresési fát. Az útkeresési probléma esetében az állapottér csak 20 állapotból áll, minden egyes városhoz tartozik egy állapot. Ebben az állapottérben azonban végtelen sok út vezet, így a keresési fa végtelen sok csomópontból áll. Például az Arad–Nagyszeben, Arad–Nagyszeben–Arad, Arad– Nagyszeben–Arad–Nagyszeben három út az első három a végtelen számú útszekvenciából. (Egy jó keresési algoritmus nyilvánvalóan elkerüli az ilyen utak követését. A 3.5. alfejezetben megmutatjuk hogyan.)</p><p>A csomópontokat sokféle módon lehet reprezentálni, de mi feltételezzük, hogy egy csomópont egy öt komponensből álló adatszerkezet:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><code class="code">ÁLLAPOT</code>: az állapottérnek a csomóponthoz tartozó állapota;</p></li><li class="listitem"><p class="List Paragraph"><code class="code">SZÜLŐ-CSOMÓPONT</code>: a keresési fa azon csomópontja, amely a kérdéses csomópontot generálta;</p></li><li class="listitem"><p class="List Paragraph"><code class="code">CSELEKVÉS</code>: a csomópont szülő-csomópontjára alkalmazott cselekvés;</p></li><li class="listitem"><p class="List Paragraph"><code class="code">ÚT-KÖLTSÉG</code>: a kezdeti állapotból a kérdéses csomópontig vezető út általában <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>)-nel jelölt költsége, ahogy ezt a szülőmutatók jelzik;</p></li><li class="listitem"><p class="List Paragraph"><code class="code"> MÉLYSÉG</code>: a kezdeti állapotból vezető út lépéseinek a száma.</p></li></ul></div><p>Fontos visszaidéznünk a csomópontok és az állapotok közti különbséget. A csomópont egy adatnyilvántartásra használt adatszerkezet, amit egy keresési fa leírására használunk. Egy állapot a világ egy konfigurációja. Így a csomópontok a <code class="code">SZÜLŐ-CSOMÓPONT</code> mutatók által definiált meghatározott úton találhatók, míg az állapotok nem. Továbbá könnyen előfordulhat, hogy két különböző csomópont egyazon állapotot tartalmaz, ha ezt az állapotot két különböző cselekvéssorozattal generálták le. A csomópont-adatstruktúrát a 3.8. ábra mutatja.</p><div class="figure"><a id="id545451"/><p class="title"><strong>3.8. ábra - A keresési fa alapvető építő adatstruktúrái a csomópontok. Minden csomópontnak van szülője, állapota és számos adminisztráló adatmezeje. A nyilak a gyerekektől a szülőkig mutatnak.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-08.png" alt="A keresési fa alapvető építő adatstruktúrái a csomópontok. Minden csomópontnak van szülője, állapota és számos adminisztráló adatmezeje. A nyilak a gyerekektől a szülőkig mutatnak."/></div></div></div><p>Valahogy nyilván kell tartanunk a legenerált, kifejtésre váró csomópontokat is – ezt a gyűjteményt, listát <span class="strong"><strong>perem</strong></span>nek (<span class="strong"><strong>fringe</strong></span>) nevezik. A perem minden eleme egy <span class="strong"><strong>levélcsomópont</strong></span> (<span class="strong"><strong>leaf node</strong></span>), azaz egy olyan csomópont, amelynek a fában nincsenek követői. A 3.6. ábrán a fák pereme a vastagon bekeretezett csomópontokból áll. A perem legegyszerűbb reprezentációja egy csomóponthalmaz lenne. A keresési stratéga ekkor olyan függvény lenne, amely a következő lépésben kifejtendő csomópontot ebből a halmazból választaná ki. Bár elvi szempontból ez nyilvánvaló megoldás, számításigény szempontjából drága lenne, mert a keresési stratégia függvénynek a halmaz minden egyes elemét végig kellene néznie, hogy ki tudja választani a legjobb csomópontot. Ezért a továbbiakban feltesszük, hogy a csomópontgyűjtemény egy <span class="strong"><strong>várakozási sor</strong></span>ként (<span class="strong"><strong>queue</strong></span>) van megvalósítva. A soron végezhető műveletek az alábbiak:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><code class="code">SORT-LÉTREHOZ</code>(<span class="emphasis"><em>elem, …</em></span>) létrehoz egy az adott elemeket tartalmazó sort.</p></li><li class="listitem"><p class="List Paragraph"><code class="code">ÜRES?</code>(<span class="emphasis"><em>sor</em></span>) csak akkor ad vissza igaz értéket, ha a sor üres. </p></li><li class="listitem"><p class="List Paragraph"><code class="code">ELSŐ-ELEM</code>(<span class="emphasis"><em>sor</em></span>) visszaadja a sor első elemét.</p></li><li class="listitem"><p class="List Paragraph"><code class="code">TÁVOLÍTSD-EL-AZ-ELSŐ-ELEMET</code>(<span class="emphasis"><em>sor</em></span>) visszaadja az <code class="code">ELSŐ-ELEM</code>(<span class="emphasis"><em>sor</em></span>)-t és ezt eltávolítja a sorból.</p></li><li class="listitem"><p class="List Paragraph"><code class="code">BESZÚR</code>(<span class="emphasis"><em>elem</em></span>, <span class="emphasis"><em>sor</em></span>) egy elemet szúr be a sorba. </p></li><li class="listitem"><p class="List Paragraph"><code class="code">BESZÚR-MIND</code>(<span class="emphasis"><em>elemek</em></span>, <span class="emphasis"><em>sor</em></span>) egy elemhalmazt beszúr a sorba. </p></li></ul></div><p>Ezen definíciók felhasználásával az általános fakeresési algoritmus egy formálisabb definícióját adhatjuk meg. Ezt a 3.9. ábra<span class="emphasis"><em> </em></span>mutatja.</p><div class="figure"><a id="id545583"/><p class="title"><strong>3.9. ábra - Az általános fakeresési algoritmus. (Vegyük észre, hogy a <span class="emphasis"><em>perem</em></span> argumentumnak egy üres sornak kell lennie, és a sor típusa befolyással lesz a keresés sorrendjére.) A <code class="code">MEGOLDÁS</code> függvény a szülőmutatók gyökérig való követésével kinyert cselekvéssorozatot adja vissza.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-09.png" alt="Az általános fakeresési algoritmus. (Vegyük észre, hogy a perem argumentumnak egy üres sornak kell lennie, és a sor típusa befolyással lesz a keresés sorrendjére.) A MEGOLDÁS függvény a szülőmutatók gyökérig való követésével kinyert cselekvéssorozatot adja vissza."/></div></div></div><div class="section" title="A problémamegoldó hatékonyság mérése"><div class="titlepage"><div><div><h2 class="title"><a id="id545599"/>A problémamegoldó hatékonyság mérése</h2></div></div></div><p>A problémamegoldó algoritmus kimenete vagy <span class="emphasis"><em>kudarc,</em></span> vagy egy megoldás (egyes algoritmusok végtelen hurokba kerülhetnek és soha nem térnek vissza válasszal). Mi az algoritmusok hatékonyságát négyféle módon fogjuk értékelni:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Teljesség</strong></span> (<span class="strong"><strong>completeness</strong></span>): az algoritmus garantáltan megtalál egy megoldást, amennyiben létezik megoldás?</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Optimalitás</strong></span> (<span class="strong"><strong>optimality</strong></span>): a stratégia megtalálja az optimális megoldást, ahogy azt a <a class="xref" href="ch03.md#ID_100_101_oldal">„Jól definiált problémák és megoldások”</a> részben definiáltuk?</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Időigény</strong></span> (<span class="strong"><strong>time complexity</strong></span>): mennyi ideig tart egy megoldás megtalálása?</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Tárigény</strong></span> (<span class="strong"><strong>space complexity</strong></span>): a keresés elvégzéséhez mennyi memóriára van szükség?</p></li></ul></div><p>Az idő- és tárigényről beszélve mindig a probléma nehézségének valamilyen mértékét tartjuk szem előtt. Az elméleti számítástudományban egy tipikus ilyen mérték az állapottér gráf nagysága, mivel a gráf a kereső program bemenetére adott explicit adatstruktúrának tekinthető (erre egy példa Románia térképe). Az MI-ben, ahol a gráfot implicit formában a kezdeti állapottal és az állapotátmenet-függvénnyel reprezentáljuk, és ahol a gráf sokszor végtelen, a komplexitást három tényezővel fejezzük ki. Ezek: <span class="emphasis"><em>b</em></span> – az <span class="strong"><strong>elágazási tényező</strong></span> (<span class="strong"><strong>branching factor</strong></span>), vagyis a követők maximális száma minden csomópontban, <span class="emphasis"><em>d</em></span> – a legsekélyebb célállapot mélysége és <span class="emphasis"><em>m</em></span> – az állapottérben található utak maximális hossza.</p><p>Az időt gyakran a keresés közben generált<sup>[<a id="id545694" href="#ftn.id545694" class="footnote">31</a>]</sup> csomópontok számával, a tárat pedig a memóriában maximálisan tárolt csomópontok számával mérik.</p><p>A keresés hatékonyságának becslésénél gondolhatunk a <span class="strong"><strong>keresési költség</strong></span>re (<span class="strong"><strong>search cost</strong></span>), amely tipikusan az időigénytől függ, de tartalmazhat egy tárigényt jelző komponenst is; vagy használhatjuk a keresés <span class="strong"><strong>összköltség</strong></span>ét (<span class="strong"><strong>total cost</strong></span>), amely a megoldás útköltségét és a keresési költséget kapcsolja össze. Az Aradról Bukarestbe vezető útkeresési probléma esetén a keresési költség a keresés ideje, a megoldási költség pedig a teljes út hossza km-ben. Így amikor a teljes költséget akarjuk kiszámítani, kilométert és milliszekundumot kellene összeadnunk. Ez nem mindig egyszerű, mert nem létezik semmilyen „hivatalos váltószám” a kettő között, ennél a problémánál azonban értelmesnek tűnhet a kilométereket milliszekundumokra átszámítani a gépkocsi átlagsebességét használva (mert az ágensnek az idő a fontos). Ez lehetővé teszi, hogy az ágens megtalálja azt a kompromisszumot, amikor a legrövidebb út keresését célzó minden további számítás improduktívvá válik. A különböző javak közötti kompromisszum általános problémájára a 16. fejezetben még visszatérünk.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id545694" href="#id545694" class="para">31</a>] </sup> Egyes források ehelyett az időt a kifejtett csomópontok számával mérik. A két mérték legfeljebb egy <span class="emphasis"><em>b</em></span> tényezőben tér el. Nekünk úgy tűnik, hogy a csomópontkifejtés végrehajtási ideje nő az adott kifejtésben generált csomópontok számával.</p></div></div></div></body></html>
