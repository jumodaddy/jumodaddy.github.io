<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id661848"/>Összefoglalás</h1></div></div></div><p>Ez a fejezet a valódi világban alkalmazott tervkészítés és cselekvés nehézségeivel foglalkozott. Összefoglaljuk a fő megállapításokat.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A legtöbb cselekvés <span class="strong"><strong>erőforrás</strong></span>okat (<span class="strong"><strong>resource</strong></span>s) használ, például pénzt, benzint vagy nyersanyagokat. Ezen erőforrásokat készletekre vonatkozó mérőszámokként célszerű kezelni, mintsem hogy megpróbáljunk következtetni mondjuk a világ minden egyes pénzérméjéről és papírpénzéről. A cselekvések generálhatnak és elfogyaszthatnak erőforrásokat, és rendszerint olcsó és hatékony, ha a további finomítások végrehajtása előtt a részleges terveket ellenőrizzük, hogy az erőforrásokra vonatozó korlátozásokat kielégítik-e.</p></li><li class="listitem"><p>Az idő az egyik legfontosabb erőforrás. Ez speciális ütemező algoritmusokkal kezelhető, vagy az ütemezést integrálhatjuk a tervkészítésbe. </p></li><li class="listitem"><p>A <span class="strong"><strong>hierarchikus feladat háló</strong></span> (<span class="strong"><strong>hierarchical task network</strong></span>) (<span class="strong"><strong>HFH</strong></span>) tervkészítés lehetővé teszi az ágens számára, hogy dekompozíciós szabályok formájában tanácsokat fogadjon el a feladatkör tervezőjétől. Ez lehetővé teszi, hogy nagyon nagy terveket készítsünk, amelyekre számos valódivilág-beli alkalmazáshoz szükség van.</p></li><li class="listitem"><p>A hagyományos tervkészítő algoritmusok teljes és helyes információt és determinisztikus, teljesen megfigyelhető környezetet feltételeznek. A legtöbb problémakörre nem igaz ez a feltételezés.</p></li><li class="listitem"><p>A hiányos információ kezelhető azáltal, hogy érzékelő cselekvéseket tervezünk, amelyekkel megszerezzük a szükséges információt. A <span class="strong"><strong>feltételes terv</strong></span>ek (<span class="strong"><strong>conditional </strong></span><span class="strong"><strong>plan</strong></span>s) lehetővé teszik az ágens számára, hogy a végrehajtás során érzékelje a környezetét, hogy eldönthesse, mely ágát követi a tervnek. Néhány esetben <span class="strong"><strong>érzékelőmentes</strong></span> (<span class="strong"><strong>sensorless</strong></span>) vagy <span class="strong"><strong>alkalmazkodó tervkészítés</strong></span> (<span class="strong"><strong>conformant planning</strong></span>) használható az érzékelést nem igénylő terv elkészítéséhez. Mind az érzékelőmentes, mind pedig a feltételes tervek előállíthatók a <span class="strong"><strong>hiedelmi állapot</strong></span>ok<span class="strong"><strong> </strong></span>(<span class="strong"><strong>belief state</strong></span>s) terében történő kereséssel.</p></li><li class="listitem"><p>A helytelen információk kielégítetlen előfeltételeket eredményeznek a cselekvések és a tervek számára. A <span class="strong"><strong>végrehajtás-monitorozás</strong></span> (<span class="strong"><strong>execution monitoring</strong></span>) a terv sikeres befejezése érdekében érzékeli az előfeltételek megszegéseit. </p></li><li class="listitem"><p>Az <span class="strong"><strong>újratervező ágens</strong></span> (<span class="strong"><strong>replanning agent</strong></span>) végrehajtás-monitorozást használ és szükség esetén javításokat szúr be.</p></li><li class="listitem"><p>A <span class="strong"><strong>folytonos tervkészítő</strong></span> (<span class="strong"><strong>continuous planning</strong></span>) ágens előrehaladása során új célokat alkot és valós időben reagál.</p></li><li class="listitem"><p><span class="strong"><strong>Multiágens</strong></span> (<span class="strong"><strong>multiagent</strong></span>) tervezésre van szükség, amikor a környezetben más ágensek is találhatók, melyekkel együttműködni vagy versengeni kell, vagy amelyeket koordinálni kell. A <span class="strong"><strong>többtestű</strong></span> (<span class="strong"><strong>multibody</strong></span>) tervkészítés az együttes cselekvésleírások hatékony dekompozícióját felhasználva együttes terveket alkot, de ki kell egészíteni valamilyen koordinációval, amennyiben két együttműködő ágensnek egyet kell érteni abban, hogy melyik együttes tervet hajtsák végre.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id662009"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>A folytonos idővel való tervkészítést elsőként <code class="code">DEVISER</code> vetette fel (Vere, 1983). Az időnek a tervekben való szisztematikus reprezentációjával Dean és társai dolgoztak a <code class="code">FORBIN</code> rendszerben (Dean és társai, 1990). A <code class="code">NONLIN</code>+ (Tate és Whiter, 1984) és a <code class="code">SIPE</code> (Wilkins, 1988; 1990) kezelni tudta a korlátos erőforrások különböző tervlépésekhez való hozzárendelését. Az <code class="code">O-PLAN</code> (Bell és Tate, 1985) HFH-tervkészítő az idő- és erőforrás-korlátozások egységes és általános reprezentációját tartalmazta. A szövegben említett Hitachi-alkalmazás kiegészítéseképpen, az <code class="code">O-PLAN</code> módszert a Price Waterhouse-ban a szoftverbeszerzési tervkészítéshez alkalmazták, míg a Jaguar Autógyárban a hátsó tengely összeszerelési tervének készítésénél. Számos hibrid tervkészítő és ütemező rendszert alkalmaztak: az <code class="code">ISIS</code> (<code class="code">FOX</code> és társai, 1982; Fox, 1990) egy ütemezési feladatban alkalmazták a Westinghouse-nál, a <code class="code">GARI</code> (Descotte és Latombe, 1985) mechanikus alkatrészek gépesítését és készítését tervezte, a <code class="code">FORBIN</code>-t gyár vezérlésre használták, végezetül a <code class="code">NONLIN</code>+ hajózási logisztikai tervkészítéshez alkalmazták.</p><p>Az 1980-as években megindult elméleti munka tetőzése után, napjainkban ismét a temporális tervkészítés kerül előtérbe, amikor az új algoritmusok és a megnövekedett feldolgozási teljesítmény lehetővé tette a gyakorlati felhasználást. A két tervkészítő a <code class="code">SAPA</code> (Do és Kambhampati, 2001) és a T4 (Haslum és Geffner, 2001) előrefelé történő állapottér keresést alkalmaztak, amit az időtartammal és erőforrásokkal rendelkező cselekvések kezeléséhez egy kifinomult heurisztikával egészítettek ki. Egy másik lehetőség a nagyon költséges cselekvésleíró nyelvek használata, melyeket kézzel írt és alkalmazási terület specifikus heurisztikákkal irányíthatunk, amint az az ASPEN (Fukunaga és társai, 1997), a HSTS (Jonsson és társai, 2000) és az IxTeT (Ghallab és Laruelle, 1994) esetén is történik.</p><p>Az ütemezés az űrkutatásban nagyon hosszú múltra tekint vissza. A T-<code class="code">SCHED</code> (Drabble, 1990) rendszert az <code class="code">UOSAT–II</code> műhold küldetésvezérlő parancssorozatainak ütemezésére használták. Az <code class="code">O-PLAN</code>-en alapuló <code class="code">OPTIMUM</code>-AIV (Aarup és társai, 1994) és a <code class="code">PLAN</code>-ERS1 (Fuchs és társai, 1990) az űrrepülőgép-összeszerelésben a megfigyelési tervkészítésben használták fel az Európai Űrkutatási Ügynökségnél (ESA). </p><p>A <code class="code">SPIKE</code> rendszert (Johnston és Adorf, 1992) a NASA-nál a Hubble-űrteleszkóp megfigyelés-tervezéséhez használták, míg az űrsikló földi feldolgozásütemező rendszer (Deale és társai, 1994) emberi erőforrás ütemezést végez egészen 16 000 munkás-műszak értékig. A Remote Ágens (Muscettola és társai, 1998) lett az első önálló tervkészítő és ütemező, mely űrsiklót vezérelt, mialatt a Deep Space One űrszonda fedélzetén repült 1999-ben. Az emberi erőforrás ütemezés irodalmát Vaessens és társai (Vaessens és társai, 1996) foglalták össze, az elméleti eredményeket Martin és Shmoys (Martin és Shmoys, 1996) jelentette meg.</p><p>A <code class="code">STRIPS</code> programban található a <span class="strong"><strong>macrops</strong></span> – elemi lépések sorozatából álló „makróoperátorok” (<span class="strong"><strong>macro operators</strong></span>) – tanulásra szolgáló eszköztár, az első hierarchikus mechanizmusnak tekinthető (Fikes és társai, 1972). A hierarchiát szintén alkalmazták a <code class="code">LAWALY</code> rendszerben (Siklossy és Dreussi, 1973). Az <code class="code">ABSTRIPS</code> rendszer (Sacerdoti, 1974) az <span class="strong"><strong>absztrakciós hierarchia</strong></span> (<span class="strong"><strong>abstraction hierarchy</strong></span>) ötletét vezette be, ahol a magasabb szintű tervezés megengedte a cselekvések alacsonyabb szintű előfeltételeinek figyelmen kívül hagyását, hogy egy működő terv általános struktúráját származtathassa. Austin Tate PhD-tézise (Tate, 1975b) és Earl Sacerdoti (Sacerdoti, 1977) munkája a HTM tervkészítés modern formájának alapötleteit vezette be. Számos gyakorlati tervkészítő, beleértve az O-<code class="code">PLAN</code> és a <code class="code">SIPE</code> tervkészítőket, HFH-tervkészítő. Yang (Yang, 1990) a HFH-tervkészítést hatékonnyá tevő cselekvések jellemzőit tárgyalja. Erol, Hendler és Nau (Erol és társai, 1994, 1996) egy teljes hierarchikus dekompozíciót alkalmazó tervkészítőt mutat be, valamint számos komplexitásbeli eredményt a tiszta HFH-tervkészítőkhöz. Más szerzők (Ambros-Ingerson és Steel, 1988); Young és társai (Young és társai, 1994); Barrett és Weld (Barett és Weld, 1994); Kambhampati és társai (Kambhampati és társai, 1998) az ebben a fejezetben bemutatott hibrid megközelítést javasolták, melyben a dekompozíciók mindössze a részben rendezett tervkészítéshez használható finomítások egy másik formáját jelentik. </p><p>A <code class="code">STRIPS</code>-ben szereplő makróoperátorokkal kezdődően a hierarchikus tervkészítés egyik célja a korábbi, általánosított tervek formájában rendelkezésre álló tervkészítési tapasztalat újrahasznosítása. A <span class="strong"><strong>magyarázatalapú tanulás</strong></span> (<span class="strong"><strong>explanation-based learning</strong></span>) technikáját, amit részleteiben a 19.<span class="emphasis"><em> </em></span>fejezet mutat be, számos rendszerben, mint a <code class="code">SOAR</code> Laird és társai (Laird és társai, 1986) és <code class="code">PRODIGY</code> (Carbonell és társai, 1989) alkalmazták a korábban elkészített tervek általánosítására. Egy másik megközelítés, hogy a korábban kiszámított terveket eredeti formájukban tároljuk el, majd az új hasonló feladatokban az eredeti feladat analógiájára újrahasznosítjuk őket. Ezt a megközelítést <span class="strong"><strong>esetalapú tervk</strong></span><span class="strong"><strong>észítés</strong></span>nek (<span class="strong"><strong>case-based planning</strong></span>) (Carbonell, 1983; Alterman, 1988; Hammond, 1989) nevezzük. Kambhampati (Kambhampati, 1994) érvelése szerint az esetalapú tervkészítést a finomító tervkészítéshez hasonlóan kellene vizsgálni. Emellett lefekteti az esetalapú részben rendezett tervkészítés formális alapjait. </p><p>A valós környezetek kiszámíthatatlanságát és részleges megfigyelhetőségét elsőként tervkészítési technikákat használó robotikai projektekben – beleértve a Shakey (Fikes és társai, 1972) és a <code class="code">FREDDY</code> (Michie, 1974) projekteket – ismerték fel. A problémakör több figyelmet kapott McDermott nagy hatású <span class="emphasis"><em>Tervezés és cselekvés (Planning and Acting) </em></span>c. cikkének megjelenését követően (McDermott, 1978a).</p><p>A korai, feltételeket és ciklusokat nem tartalmazó tervkészítők nem tükrözték pontosan a feltételes tervkészítés megközelítésmódját, de ennek ellenére néha kényszerítően reagáltak a környezet bizonytalanságára. Sacerdoti <code class="code">NOAH</code> rendszere kényszerítést használt a „kulcsok és dobozok” (keys and boxes) probléma megoldásában, egy olyan tervkészítési kihívásban, ahol a tervkészítő keveset tud a kiinduló állapotról. Mason (Mason, 1993) kijelentette, hogy a robotikai tervkészítés nélkülözni tudja és nélkülöznie is kell az érzékelést, és bemutatott egy érzékelőmentes tervet, ami a kiindulási pozíciótól <span class="emphasis"><em>függetlenül</em></span> képes egy eszközt csuklómozdulatok sorozatával az asztal egy megadott pozíciójába mozgatni. Ezt az ötletet a robotika kontextusában tárgyaljuk (lásd 25.17.<span class="emphasis"><em> </em></span>ábra).</p><p>Goldman és Boddy (Goldman és Boddy, 1996) bevezették az <span class="strong"><strong>alkalmazkodó tervkészítés</strong></span> (<span class="strong"><strong>conformant planning</strong></span>) fogalmát, az érzékelőmentes tervkészítőkre, melyek a bizonytalanságot a környezet ismert állapotokba való kényszerítésével kezelik, megjegyezve, hogy az érzékelőmentes tervek gyakran hatékonyak még akkor is, ha az ágens rendelkezik érzékelőkkel. Az első megfelelően hatékony alkalmazkodó tervkészítő Smith és Weld (Smith és Weld, 1998) Conformant Graphplan (CGP) rendszere volt. Ferraris és Giunchiglia (Ferraris és Giunchiglia, 2000), valamint Rintanen (Rintanen, 1999) függetlenül fejlesztettek ki <code class="code">SATPLAN</code>-alapú alkalmazkodó tervkészítőket. Bonet és Geffner (Bonet és Geffner, 2000) a hiedelmi állapotok terén végzett heurisztikus keresésalapú alkalmazkodó tervkészítőt mutat be, olyan ötletekre alapozva, melyeket először 1960-ban fejlesztettek ki a részlegesen megfigyelhető Markov döntési folyamatokhoz (Partially Observable Markov Decision Process – POMDP) (lásd 17.<span class="emphasis"><em> </em></span>fejezet). Jelenleg a leggyorsabb hiedelmi állapot alkalmazkodó tervkészítők, mint például a HSCP (Bertoli és társai, 2001a) bináris döntési diagramokat (BDD) (Bryant, 1992) használnak a hiedelmi állapotok leírására, valamint öt nagyságrenddel gyorsabbak, mint a CGP. </p><p>A <code class="code">WARPLAN-C</code> (Warren, 1976), ami a <code class="code">WARPLAN</code> egy változata, volt az első feltételes cselekvéseket használó tervkészítők egyike. Olawski és Gini (Olawski és Gini, 1990) a feltételes tervkészítés fő problémáit vetette fel. </p><p>A fejezetben bemutatott feltételes tervkészítési megközelítés a Jimenez és Torras (Jimenez és Torras, 2000), valamint Hansen és Zilberstein (Hansen és Zilberstein, 2001) által kifejlesztett ciklikus <code class="code">ÉS-VAGY</code> gráfok hatékony keresési algoritmusán alapul. Bertoli és társai (Bertoli és társai, 2001b) egy BDD-alapú megközelítést mutatnak be, ami ciklikus feltételes terveket készít. A C-<code class="code">BURIDAN</code> rendszer (Draper és társai, 1994) egy folytonos tervkészítést végez valószínűségi kimenetelű cselekvésekre, melynek problémája a POMDP vezérlése során is felmerült (lásd 17.<span class="emphasis"><em> </em></span>fejezet). Szoros kapcsolat van a feltételes tervkészítés és az automatizált programkészítés között. A 9.<span class="emphasis"><em> </em></span>fejezet számos ilyen hivatkozást tartalmaz. A két területet egymástól függetlenül tárták fel, aminek oka az az óriási költségkülönbség, ami egy gépi utasítás végrehajtása, valamint robot- vagy manipulátorcselekvések végrehajtása között fennáll. Linden (Linden, 1991) a két terület közötti tudásmegosztást szorgalmazza. </p><p>Történelmi távlatból már látható, hogy hogyan vezetett a két fő klasszikus tervkészítő algoritmus kibővített verziókhoz a bizonytalan környezetek kezelése céljából. A keresésalapú technikák a hiedelmi állapottér keresésre vezettek (Bonet és Geffner, 2000). A <code class="code">SATPLAN</code> algoritmus a sztochasztikus <code class="code">SATPLAN</code> (Majercik és Littman, 1999) algoritmusra, valamint a kvantorokat alkalmazó logikai tervezésre vezetett (Rintanen, 1999). A részben rendezett tervkészítésből az UWL (Etzioni és társai, 1992), a CNLP (Peot és Smith, 1992) és a <code class="code">CASSANDRA</code> (Pryor és Collins, 1996) származik. A <code class="code">GRAPHPLAN</code>, az érzékeléses <code class="code">GRAPHPLAN</code> (sensory <code class="code">GRAPHPLAN</code>-SGP) (Weld és társai, 1998) algoritmusra vezetett, de a teljesen valószínűségi <code class="code">GRAPHPLAN</code> algoritmus még kifejlesztésre vár. </p><p>A végrehajtás monitorozás első fő megjelenése a <code class="code">PLANEX</code> (Fikes és társai, 1972), ami egy <code class="code">STRIPS</code> tervkészítővel működött a Shakey robot irányításán. A <code class="code">PLANEX</code> háromszög táblákat használt – ami egy szükségszerűen hatékony tárolási mechanizmus a terv előfeltételeinek tárolására a terv minden pontján –, hogy teljes újratervezés nélkül helyreállhasson egy részleges végrehajtási hiba után. A végrehajtás Shakey-modelljét a 25.<span class="emphasis"><em> </em></span>fejezetben tárgyaljuk tovább. A NASL tervkészítő (McDermott, 1978a) a tervkészítési problémát egyszerűen, mint egy komplex cselekvés végrehajtásának specifikációját tekintette, így a tervezés és végrehajtás teljesen egységessé vált. Az összetett cselekvések levezetésére tételbizonyítást használ. </p><p>A <code class="code">SIPE</code> (System for Interactive Planning and Execution Monitoring) (Wilkins, 1988, 1990) volt az első tervkészítő, ami az újratervezés problémáját szisztematikusan kezelte. Különböző problémakörök demonstrációs feladataiban is felhasználták, például az űrsiklóhordozó fedélzeti terv készítésére vagy emberi erőforrás ütemezésére egy ausztrál sörgyárban. Egy másik vizsgálat a <code class="code">SIPE</code> rendszert többemeletes épületek tervezésében alkalmazta, ami az egyik legbonyolultabb problémakör, amit tervkészítő valaha kezelt. </p><p>Az <code class="code">IPEM</code> (Intergrated Planning, Execution, and Monitoring) (Ambros-Ingerson és Steel, 1988) volt az első rendszer, ami integrálta a részben rendezett tervkészítést és a végrehajtást, hogy folytonos tervkészítő ágensre jusson. Az általunk tárgyalt folytonos, részben rendezett tervkészítő ágens (<code class="code">CONTINUOUS-POP-AGENT</code>) az <code class="code">IPEM</code> a <code class="code">PUCCINI</code> (Golden, 1998) és a <code class="code">CYPRESS</code> (Wilkins és társai, 1995) tervkészítők ötleteit kombinálja. </p><p>Az 1980-as évek közepén néhányan úgy gondolták, hogy a részben rendezett tervkészítés és a kapcsolódó technikák soha nem futhatnak eléggé gyorsan, hogy egy valódivilág-beli ágens számára használható viselkedést biztosítsanak (Agre és Chapman, 1987). Ezek helyett a <span class="strong"><strong>reaktív tervkészítő</strong></span> (<span class="strong"><strong>reactive planning</strong></span>) rendszereket vezették be. Ezek alapesetben reflexszerű ágensek, esetenként belső állapottal, melyek számos különböző feltétel-cselekvés szabályábrázolás segítségével implementálhatók. Brooks (Brooks, 1986) bennfoglalási architektúrája (lásd. 7. és 25.<span class="emphasis"><em> </em></span>fejezet) rétegzett véges állapotú állapotgépeket használt, lábbal és kerékkel ellátott robotok mozgásának és akadályok elkerülésének a szabályozására. Pengi (Agre és Chapman, 1987) egy (teljesen megfigyelhető) videojátékot tudott játszani, az aktuális célok „látott” reprezentációja, az ágens belső állapota, valamint kétértékű áramkörök kombinálásával. </p><p>Az „univerzális tervek” (Schoppers, 1987) a reaktív tervkészítés keresőtábla módszereként került kifejlesztésre, de mint kiderült, ez a Markov döntési folyamatokban használt <span class="strong"><strong>eljárásmód</strong></span> (<span class="strong"><strong>policy</strong></span>) ötletének újrafelfedezése volt. Egy univerzális terv (vagy egy eljárásmód) bármely állapotban az adott állapotban végrehajtandó cselekvésre mutató leképezést tartalmazza. Ginsberg (Ginsberg, 1989) lelkes támadást indított az univerzális tervek ellen, ami kezelhetetlenségi eredményeket is tartalmazott a reaktív tervkészítési probléma néhány alakjára. Erre Schoppers 1989-ben egy hasonlóan lelkes választ adott (Schoppers, 1989).</p><p>Mint a legtöbb esetben a hibrid megközelítés feloldja az ellentmonást. Jól tervezett hierarchiák használatával a HFH tervkészítők, mint a PRS (Georgeff és Lansky, 1987) és a RAP (Firby, 1996), valamint a folytonos tervkészítő ágensek használható válaszidőket és összetett hosszú távú terveket érhetnek el számos problémakörben. </p><p>A multiágens tervkészítés napjainkban vált népszerűvé, bár hosszú történelme van. Konolige (Konolige, 1982) a multiágens tervkészítés elsőrendű logikai leírását adta meg, míg Pednault (Pednault, 1986) egy <code class="code">STRIPS</code>-alakú leírást készített. A kölcsönös szándék ötlete, ami elengedhetetlen, ha az ágensek együttes tervet hajtanak végre, a kommunikációs viselkedés kutatásából ered (Cohen és Levesque, 1990; Cohen és társai, 1990). Az általunk bemutatott többtestű részben rendezett tervkészítés Boutilier és Brafman (Boutilier és Brafman, 2001) munkáján alapul. </p><p>Az itt szereplő, a multiágens tervkészítésben az együttműködést célzó munka bemutatása éppcsak a jéghegy csúcsa. Durfee és Lesser (Durfee és Lesser, 1989) azt tárgyalja, hogy a feladatok hogyan oszthatók meg az ágensek között egyezkedés útján. Kraus és társai (Kraus és társai, 1991) egy Diplomacyt – egy egyezkedést, együttműködést, felbomlást és ügyeskedést igénylő táblajátékot – játszó rendszert mutatnak be. Stone (Stone, 2000) bemutatja, hogy az ágensek hogyan tudnak csapattagként együttműködni a robotfoci versengő, dinamikus, részben megfigyelhető környezetében. A (Weiss, 1999) a multiágens rendszerek egy könyvhosszúságú áttekintése. Az <a class="xref" href="ch12s07.md#ID_533_oldal">„Koordináló mechanizmusok”</a> rész moid modellje Reynoldsnak köszönhető (Reynolds, 1987), aki ennek a <span class="emphasis"><em>Batman visszatér </em></span>(<span class="emphasis"><em>Batman returns</em></span>) c. film denevérseregeire és pingvincsapatára való alkalmazásával Oscar-díjat is nyert.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id662359"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>12.1.</strong></span></p><p>Vizsgáljuk meg figyelmesen a 12.1.<span class="emphasis"><em> </em></span>alfejezetben az idő és az erőforrások reprezentációját.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Miért jobb, ha egy cselekvés következménye az <span class="emphasis"><em>Időtartam</em></span>(<span class="emphasis"><em>d</em></span>), mint ha a cselekvésnek egy <code class="code">IDŐTARTAM</code>:<span class="emphasis"><em>d</em></span> alakú külön mezője lenne? (<span class="emphasis"><em>Segítség: </em></span>vegyük figyelembe a feltételes következményeket és a diszjunktív következményeket.)</p></li><li class="listitem"><p>Az <code class="code">ERŐFORRÁS</code>: <span class="emphasis"><em>m </em></span>miért egy külön mező a cselekvésben, nem pedig egy következmény?</p></li></ol></div><p><span class="strong"><strong>12.2.</strong></span></p><p>Egy <span class="strong"><strong>fogyóeszköz</strong></span> (<span class="strong"><strong>consumable resource</strong></span>) egy olyan erőforrás, ami (részlegesen) felhasználásra kerül a cselekvésben. Például a motor beszerelése az autóba csavarokat igényel. Miután a csavarokat felhasználtuk, már nem használhatók további rögzítésekhez. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Magyarázza meg, hogyan módosítsuk a 12.3.<span class="emphasis"><em> </em></span>ábra reprezentációját úgy, hogy 100 kiinduló csavarunk legyen az <span class="emphasis"><em>E</em></span><sub>1</sub> motor 40 csavart, az <span class="emphasis"><em>E</em></span><sub>2</sub> pedig 50 csavart igényel. A + és – szimbólumok felhasználhatók az erőforrásokat leíró következményliterálokban.</p></li><li class="listitem"><p>Mutassa meg, hogy a részben rendezett tervkészítésben alkalmazott okozati kapcsolatok és cselekvések közötti <span class="strong"><strong>ütközés</strong></span> (<span class="strong"><strong>conflict</strong></span>) definícióját hogyan kell módosítani, hogy a fogyóeszközöket kezelje. </p></li><li class="listitem"><p>Néhány cselekvés, például a gyár ellátása csavarokkal vagy egy autó feltankolása, <span class="emphasis"><em>növelheti</em></span> az erőforrások készletét. Egy erőforrás monoton nem növekvő, ha egyetlen cselekvés sem növeli. Magyarázza meg, hogyan használható ez a tulajdonság a keresési tér megmetszéséhez.</p></li></ol></div><p><span class="strong"><strong>12.3.</strong></span></p><p>Adjon dekompozíciót a 12.7.<span class="emphasis"><em> </em></span>ábra <span class="emphasis"><em>KivitelezőtVeszFel </em></span>és <span class="emphasis"><em>EngedélytSzerez</em></span> lépéseire, és mutassa meg, hogy a dekomponált résztervek hogyan állnak össze egy teljes tervvé.</p><p><span class="strong"><strong>12.4.</strong></span></p><p>Adjon példát a házépítési problémakörben két olyan absztrakt résztervre, ami nem egyesíthető egy teljes tervvé lépések megosztása nélkül. (<span class="emphasis"><em>Segítség:</em></span> azok a pontok, ahol egy ház fizikai részei csatlakoznak, egyúttal a résztervek várható csatlakozási kölcsönhatási pontjai is.)</p><p><span class="strong"><strong>12.5.</strong></span></p><p>Sokan mondják, hogy a HFH-tervkészítés előnye, hogy  „tegyünk egy körutat Los Angelesből New Yorkba, és vissza” típusú problémákat is meg tud oldani, amelyeket nehéz nem HFH-jelölésekkel kifejezni, hiszen a kiinduló és a célállapotok azonosak lennének (<span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>LA</em></span>)). Tud mondani megfelelő reprezentációt, illetve meg tudja-e oldani ezt a problémát HFH-k nélkül?</p><p><span class="strong"><strong>12.6.</strong></span></p><p>Mutassa meg, hogy az eredeti <code class="code">STRIPS</code> cselekvésleírás hogyan írható át HFH-dekompozícióvá. Használja az <span class="emphasis"><em>Eléri</em></span>(<span class="emphasis"><em>p</em></span>) cselekvést a <span class="emphasis"><em>p</em></span> feltétel eléréséhez szükséges cselekvés jelölésére.</p><p><span class="strong"><strong>12.7.</strong></span></p><p>A hagyományos programozási nyelvekben számos művelet modellezhető olyan cselekvéssel, amely megváltoztatja a világ állapotát. Például egy értékadási operátor egy memóriaterület tartalmát másolja, míg egy nyomtatás operátor megváltoztatja a kimenet állapotát. Egy, ezekből a műveletekből álló programot tervnek tekinthetünk, melynek célját a program specifikációja definiálja. A felkészítő algoritmusok ezért felhasználhatók egy adott specifikációjú program elkészítéséhez. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Írjon egy operátorsémát az értékadási operátorhoz (egy változó értékének átadása egy másik változónak). Vegye figyelembe, hogy az eredeti érték felülíródik!</p></li><li class="listitem"><p>Mutassa meg, hogy az objektumok létrehozása hogyan használható a felkészítő által két változó értékének egy átmeneti változó felhasználásával történő felcserélésére.</p></li></ol></div><p><span class="strong"><strong>12.8.</strong></span></p><p>Tekintsük a következő indoklást: egy bizonytalan kiinduló állapotot megengedő keretrendszerbe a <span class="strong"><strong>diszjunktív következmény</strong></span>ek (<span class="strong"><strong>disconjuctive effect</strong></span>s) csak jelölési könnyebbséget jelentenek, és nem a kifejezőképesség növelésére szolgálnak. Egy <span class="emphasis"><em>P</em></span> ∨ <span class="emphasis"><em>Q</em></span> diszjunktív következményt tartalmazó <span class="emphasis"><em>a</em></span> cselekvéssémát mindig helyettesíthetünk a <span class="strong"><strong>when</strong></span> <span class="emphasis"><em>R</em></span>:<span class="emphasis"><em> P</em></span> ∧ <span class="strong"><strong>when</strong></span> ¬<span class="emphasis"><em>R</em></span>:<span class="emphasis"><em> Q</em></span> feltételes következményekkel, ami cserében két hagyományos cselekvésre redukálható. Az <span class="emphasis"><em>R</em></span> kifejezés egy a kiinduló állapotban ismeretlen véletlen állítást takar, melyhez nem tartozik érzékelő cselekvés. Helyes ez az indoklás? Vegyünk külön két esetet, egyet, melyben csak egy <span class="emphasis"><em>a</em></span> cselekvésséma szerepel a tervben, és egy másikat, melyben több mint egy példány van.</p><p><span class="strong"><strong>12.9.</strong></span></p><p>Miért nem tudja a feltételes tervkészítés kezelni a nem korlátos nemdeterminisztikusságot?</p><p><span class="strong"><strong>12.10.</strong></span></p><p>A kockavilágban két <code class="code">STRIPS</code> cselekvést kellett bevezetnünk, hogy az <span class="emphasis"><em>Üres</em></span> predikátumot helyesen megtartsuk, a <span class="emphasis"><em>Mozgat</em></span> és az <span class="emphasis"><em>AsztalraTesz</em></span> cselekvéseket. Mutassuk meg, hogy a feltételes következmények hogyan használhatók mindkét eset egyetlen cselekvéssel történő leírására.</p><p><span class="strong"><strong>12.11.</strong></span></p><p>A feltételes következményeket a porszívóvilág <span class="emphasis"><em>Szív</em></span> cselekvésére mutattuk be, ahol az, hogy melyik kocka lesz tiszta, attól függ, hogy mely kockán áll a robot. Tud mondani olyan ítéletlogikai változókat, melyek a porszívóvilág állapotait definiálják úgy, hogy a <span class="emphasis"><em>Szív</em></span> cselekvésnek <span class="emphasis"><em>feltétel nélküli</em></span> leírása legyen? Adja meg a <span class="emphasis"><em>Szív</em></span>, a <span class="emphasis"><em>Balra</em></span> és a <span class="emphasis"><em>Jobbra</em></span> cselekvések leírását az állításaik felhasználásával, és mutassa meg, hogy ezek kielégítők a világ összes lehetséges állapotának leírásához.</p><p><span class="strong"><strong>12.12.</strong></span></p><p>Adja meg a <span class="emphasis"><em>Szív</em></span> cselekvés teljes leírását a dupla-Murphy porszívó problémára, ami néha piszkot hagy maga után, amikor egy tiszta célterületre mozog, és néha piszkot rak le, ha a <span class="emphasis"><em>Szív</em></span> cselekvést egy tiszta négyzeten hajtjuk végre.</p><p><span class="strong"><strong>12.13.</strong></span></p><p>Keressen egy megfelelően piszkos szőnyeget, amely akadálymentes és porszívózza ki. Rajzolja le a porszívó által választott útvonalat, amilyen pontosan csak tudja. Indokolja a választ hivatkozva a fejezetben tárgyalt tervkészítési módszerekre. </p><p><span class="strong"><strong>12.14.</strong></span></p><p>A következő idézetek samponos flakonok hátuljáról származnak. Azonosítsa mindegyiket, mint egy feltétel nélküli, feltételes vagy végrehajtás monitorozó tervet. (a) „Mosás. Öblítés. Ismételje.” (b) „Tegye a sampont a fejére, és hagyja ott néhány percig. Öblítsen és ismételje, ha szükséges.” (c) „Amennyiben az irritáció nem szűnik, forduljon orvoshoz.”</p><p><span class="strong"><strong>12.15.</strong></span></p><p>A 12.10.<span class="emphasis"><em> </em></span>ábrán szereplő <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code> algoritmus csak a gyökér és az aktuális állapot közötti útvonalat ellenőrzi le ismétlődő állapotokra. Mindehhez tegyük fel, hogy az algoritmus eltárolt <span class="emphasis"><em>minden</em></span> meglátogatott állapotot, és összeveti ezzel a listával (lásd például 3.19.<span class="emphasis"><em> </em></span>ábra <code class="code">GRÁF-KERESÉS</code>). Határozza meg, hogy milyen információt kellene tárolni, és azt, hogy az algoritmus hogyan használja ezt fel, amikor ismétlődő állapotot talál. (<span class="emphasis"><em>Segítség:</em></span> szüksége lesz arra, hogy különbséget tegyen azon állapotok, melyekhez egy sikeres részterv készült korábban, és azon állapotok között, melyekre nem talált résztervet.) Magyarázza meg, hogyan használhatunk <span class="strong"><strong>címké</strong></span>ket (<span class="strong"><strong>label</strong></span>s), hogy elkerüljük a résztervek duplikálását.</p><p><span class="strong"><strong>12.16.</strong></span></p><div class="informalexample"><p/><p>Mutassa meg precízen, hogy hogyan módosítjuk az <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code> algoritmust, hogy ciklikus tervet generáljon, amennyiben ciklusmentes terv nem létezik. Ehhez három problémával kell megküzdenie: a terv lépéseinek címkézése, hogy egy ciklikus terv vissza tudjon mutatni a terv egy korábbi pontjára, a <code class="code">VAGY-KERESÉS</code> módosításával, hogy egy ciklikus terv megtalálása után ciklusmentes tervet keressen, és a terv leírásának olyan bővítésével, mely jelzi, hogy a terv ciklikus. Mutassa meg, hogyan működik az algoritmus (a) a tripla-Murphy porszívóvilágban, (b) a váltakozó dupla-Murphy porszívóvilágban. Használhat számítógépes implementációt az eredmények ellenőrzéséhez. A (b) eset terve felírható egy hagyományos ciklusszintaxis használatával?</p><p/></div><p><span class="strong"><strong>12.17.</strong></span></p><p>Specifikálja teljesen a hiedelem állapot módosító folyamatot részben megfigyelhető környezetekre. Azaz a módszert, ami az új hiedelmi állapot leírást számítja (mint ismeret állítások listáját) az aktuális hiedelmi állapot leírásból és a feltételes következményeket tartalmazó cselekvésleírásokból.</p><p><span class="strong"><strong>12.18.</strong></span></p><p>Írjon a (12.2.)<span class="emphasis"><em> </em></span>egyenlettel analóg cselekvésleírásokat a <span class="emphasis"><em>Jobbra</em></span> és a <span class="emphasis"><em>Szív</em></span> cselekvésekre. Adja meg a leírását a<span class="emphasis"><em> PozícióEllenőrzés</em></span> cselekvésnek, a (12.3.)<span class="emphasis"><em> </em></span>egyenletnek megfelelően. Ismételje ezt meg a 12.11.<span class="emphasis"><em> </em></span>feladat alternatív állítás halmazának felhasználásával.</p><p><span class="strong"><strong>12.19.</strong></span></p><p>Tekintse meg az <a class="xref" href="ch12s06.md#ID_525_oldal">„Folytonos tervkészítés”</a> rész listáját, ami felsorolja, hogy mit nem tud az újratervező ágens végrehajtani. Vázoljon fel egy algoritmust néhány probléma kezelésére. </p><p><span class="strong"><strong>12.20.</strong></span></p><p>Vegyük a következő feladatot: egy páciens olyan tünetekkel érkezik az orvoshoz, amelyet kiszáradás vagy <span class="emphasis"><em>D</em></span> fertőzés okozhat (de nem mindkettő). Két lehetséges cselekvés van: <span class="emphasis"><em>Iszik</em></span>, ami feltétel nélkül kúrálja a kiszáradást, és <span class="emphasis"><em>Gyógyszert szed</em></span>, amely a <span class="emphasis"><em>D</em></span> fertőzést kúrálja ki, de káros mellékhatása van, ha a páciens kiszáradt. Írja fel a probléma leírást PDDL-ben, és az összes releváns világ számbavétele mellett ábrázolja az érzékelőmentes tervet, ami megoldja a problémát. </p><p><span class="strong"><strong>12.21.</strong></span></p><p>Az előző feladat gyógyszerszedési problémájához adja hozzá a <span class="emphasis"><em>Vizsgál</em></span> cselekvést, melynek feltételes következménye a <span class="emphasis"><em>TenyészetNövekedés</em></span>, amennyiben a <span class="emphasis"><em>Fertőzés</em></span> igaz, és minden esetben van egy érzékelési következménye: <span class="emphasis"><em>Ismert</em></span>(<span class="emphasis"><em>TenyészetNövekedés</em></span>). Ábrázolja a feltételes tervet, ami megoldja a problémát és minimalizálja a <span class="emphasis"><em>GyógyszertSzed</em></span> cselekvés felhasználását.</p></div></div></body></html>
