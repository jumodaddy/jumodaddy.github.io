<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="appendix" title="A. függelék - Matematikai alapok"><div class="titlepage"><div><div><h1 class="title"><a id="id803256"/>A. függelék - Matematikai alapok</h1></div></div></div><div class="section" title="A1. Bonyolultságanalízis és az O() jelölés"><div class="titlepage"><div><div><h1 class="title"><a id="id803260"/>A1. Bonyolultságanalízis és az O() jelölés</h1></div></div></div><p>A számítógépes szakembereknek gyakran szembe kell nézniük azzal a feladattal, hogy eldöntsék, két algoritmus közül melyik fut gyorsabban, vagy melyik igényel kevesebb memóriát. Ezt a feladatot kétféle módon lehet megközelíteni. Az első a <span class="strong"><strong>teljesítménymérés</strong></span> (<span class="strong"><strong>benchmarking</strong></span>) – ahol az algoritmusokat számítógépen futtatjuk, és megmérjük, milyen a sebességük másodpercekben, valamint a memóriafogyasztásuk bájtokban. Hiszen végül is ez az, ami igazából számít. A teljesítménymérés azonban nem biztos, hogy kielégítő mérték, mivel igen specifikus: egy konkrét program teljesítményét méri, amely program egy konkrét programozási nyelven íródott, konkrét gépen fut, konkrét fordító és bemeneti adatok mellett. A teljesítménymérő program által szolgáltatott egyszerű adatokból nehéz lenne arra következtetni, hogy az algoritmus milyen jól vizsgázik más fordító, más számítógép vagy más adathalmaz esetén.</p><div class="section" title="Aszimptotikus analízis"><div class="titlepage"><div><div><h2 class="title"><a id="id803275"/>Aszimptotikus analízis</h2></div></div></div><p>A második megközelítés az <span class="strong"><strong>algoritmusok</strong></span> matematikai <span class="strong"><strong>elemzésé</strong></span>n (<span class="strong"><strong>analysis of algorithms</strong></span>) alapul, konkrét implementációtól és bemenetektől függetlenül. Ezt a megközelítést egy példa kapcsán, egy számsorozatot összeadó program esetén fogjuk ismertetni:</p><p><span class="inlinemediaobject"><img src="kepek/1105-1.png" alt="Aszimptotikus analízis"/></span></p><p>Az elemzés első lépése a bemenetektől való eltekintés, olyan paraméter vagy paraméterek megkeresése, amely vagy amelyek jellemzők a bemenet méretére. Jelen példában a bemenetet a szekvencia hosszával jellemezhetjük, aminek a jele legyen <span class="emphasis"><em>n</em></span>. Második lépés az implementációktól való eltekintés, azaz egy olyan mérték megkeresése, amely tükrözi az algoritmus futásiidő-igényét, de nem kötődik egy konkrét fordítóhoz vagy számítógéphez. Az <code class="code">ÖSSZEGZÉS</code> program esetén ez lehetne például a végrehajtott kód sorainak a száma. A mérték részletesebb is lehetne, külön specifikálva az algoritmus által végrehajtott összeadások, értékadások, tömbhivatkozások és elágazások számát. Mindkét esetben megkapjuk az algoritmus által végzett lépések teljes számának a jellemzését a bemenet nagyságának függvényében, amit <span class="emphasis"><em>T</em></span>(<span class="emphasis"><em>n</em></span>)-nek fogunk nevezni. Ha megszámoljuk a kód sorait, a példánk esetében az eredmény <span class="emphasis"><em>T</em></span>(<span class="emphasis"><em>n</em></span>) = 2<span class="emphasis"><em>n + </em></span>2.</p><p>Ha minden program olyan egyszerű lenne, mint az <code class="code">ÖSSZEGZÉS</code>, az algoritmusok elemzése triviális lenne. Két probléma miatt a helyzet azért bonyolultabb. Először is, ritka eset olyan paramétert találni, mint az <span class="emphasis"><em>n</em></span>, amely teljes egészében jellemzi az algoritmus által végrehajtott lépések számát. A legjobb, amivel ehelyett rendelkezhetünk, a legrosszabb esetet jelentő <span class="emphasis"><em>T</em></span><sub>legrosszabb</sub>(<span class="emphasis"><em>n</em></span>) vagy az átlagos <span class="emphasis"><em>T</em></span><sub>átlag</sub>(<span class="emphasis"><em>n</em></span>) számítása. Az átlag kiszámításához az elemzőnek fel kell tételeznie a bemenetek valamilyen eloszlását.</p><p>A másik probléma az, hogy az algoritmusok ellenállnak az egzakt elemzésnek. Ilyen esetben közelítésekre szükséges támaszkodnunk. Azt mondhatjuk, hogy az <code class="code">ÖSSZEGZÉS</code> algoritmus <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) – avagy nagy ordó <span class="emphasis"><em>n</em></span> – jelezvén, hogy a mértéke, néhány kis értékű <span class="emphasis"><em>n</em></span> kivételével, a legtöbb esetben <span class="emphasis"><em>n</em></span> konstans-szorosa. Formálisan:</p><p><code class="code"><em><span class="remark">T</span></em>(<em><span class="remark">n</span></em>) <em><span class="remark">O</span></em>(<em><span class="remark">f </span></em>(<em><span class="remark">n</span></em>)) mértékű, ha <em><span class="remark">T</span></em>(<em><span class="remark">n</span></em>) ≤ <em><span class="remark">kf</span></em>(<em><span class="remark">n</span></em>) valamilyen <em><span class="remark">k</span></em>-ra, minden <em><span class="remark">n </span></em>&gt;<em><span class="remark"> n</span></em><sub>0</sub> esetén.</code></p><p>Az <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) jelölés az <span class="strong"><strong>aszimptotikus analízis</strong></span>t (<span class="strong"><strong>asymptotic analysis</strong></span>) jelenti. Külön vizsgálat nélkül azt mondhatjuk, hogy ha <span class="emphasis"><em>n</em></span> aszimptotikusan közeledik a végtelenhez, egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) algoritmus jobb, mint egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) algoritmus. Egy egyedi teljesítménymérő adat egy ilyen kijelentést nem tudna alátámasztani.</p><p>Az <span class="emphasis"><em>O</em></span>() jelölés a konstans szorzóktól eltekint, emiatt kevésbé precíz, viszont könnyebb használni, mint a <span class="emphasis"><em>T</em></span>()-t. Így például egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) algoritmus egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) algoritmusnál hosszú távon mindig rosszabb lesz, azonban ha a két algoritmus <span class="emphasis"><em>T</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup> + 1) és <span class="emphasis"><em>T</em></span>(100<span class="emphasis"><em>n</em></span> + 1000), akkor az <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) algoritmus <span class="emphasis"><em>n </em></span>≤<span class="emphasis"><em> </em></span>110-re jobb lesz.</p><p>E hátránya ellenére az aszimptotikus elemzés az algoritmuselemzés legelterjedtebben használt módszere. Ez azért van így, mert az elemzés mind a műveletek egzakt számától (a <span class="emphasis"><em>k</em></span> konstans tényezőt figyelmen kívül hagyva), mind a bemenet egzakt tartalmától (csupán <span class="emphasis"><em>n</em></span> nagyságát figyelembe véve) elvonatkoztat. Ily módon az elemzés matematikailag kivitelezhetővé válik. Az <span class="emphasis"><em>O</em></span>() jelölés jó kompromisszum a precizitás és a könnyű elemzés között.</p></div><div class="section" title="NP és az inherensen nehéz problémák"><div class="titlepage"><div><div><h2 class="title"><a id="id803547"/>NP és az inherensen nehéz problémák</h2></div></div></div><p>Az algoritmusok elemzése és az <span class="emphasis"><em>O</em></span>() jelölés lehetővé teszi, hogy egy konkrét algoritmus hatékonyságáról nyilatkozzunk. Arról azonban nem tudunk mondani semmit, hogy az adott problémához van-e nála jobb algoritmus. A <span class="strong"><strong>bonyolultságelmélet</strong></span> (<span class="strong"><strong>complexity analysis</strong></span>) területe nem az algoritmusokat, hanem inkább a problémákat elemzi. Az első nagy szakadék a polinom időben megoldható és a polinom idejű megoldást nélkülöző problémák között van, akármilyen algoritmust is használnánk. A polinom idejű problémák osztályát – azokét, amelyek <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n<sup>k</sup></em></span>) időben oldhatók meg valamilyen <span class="emphasis"><em>k</em></span> esetén – P-vel jelöljük. Ezeket néha „könnyű” problémáknak hívjuk, mert az osztályhoz <span class="emphasis"><em>O</em></span>(log<span class="emphasis"><em>n</em></span>) és <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) futási idejű problémák is tartoznak. Idetartoznak azonban <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>1000</sup>) problémák is, a „könnyű” elnevezést tehát túlságosan szó szerint venni nem lehet.</p><p>A problémák másik fontos osztálya az NP osztály, a nemdeterminisztikus polinom idejű problémák osztálya. Egy probléma akkor tartozik ide, ha létezik egy algoritmus, ami polinom időben meg tud találni egy megoldást, és még ellenőrizni is tudja, hogy a megtalált megoldás korrekt-e. Az ötlet az, hogy ha tetszőlegesen nagyszámú proceszszorral rendelkezünk ahhoz, hogy az összes sejtést egyszerre próbáljuk ki, vagy pedig ha szerencsések vagyunk, és mindig elsőre eltaláljuk a helyes megoldást, az NP probléma P problémává válik. A számítógépes tudomány egyik nagy nyitott kérdése az, hogy az NP osztály ekvivalens-e a P osztállyal akkor, ha nélkülözzük a végtelen processzorhalmaz, illetve a mindentudó sejtés luxusát. A legtöbb számítógépes szakember meg van győződve arról, hogy P ≠ NP, vagyis, hogy az NP problémák inherens módon nehezek, és nincsenek számukra polinom idejű algoritmusok. Ezt azonban még soha sem bizonyították be.</p><p>Akik a P = NP eldöntése iránt érdeklődnek, azok figyelmébe az NP osztály egy alosztályát, az <span class="strong"><strong>NP-teljes</strong></span> (<span class="strong"><strong>NP-complete</strong></span>) problémák alosztályát ajánljuk. A <span class="emphasis"><em>teljes</em></span> szó itt a „legvégsőt” jelenti, és az NP osztály legnehezebb problémáit jelöli ki. Azt bebizonyították már, hogy vagy minden NP-teljes probléma P-ben van, vagy egyik sem. Emiatt ez az osztály elméletileg érdekes, de gyakorlati jelentősége is van, mert sok fontos problémáról tudjuk, hogy NP-teljes. Egy lehetséges példa a Boole-kifejezések kielégíthetőségének problémája: egy adott logikai kifejezés esetén létezik-e az ítéletváltozóinak olyan logikaiérték-hozzárendelése, hogy a kifejezés igaz legyen? Hacsak egy csodának nem leszünk tanúi, és a P = NP nem lesz igaz, nincs olyan algoritmus, amely <span class="emphasis"><em>minden</em></span> kielégíthetőségi problémát polinomiális időben megold. Az MI azonban jobban érdekelt abban, hogy vajon léteznek-e hatékony algoritmusok <span class="emphasis"><em>tipikus,</em></span> előre rögzített eloszlásokból sorsolt problémák esetén. Ahogy ezt a 7. fejezetben láttuk, vannak olyan algoritmusok, mint a <code class="code">WALKSAT</code>, amelyek sok probléma esetén egészen jól teljesítenek.</p><p>A <span class="strong"><strong>co-NP</strong></span> osztály az NP komplemense abban az értelemben, hogy minden NP-beli döntési probléma esetén létezik egy neki megfelelő co-NP-beli probléma felcserélt „igen” és „nem” válaszokkal. Tudjuk, hogy a P mind az NP, mind a co-NP osztályok részhalmaza, és azt gondoljuk, hogy vannak olyan co-NP-beli problémák, amelyek P-nek nem elemei. A co-NP osztály legnehezebb problémái a <span class="strong"><strong>co-NP-teljes</strong></span> problémák.</p><p>A #P osztály az NP-beli döntési problémáknak megfelelő számlálási problémák halmaza. Döntési problémáknak igen-nem a megoldásuk: például létezik-e megoldása ennek a 3-SAT mondatnak? A számlálási problémáknak egész számok a megoldásaik; mennyi megoldása van ennek a 3-SAT mondatnak? Egyes esetekben a számlálási probléma a döntési problémánál sokkal nehezebb. Így például annak az eldöntése, hogy egy páros gráfhoz létezik-e egy tökéletes párosítása <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>VE</em></span>) idejű (ahol a gráfnak <span class="emphasis"><em>V</em></span> csúcsa és <span class="emphasis"><em>E</em></span> éle van). A „hány tökéletes párosítása létezik egy konkrét páros gráf esetén” számlálási probléma viszont #P-teljes, amin azt kell érteni, hogy legalább olyan nehéz, mint a #P-beli problémák bármelyike, és így legalább olyan nehéz, mint az NP-beli problémák bármelyike.</p><p>A P-TÁR – a polinom-tárigényű – problémák osztályát szintén tanulmányozták még nemdeterminisztikus gép esetén is. Az az általános vélekedés, hogy a P-TÁR-nehéz problémák az NP-teljes problémáknál nehezebbek, bár kiderülhet, hogy NP = P-TÁR, mint ahogy az is kiderülhet, hogy P = NP.</p></div></div></div></body></html>
