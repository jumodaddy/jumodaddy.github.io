<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="A problémák struktúrája"><div class="titlepage"><div><div><h1 class="title"><a id="id565451"/>A problémák struktúrája</h1></div></div></div><p>Ebben az alfejezetben azt vizsgáljuk meg, miként lehet a probléma <span class="emphasis"><em>struktúráját,</em></span> ahogy azt a kényszergráf megmutatja, felhasználni a megoldások gyors keresésére. Az itt tárgyalt megközelítések java része nagyon általános és a kényszerkielégítési problémákon kívül más eseteknél is alkalmazható, például a valószínűségi következtetésnél. Végül is a részproblémákká történő dekompozíció az egyetlen mód, mellyel remélhetjük, hogy megbirkózhatunk a valósvilág-beli problémákkal. Ismét ránézve az 5.1. (b) ábrára, miközben a probléma struktúráját keressük, egy tény ötlik a szemünkbe ki: Tasmania nincs összeköttetésben a nagy szárazfölddel.<sup>[<a id="id565461" href="#ftn.id565461" class="footnote">50</a>]</sup><sup> </sup>Napnál világosabb, hogy Tasmania színezése és a szárazföld színezése <span class="strong"><strong>független részproblémá</strong></span>k (<span class="strong"><strong>independent subproblem</strong></span>s): a szárazföld színezésének bármely megoldása és Tasmania színezésének bármely megoldása kombinálva egyben a teljes térkép színezésének is megoldása lesz. A függetlenségről könnyű megbizonyosodni a kényszergráf <span class="strong"><strong>összefüggő komponens</strong></span>eit (<span class="strong"><strong>connected component</strong></span>s) vizsgálva. Mindegyik komponens egy <span class="emphasis"><em>CSP<sub>i</sub></em></span> részproblémának felel meg. Ha az <span class="emphasis"><em>S<sub>i</sub></em></span> hozzárendelés egy megoldás a <span class="emphasis"><em>CSP<sub>i</sub></em></span> részproblémára, akkor az ∪<span class="emphasis"><em><sub>i </sub>S<sub>i </sub></em></span>hozzárendelés megoldása lesz az ∪<sub>i</sub> <span class="emphasis"><em>CSP<sub>i</sub></em></span>-nek. Miért fontos ez? Gondoljunk bele a következőbe: tegyük fel, hogy minden egyes <span class="emphasis"><em>CSP<sub>i</sub></em></span>-nek <span class="emphasis"><em>c</em></span> változója van az <span class="emphasis"><em>n</em></span>-ből, ahol <span class="emphasis"><em>c</em></span> konstans. Ekkor <span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>c </em></span>részproblémánk van, amelyek mindegyike legfeljebb <span class="emphasis"><em>d<sup>c</sup> </em></span>komplexitású. Tehát a teljes komplexitás <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d<sup>c</sup>n</em></span>/<span class="emphasis"><em>c</em></span>), ami lineáris <span class="emphasis"><em>n</em></span>-ben, míg dekompozíció nélkül <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d<sup>n</sup></em></span>), ami exponenciális <span class="emphasis"><em>n</em></span>-ben. Tegyük ezt még konkrétabbá: egy <span class="emphasis"><em>n </em></span>=<span class="emphasis"><em> </em></span>80-nal jellemzett Boole CSP-t négy részproblémává osztva (<span class="emphasis"><em>c </em></span>= 20)<span class="emphasis"><em> </em></span>a megoldás futási idejét a legrosszabb esetben is az univerzum élethosszáról a másodperc törtrészére rövidítjük le.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A teljesen független részproblémák ínyencfalatok, de ritkák. A legtöbb esetben a kényszerkielégítési problémák részproblémái kapcsolatban vannak egymással. A legegyszerűbb eset az, amikor a kényszergráf egy <span class="strong"><strong>fá</strong></span>t alkot: bármely két változót legfeljebb egy út köt össze. Az 5.10. (a) ábra egy sematikus példát mutat erre.<sup>[<a id="id565613" href="#ftn.id565613" class="footnote">51</a>]</sup> Meg fogjuk mutatni, hogy bármely <span class="emphasis"><em>fastruktúrájú kényszerkielégítési probléma megoldható a változók száma szerinti lineáris időben.</em></span> Az algoritmusnak a következő lépései vannak:</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Válasszuk ki bármelyik változót a fa gyökércsomópontjául, és rendezzük a többi változót a gyökértől a levelekig úgy, hogy mindegyik csomópontot a sorrendezésben megelőzzön a szülője (lásd 5.10. (b) ábra). Címkézzük ezeket a változókat sorban <span class="emphasis"><em>X</em></span><sub>1</sub>, …, <span class="emphasis"><em>X<sub>n</sub></em></span>-nel. Most, a gyökércsomópontot leszámítva, mindegyik változónak pontosan egy szülője van.</p></li><li class="listitem"><p>Alkalmazzuk az élkonzisztenciát (<span class="emphasis"><em>X<sub>i</sub></em></span>,<span class="emphasis"><em> X<sub>j</sub></em></span>)-re, ahol <span class="emphasis"><em>X<sub>i </sub></em></span>szülője <span class="emphasis"><em>X<sub>j</sub></em></span>-nek (<span class="emphasis"><em>j</em></span> pedig fusson visszafelé <span class="emphasis"><em>n</em></span>-től 2-ig), és szükség esetén vegyünk ki értékeket a <code class="code">TARTOMÁNY</code>[ <span class="emphasis"><em>X<sub>i</sub></em></span>]-ből.</p></li><li class="listitem"><p>Adjunk <span class="emphasis"><em>X<sub>j</sub></em></span>-nek bármilyen, <span class="emphasis"><em>X<sub>i </sub></em></span>hozzárendelt értékével konzisztens értéket ahol <span class="emphasis"><em>X<sub>i</sub></em></span><sub> </sub>szülője <span class="emphasis"><em>X<sub>j</sub></em></span>-nek, és <span class="emphasis"><em>j</em></span> 1-től <span class="emphasis"><em>n</em></span>-ig halad.</p></li></ol></div><div class="figure"><a id="id565727"/><p class="title"><strong>5.10. ábra - (a) Egy faszerkezetű kényszerkielégítési probléma kényszergráfja. (b) Az <span class="emphasis"><em>A</em></span> csomópont gyökérnek tekintésével konzisztens változók egy lineáris rendezése.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-10.png" alt="(a) Egy faszerkezetű kényszerkielégítési probléma kényszergráfja. (b) Az A csomópont gyökérnek tekintésével konzisztens változók egy lineáris rendezése."/></div></div></div><p>Két dolog érdemes említésre. Egyrészt a 2. lépés után a kényszerkielégítési probléma irány szerint élkonzisztens, tehát a 3. lépés hozzárendeléseiben nincsen szükség visszalépésre (lásd a <span class="emphasis"><em>k</em></span>-konzisztencia tárgyalását a <a class="xref" href="ch05s02.md#ID_193_oldal">„A kényszerek terjesztése”</a> részben). Másrészt, miután a 2. lépésben fordított sorrendben alkalmaztuk az élkonzisztencia-ellenőrzéseket, elértük az algoritmussal, hogy a törölt értékek ne veszélyeztessék a már feldolgozott élek konzisztenciáját. A teljes algoritmus <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>nd</em></span><sup>2</sup>)<span class="emphasis"><em> </em></span>időben fut. </p><p>Most, hogy fákra már van egy hatékony algoritmusunk, megvizsgálhatjuk, miként lehet az általánosabb kényszergráfokat valahogyan fákra <span class="emphasis"><em>visszavezetni</em></span>. Alapvetően két mód van erre: az egyik a csomópontok eltávolításán, a másik a csomópontok összevonásán alapul.</p><p>Az első megközelítés úgy jár el, hogy néhány változónak értéket ad, a maradékok pedig fát fognak alkotni. Vegyük ismét az 5.11. (a) ábrán látható kényszergráfot az Ausztrália-példához. Ha törölni tudnánk Dél-Ausztráliát, akkor a gráf fává válhatna (ahogy az ábra (b) részén látható). Szerencsére meg tudjuk tenni ezt (a gráfban, nem a kontinensen) azzal, hogy <span class="emphasis"><em>DA</em></span> értékét rögzítjük, és a többi változó tartományából töröljük azokat az értéket, melyek inkonzisztensek a <span class="emphasis"><em>DA</em></span> számára választottal. </p><p>Most tehát hogy mind <span class="emphasis"><em>DA-</em></span>t, mind a rá vonatkozó kényszereket<span class="emphasis"><em> </em></span>eltávolítottuk, a kényszerkielégítési probléma bármely megoldása konzisztens lesz a <span class="emphasis"><em>DA</em></span> számára választott értékkel. (Ez bináris kényszerkielégítési problémák esetén működik; a helyzet jóval bonyolultabb magasabb rendű kényszerek esetén.) Tehát a keletkező fa a fenti algoritmussal megoldható, és így az egész problémát is megoldottuk. Általános esetben persze (nem úgy, mint a térképszínezésnél) a <span class="emphasis"><em>DA</em></span> számára választott érték lehet rossz is, és ekkor egyesével végig kell próbálgatni őket. Az általános algoritmus az alábbi:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Válasszunk ki egy <span class="emphasis"><em>S</em></span> részhalmazt a <code class="code">VÁLTOZÓK</code>[<span class="emphasis"><em>csp</em></span>]-ből úgy, hogy a kényszergráf <span class="emphasis"><em>S</em></span> eltávolítása után fa legyen. <span class="emphasis"><em>S</em></span>-et <span class="strong"><strong>ciklikusság-vágóhalmaz</strong></span>nak (<span class="strong"><strong>cycle cutset</strong></span>) nevezzük.</p></li><li class="listitem"><p><span class="emphasis"><em>S</em></span> minden egyes változójának minden egyes, az <span class="emphasis"><em>S</em></span>-re vonatkozó összes kényszert kielégítő lehetséges hozzárendelésére:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>vegyük ki a fennmaradó változók tartományaiból az <span class="emphasis"><em>S</em></span> számára választott hozzárendeléssel inkonzisztens értékeket, és</p></li><li class="listitem"><p>ha a fennmaradó kényszerkielégítési problémának van megoldása, akkor adjuk vissza ezt az <span class="emphasis"><em>S</em></span> hozzárendelésével együtt.</p></li></ol></div></li></ol></div><p>Ha a ciklikusság-vágóhalmaz mérete <span class="emphasis"><em>c</em></span>, akkor a teljes futási idő <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d<sup>c</sup></em></span> · (<span class="emphasis"><em>n</em></span> – <span class="emphasis"><em>c</em></span>)<span class="emphasis"><em>d</em></span><sup>2</sup>) lesz. Ha a gráf „közel fa”, akkor <span class="emphasis"><em>c</em></span> kicsi lesz, a megtakarítás pedig tetemes a gondolkodás nélküli visszalépéses megoldáshoz képest. A legrosszabb esetben azonban <span class="emphasis"><em>c</em></span> akár (<span class="emphasis"><em>n</em></span> – 2) méretű is lehet. A <span class="emphasis"><em>legkisebb</em></span> ciklikusság-vágóhalmaz megtalálása NP-nehéz probléma, de sok hatékony algoritmust ismerünk erre a feladatra. Az általános algoritmikus megközelítés a <span class="strong"><strong>vágóhalmaz-kondicionálás</strong></span> (<span class="strong"><strong>cutset conditioning</strong></span>); még találkozni fogunk ezzel a 14. fejezetben, ahol a valószínűségekről történő következtetésekhez használjuk.</p><div class="figure"><a id="id565915"/><p class="title"><strong>5.11. ábra - (a) Az 5.1. ábrán szereplő eredeti kényszergráf. (b) A kényszergráf <span class="emphasis"><em>DA</em></span> eltávolítását követően.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-11.png" alt="(a) Az 5.1. ábrán szereplő eredeti kényszergráf. (b) A kényszergráf DA eltávolítását követően."/></div></div></div><p>A második megközelítés a kényszergráf több, egymással kapcsolatban lévő részproblémából álló <span class="strong"><strong>fadekompozíció</strong></span> (<span class="strong"><strong>tree decomposition</strong></span>) előállításán alapul. Mindegyik részproblémát függetlenül oldjuk meg, és a keletkező megoldásokat összekapcsoljuk. A legtöbb „oszd meg és uralkodj” típusú megközelítéshez hasonlóan ez is akkor működik, ha egyik részprobléma sem túl nagy. Egy fadekompozíciónak az alábbi követelményeket kell kielégítenie:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Az eredeti probléma mindegyik változója szerepeljen a részproblémák legalább egyikében.</p></li><li class="listitem"><p>Ha bármely két változót az eredeti problémában egy kényszer köt össze, akkor a részproblémák legalább egyikében együtt is elő kell fordulniuk (és természetesen a kényszernek is). </p></li><li class="listitem"><p>Ha egy változó a fa két részproblémájában is előfordul, akkor a változónak az ezeket a részproblémákat összekötő út minden részproblémájában is elő kell fordulnia.</p></li></ul></div><p>Az első két kikötés biztosítja, hogy az összes változó és kényszer előforduljon a dekompozícióban. A harmadik kikötés eléggé technikai ízűnek tűnik, de egyszerűen csak arról szól, hogy bármely adott változónak ugyanazzal az értékkel kell rendelkeznie az összes részproblémában, ahol előfordul – a részproblémákat a fában összekötő élek kényszerítik ezt ki. Például <span class="emphasis"><em>DA</em></span> az 5.12. ábra mindegyik összekötött részproblémájában előfordul. Az olvasó az 5.11. ábra alapján igazolhatja, hogy van értelme ennek a dekompozíciónak.</p><p>Külön-külön megoldhatjuk az egyes részproblémákat, és ha bármelyiknek is nincs megoldása, akkor az egész problémának nincs. Ha az összes részproblémát meg tudjuk oldani, akkor a következők szerint megpróbálhatunk összeállítani egy globális megoldást. Először is tekintsünk minden egyes változót egy „megaváltozónak”, amelynek tartománya a részprobléma összes megoldásának halmaza. Például az 5.12. ábra bal szélső részproblémája az a térképszínezési probléma, amelynek három változója és – ezek szerint – hat megoldása van (ezek egyike az {<span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span>,<span class="emphasis"><em> DA </em></span>=<span class="emphasis"><em> kék</em></span>,<span class="emphasis"><em> ÚT </em></span>= <span class="emphasis"><em>zöld</em></span>}). Ezután a részproblémákat összekötő kényszereket meg tudjuk oldani a fákra adott fent bemutatott hatékony algoritmussal. A részproblémák közti kényszerek egyszerűen csak azért vannak, hogy a részproblémák megoldásai megegyezzenek az osztott változókban. Például, ha adott az {<span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span>,<span class="emphasis"><em> DA </em></span>=<span class="emphasis"><em> kék</em></span>,<span class="emphasis"><em> ÚT </em></span>=<span class="emphasis"><em> zöld</em></span>} megoldás az első részproblémára, akkor a következő részprobléma egyetlen konzisztens megoldása a {<span class="emphasis"><em>DA </em></span>=<span class="emphasis"><em> kék</em></span>,<span class="emphasis"><em> ÚT </em></span>=<span class="emphasis"><em> zöld</em></span>,<span class="emphasis"><em> Q </em></span>=<span class="emphasis"><em> vörös</em></span>} lehet.</p><div class="figure"><a id="id566029"/><p class="title"><strong>5.12. ábra - Az 5.11. ábra (a) részén szereplő kényszergráf egy fa dekompozíciója</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-12.png" alt="Az 5.11. ábra (a) részén szereplő kényszergráf egy fa dekompozíciója"/></div></div></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Egy adott kényszergráfnak több dekompozíciója is lehetséges; a dekompozíció kiválasztásakor az a cél, hogy a részproblémák a lehető legkisebbek legyenek. Egy gráf fadekompozíciójának <span class="strong"><strong>faszélesség</strong></span>e (<span class="strong"><strong>tree width</strong></span>) eggyel kisebb, mint a legnagyobb részprobléma mérete; magának a gráfnak a faszélessége pedig definíció szerint a legkisebb faszélesség az összes fadekompozíciója között. Ha egy gráfnak <span class="emphasis"><em>w</em></span> a faszélessége, és adott a megfelelő fadekompozíció, akkor a problémát meg lehet oldani <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>nd<sup>w</sup></em></span><sup>+1</sup>) időben. Tehát <span class="emphasis"><em>egy felülről korlátos faszélességű kényszergráffal rendelkező kényszerkielégítési probléma polinomiális időben megoldható</em></span>. Sajnálatos módon egy minimális faszélességű fadekompozíció megtalálása NP-nehéz probléma, de vannak olyan heurisztikus módszerek, amelyek jól működnek a gyakorlatban.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id565461" href="#id565461" class="para">50</a>] </sup> Egy nagyon gondos térképész vagy egy tasmaniai patrióta ellenvethetné, hogy Tasmaniát nem lehet ugyanolyan színnel színezni, mint a legközelebbi szárazföldi szomszédját, nehogy úgy tűnjön, <span class="emphasis"><em>mintha</em></span> annak az államnak a része lenne.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id565613" href="#id565613" class="para">51</a>] </sup> Sajnos nagyon kevés olyan területe van a világnak (talán Celebesz ilyen), amelynek faszerkezetű térképe van. (Celebesz egy közelítőleg csillagstruktúrájú sziget Közép-Indonéziában – <span class="emphasis"><em>A ford.</em></span>)</p></div></div></div></body></html>
