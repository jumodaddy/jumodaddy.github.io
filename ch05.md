<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="5. fejezet - Kényszerkielégítési problémák"><div class="titlepage"><div><div><h1 class="title"><a id="id561856"/>5. fejezet - Kényszerkielégítési problémák</h1></div></div></div><p><span class="emphasis"><em>Ebben a fejezetben megmutatjuk azt, hogy ha az állapotokat nem egyszerűen kis fekete dobozoknak tekintjük, akkor új hatékony keresési módszerek egész sorához jutunk, valamint jobban megértjük a probléma struktúráját és komplexitását.</em></span></p><p>A 3. és a 4. fejezetben azt az elképzelést jártuk körbe, hogy a problémákat <span class="strong"><strong>állapottér</strong></span>beli kereséssel lehet megoldani. A tárgyterületre jellemző heurisztikák segítségével értékelhetjük ezeket az állapotokat és ellenőrizhetjük, hogy nem járunk-e célállapotban. A keresési algoritmus szempontjából azonban mindegyik állapot egy megkülönböztetés nélküli belső struktúrájú <span class="strong"><strong>fekete doboz</strong></span> (<span class="strong"><strong>black box</strong></span>). Az állapotokat egy tetszőleges adatstruktúra reprezentálja, amelyhez <span class="emphasis"><em>a problémára jellemző</em></span> rutinokkal lehet hozzáférni: az állapotátmenet- és a heurisztikafüggvénnyel, valamint a célállapotteszttel.</p><p>A fejezetben a <span class="strong"><strong>kényszerkielégítési problémá</strong></span>kkal (<span class="strong"><strong>constraint satisfication prob</strong></span><span class="strong"><strong>lem</strong></span>s) foglalkozunk, amikor az állapotok és a célteszt illeszkedik egy szabályos, strukturált és elég egyszerű <span class="strong"><strong>reprezentáció</strong></span>hoz (lásd<span class="emphasis"><em> </em></span>5.1. alfejezet). Az állapotstruktúra segítségével keresési algoritmusokat lehet definiálni, és nem <span class="emphasis"><em>problémaspecifikus, </em></span>hanem<span class="emphasis"><em> általános célú</em></span> heurisztikák használatával nagy problémák megoldása is lehetővé válik (lásd 5.2. és 5.3. alfejezet). Talán a legfontosabb azonban az, hogy a célteszt szabályos reprezentációja feltárja magának a problémának a struktúráját (lásd 5.4. alfejezet). Ez pedig módszereket ad a kezünkbe a probléma dekompozíciójára, és lehetővé teszi, hogy megértsük a probléma struktúrája és a megoldás nehézsége közötti szoros kapcsolatot.</p><div class="section" title="Kényszerkielégítési problémák"><div class="titlepage"><div><div><h1 class="title"><a id="id561915"/>Kényszerkielégítési problémák</h1></div></div></div><p>A <span class="strong"><strong>kényszerkielégítési problémá</strong></span>k (angol rövidítéssel <span class="strong"><strong>CSP</strong></span>) formális definícióját <span class="strong"><strong>változó</strong></span>k (<span class="strong"><strong>variable</strong></span>s), <span class="emphasis"><em>X</em></span><sub>1</sub>, <span class="emphasis"><em>X</em></span><sub>2</sub>, …, <span class="emphasis"><em>X<sub>n</sub></em></span>, és <span class="strong"><strong>kényszer</strong></span>ek (<span class="strong"><strong>constraint</strong></span>s), <span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>C</em></span><sub>2</sub>, …, <span class="emphasis"><em>C<sub>m</sub></em></span> halmazaival adhatjuk meg. Minden egyes <span class="emphasis"><em>X<sub>i</sub><sub> </sub></em></span>változó esetén adott a lehetséges <span class="strong"><strong>érték</strong></span>ek egy nem-üres <span class="emphasis"><em>D<sub>i </sub></em></span><span class="strong"><strong>t</strong></span><span class="strong"><strong>artománya</strong></span>. Minden egyes <span class="emphasis"><em>C<sub>i</sub> </em></span>kényszer a változók valamely részhalmazára vonatkozik, és meghatározza a részhalmaz megengedett értékkombinációit. Egy problémaállapotot az definiál, hogy vagy néhány, vagy mindegyik változóhoz értékeket <span class="strong"><strong>rendelünk hozzá</strong></span> {<span class="emphasis"><em>X<sub>i</sub></em></span> = <span class="emphasis"><em>v<sub>i</sub></em></span>, <span class="emphasis"><em>X<sub>j</sub></em></span> = <span class="emphasis"><em>v<sub>j</sub></em></span>, ...}. Egy hozzárendelést <span class="strong"><strong>konzisztens</strong></span>nek (vagy megengedettnek) nevezünk, ha egyetlen kényszert sem sért meg. Teljes az a hozzárendelés, amelyben mindegyik változó szerepel, és egy teljes hozzárendelés a kényszerkielégítési problémának <span class="strong"><strong>megoldása</strong></span>, ha mindegyik kényszert kielégíti. Néhány kényszerkielégítési probléma azt is igényli, hogy a megoldás egy <span class="strong"><strong>célfüggvény</strong></span>t maximalizáljon.</p><p>Mit is jelent mindez? Tegyük fel, hogy Romániába beleunva Ausztrália térképét tanulmányozzuk, és a térképen az 5.1. (a) ábrán feltüntetett államokat és területeket látjuk, feladatunk pedig az, hogy vörössel, zölddel és kékkel minden egyes részt színezzünk ki úgy, hogy a szomszédos részeknek ne legyen azonos a színe. Ahhoz, hogy ezt kényszerkielégítési problémaként fogalmazhassuk meg, változókat kell bevezetnünk az egyes részekhez: <span class="emphasis"><em>NyA</em></span>, <span class="emphasis"><em>ÉT</em></span>, <span class="emphasis"><em>Q</em></span>, <span class="emphasis"><em>ÚDW</em></span>, <span class="emphasis"><em>V</em></span>, <span class="emphasis"><em>DA </em></span>és <span class="emphasis"><em>T</em></span>. Mindegyik változó tartománya a {<span class="emphasis"><em>vörös</em></span>, <span class="emphasis"><em>zöld</em></span>, <span class="emphasis"><em>kék</em></span>} halmaz. Kényszerek írják elő, hogy a szomszédos részek különböző színűek legyenek, például <span class="emphasis"><em>NyA </em></span>és <span class="emphasis"><em>ÉT</em></span> esetén a megengedhető kombinációk az alábbi párok lehetnek:</p><p><code class="code">{(<em><span class="remark">vörös</span></em>, <em><span class="remark">zöld</span></em>), (<em><span class="remark">vörös</span></em>, <em><span class="remark">kék</span></em>), (<em><span class="remark">zöld</span></em>, <em><span class="remark">vörös</span></em>), (<em><span class="remark">zöld</span></em>, <em><span class="remark">kék</span></em>), (<em><span class="remark">kék</span></em>, <em><span class="remark">vörös</span></em>), (<em><span class="remark">kék</span></em>, <em><span class="remark">zöld</span></em>)} </code></p><p>(A kényszert tömörebben is ki lehet fejezni a <span class="emphasis"><em>NyA </em></span>≠<span class="emphasis"><em> ÉT </em></span>egyenlőtlenséggel, feltéve persze, hogy a kényszermegoldó algoritmus valamiképpen ki tudja értékelni az ilyen kifejezéseket.) Sok lehetséges megoldás adódik, mint például az</p><p><code class="code">{<em><span class="remark">NyA</span></em> = <em><span class="remark">vörös</span></em>, <em><span class="remark">ÉT </span></em>= <em><span class="remark">zöld</span></em>, <em><span class="remark">Q </span></em>= <em><span class="remark">vörös</span></em>, <em><span class="remark">ÚDW </span></em>= <em><span class="remark">zöld</span></em>, <em><span class="remark">V </span></em>= <em><span class="remark">vörös</span></em>, <em><span class="remark">DA </span></em>= <em><span class="remark">kék</span></em>, <em><span class="remark">T </span></em>= <em><span class="remark">vörös</span></em>}</code></p><p>Gyakran hasznos lehet, ha felrajzoljuk a kényszerkielégítési probléma <span class="strong"><strong>kényszergráf</strong></span>ját (<span class="strong"><strong>constraint graph</strong></span>), amint az az 5.1. (b) ábrán is látható. A gráf csomópontjai a probléma változóinak, élei pedig a kényszereknek felelnek meg.</p><p>Sok előnnyel járhat, ha egy problémát kényszerkielégítési problémaként tekintünk. Az állapotok reprezentációja miatt a kényszerkielégítési problémák egy standard mintára illeszkednek (ez a minta a hozzárendelt értékekkel rendelkező változók halmaza), az állapotátmenet-függvényt és a célállapottesztet pedig az összes kényszerkielégítési problémára érvényes általános módon meg lehet írni. Sőt létrehozhatók hatékony, általános heurisztikák minden kiegészítő, tárgyterület-specifikus szakértelem nélkül. Végül pedig a kényszergráf struktúrájának segítségével lerövidíthető a megoldási folyamat, és ez néhány esetben exponenciálisan csökkenti a probléma komplexitását. A kényszerkielégítési probléma reprezentációja a legelső (és a legegyszerűbb) a könyv menete során bemutatott reprezentációs sémák sorában.</p><div class="figure"><a id="id562235"/><p class="title"><strong>5.1. ábra - (a) Ausztrália államai és területei. A térkép kiszínezése tekinthető kényszerkielégítési problémának is. A cél az, hogy minden egyes részhez olyan színt találjunk, amely nem azonos egy szomszédos rész színével sem. (b) A térképszínezési probléma kényszergráfként reprezentálva.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-01.png" alt="(a) Ausztrália államai és területei. A térkép kiszínezése tekinthető kényszerkielégítési problémának is. A cél az, hogy minden egyes részhez olyan színt találjunk, amely nem azonos egy szomszédos rész színével sem. (b) A térképszínezési probléma kényszergráfként reprezentálva."/></div></div></div><p>Könnyű észrevenni, hogy egy kényszerkielégítési problémára adható egy <span class="strong"><strong>inkrementális megfogalmazás</strong></span> (<span class="strong"><strong>incremental formulation</strong></span>), amely a kényszerkielégítési problémát szabályos keresési problémaként tekinti:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Kiinduló állapot</strong></span> (<span class="strong"><strong>initial state</strong></span>): az üres hozzárendelés {}, ahol egyik változónak sincs értéke.</p></li><li class="listitem"><p><span class="strong"><strong>Állapotátmenet-függvény</strong></span> (<span class="strong"><strong>successor function</strong></span>): bármelyik hozzárendelés nélküli változó értéket kaphat, amennyiben ez nem ütközik a korábbi értékadásokkal.</p></li><li class="listitem"><p><span class="strong"><strong>Célteszt</strong></span> (<span class="strong"><strong>goal test</strong></span>): az aktuális hozzárendelés teljes.</p></li><li class="listitem"><p>Az <span class="strong"><strong>út költsége</strong></span> (<span class="strong"><strong>path cost</strong></span>): egy konstans költség (például 1) mindegyik lépésre.</p></li></ul></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Mindegyik megoldásnak egy teljes hozzárendelésnek kell lennie, tehát <span class="emphasis"><em>n</em></span> változó esetén az <span class="emphasis"><em>n</em></span>-edik mélységi szinten jelenik meg. A keresési fa pedig csak <span class="emphasis"><em>n</em></span> mélységű. Emiatt a korlátkielégítési problémák esetén a mélységi keresési algoritmusok népszerűek (lásd 5.2. alfejezet). Az is igaz, hogy <span class="emphasis"><em>a megoldáshoz vezető út nem lényeges.</em></span> Ezért használható a <span class="strong"><strong>teljes állapotleírás</strong></span> (<span class="strong"><strong>complete-state formulation</strong></span>) is, amelyben minden egyes állapot egy teljes változó-hozzárendelés, akár kielégíti a kényszereket, akár nem. Ebben a felírásban a lokális keresési eljárások is használhatók.</p></div><p>A kényszerkielégítési problémák legegyszerűbb esetében a változók <span class="strong"><strong>diszkrét</strong></span>ek és <span class="strong"><strong>véges tartományú</strong></span>ak. A térképszínezési problémák is ehhez az esethez tartoznak. A 3. fejezetben bemutatott 8-királynő problémát is felfoghatjuk véges tartományú kényszerkielégítési problémaként, ahol a <span class="emphasis"><em>Q</em></span><sub>1</sub>, …, <span class="emphasis"><em>Q</em></span><sub>8</sub> változók a királynők 1, …, 8 oszlopokban betöltött pozícióit jelölik, és mindegyik változó tartománya {1, 2, 3, 4, 5, 6, 7, 8}. Amennyiben  maximum <span class="emphasis"><em>d </em></span>a kényszerkielégítési probléma bármely változójához tartozó tartomány mérete, akkor a lehetséges teljes hozzárendelések száma <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d<sup>n</sup></em></span>), azaz a változók számának exponenciális függvénye. A véges tartományú kényszerkielégítési problémák közé tartoznak a Boole-problémák is, ahol a változók értéke vagy <span class="emphasis"><em>igaz,</em></span> vagy <span class="emphasis"><em>hamis</em></span>. A <span class="strong"><strong>Boole kényszerkielégítési problémá</strong></span>k speciális esetként tartalmaznak néhány NP-teljes problémát, például a 3SAT-ot (lásd 7. fejezet). Legrosszabb esetben tehát nem lehetséges, hogy exponenciálisnál kevesebb idő alatt meg tudunk oldani egy véges tartományú kényszerkielégítési problémát. A legtöbb gyakorlati alkalmazásban azonban az általános célú CSP algoritmusok megbirkóznak a 3. fejezetben bemutatott általános célú keresési algoritmusokkal megoldhatóknál <span class="emphasis"><em>több nagyságrenddel nagyobb </em></span>problémákkal is.</p><p>A diszkrét változók lehetnek <span class="strong"><strong>végtelen tartományú</strong></span>ak is: például ilyen az egész számok halmaza vagy a füzérek halmaza. Például amikor egy építkezési munka naptárát ütemezzük, minden feladat kezdési ideje egy változó, amelyeknek lehetséges értékei az aktuális dátum napjait megadó egész számok. Végtelen tartományok esetén már nem lehet a kényszereket a megengedett értékkombinációk felsorolásával leírni. Ehelyett egy <span class="strong"><strong>kényszernyelv</strong></span>et (<span class="strong"><strong>constraint language</strong></span>) kell használni. Például ha <span class="emphasis"><em>Munka</em></span><sub>1</sub> öt napig tart, és meg kell előznie <span class="emphasis"><em>Munka</em></span><sub>3</sub>-t, akkor kényszernyelvként az algebrai egyenlőtlenségek nyelvére van szükségünk, mint például <span class="emphasis"><em>KezdMunka</em></span><sub>1</sub> + 5 ≤<span class="emphasis"><em> KezdMunka</em></span><sub>3</sub>. Továbbá az ilyen kényszereket többé már nem lehet megoldani az összes lehetséges hozzárendelés felsorolásával, mert végtelen sok van belőlük. Különleges megoldó algoritmusok (melyekre itt nem térünk ki) léteznek egész értékű változók<span class="strong"><strong> lineáris kényszer</strong></span>eire, azaz olyan kényszerekre, mint a fenti, ahol mindegyik változó csak lineáris műveletekben jelenik meg. Megmutatható, hogy nem létezhet algoritmus egész értékű változók általános <span class="strong"><strong>nemlineáris kényszer</strong></span>einek megoldására. Néhány esetben az egész értékű kényszerproblémák egyszerűen azzal visszavezethetők véges tartományúakra, hogy korlátozzuk az összes változó értékeit. Egy ütemezési problémában például egy felső korlátot szabhatunk az összes ütemezendő munka teljes hosszára.</p><p>A <span class="strong"><strong>folytonos tartományú</strong></span> kényszerkielégítési problémák elég gyakoriak a valós alkalmazásokban, és az operációkutatáson belül is tanulmányozták ezeket a problémákat. Például a Hubble űrteleszkóp kísérleteinek ütemezése a megfigyelések nagyon pontos időzítését igényli, a megfigyelések és a manőverek kezdeti és befejezési időpontjai folytonos értékű változók és csillagászati, precedencia-, valamint teljesítménykényszerek sokasága vonatkozik rájuk. A folytonos tartományú kényszerkielégítési problémák legismertebb válfaja a <span class="strong"><strong>lineáris programozás</strong></span>i problémák csoportja, ahol a kényszerek <span class="emphasis"><em>konvex</em></span> tartományt alkotó lineáris egyenlőtlenségek. A lineáris programozási feladatokat meg lehet oldani a változók száma szerinti polinomiális időben. Más típusú kényszerekkel és célfüggvényekkel rendelkező problémákat is tanulmányoztak, például ilyennel foglalkozik a kvadratikus programozás, a másodrendű kónikus programozás és hasonló társaik.</p><p>Azon túl, hogy megvizsgálhatjuk a kényszerkielégítési problémákban megjelenő változók típusát, hasznos lehet a kényszerfajtákat is tanulmányozni. A legegyszerűbb fajta az <span class="strong"><strong>unáris kényszer</strong></span> (<span class="strong"><strong>unary constraint</strong></span>), amely egy változó értékére tesz megkötést. Elképzelhető például, hogy a délausztrálok élénken tiltakoznak a <span class="emphasis"><em>zöld</em></span> szín ellen. A hivatkozott változó tartományának előfeldolgozásával mindegyik unáris kényszer kiküszöbölhető: ki kell venni a kényszert sértő összes értéket. A <span class="strong"><strong>bináris kényszer</strong></span> (<span class="strong"><strong>binary constraint</strong></span>) két változót köt össze. Például a <span class="emphasis"><em>DA </em></span>≠ <span class="emphasis"><em>ÚDW</em></span> egy bináris kényszer. A csak bináris kényszerekkel rendelkező kényszerkielégítési problémát binárisnak nevezzük, amit az 5.1. (b) ábrán láthatóhoz hasonló kényszergráffal lehet reprezentálni.</p><p>A magasabb rendű kényszerek három vagy több változóra vonatkoznak. Ennek egy ismerős példája a <span class="strong"><strong>betűrejtvény</strong></span> (lásd 5.2. (a) ábra). A betűrejtvényben általában mindegyik betű különböző számot jelöl. Ez a megkötés az 5.2. (a) ábra betűrejtvénye esetén például a hatváltozós <span class="emphasis"><em>MindKül</em></span>(<span class="emphasis"><em>F</em></span>,<span class="emphasis"><em>T</em></span>,<span class="emphasis"><em>U</em></span>,<span class="emphasis"><em>W</em></span>,<span class="emphasis"><em>R</em></span>,<span class="emphasis"><em>O</em></span>) kényszerrel adható meg. Egy másik megoldás lehet, ha a megkötést bináris kényszerek (mint például<span class="emphasis"><em> F</em></span>≠<span class="emphasis"><em>T</em></span>)<span class="emphasis"><em> </em></span>gyűjteményével adjuk meg. A rejtvény négy oszlopában az összeadáskényszerek több változót is tartalmazhatnak, amelyek a következőképpen írhatók fel:</p><p><code class="code"><em><span class="remark">O</span></em> + <em><span class="remark">O</span></em> = <em><span class="remark">R</span></em> + 10 · <em><span class="remark">X</span></em><sub>1</sub></code></p><p><code class="code"><em><span class="remark">X</span></em><sub>1</sub> + <em><span class="remark">W</span></em> + <em><span class="remark">W</span></em> = <em><span class="remark">U</span></em> + 10 · <em><span class="remark">X</span></em><sub>2</sub></code></p><p><code class="code"><em><span class="remark">X</span></em><sub>2</sub> + <em><span class="remark">T</span></em> + <em><span class="remark">T</span></em> = <em><span class="remark">O</span></em> + 10 · <em><span class="remark">X</span></em><sub>3</sub></code></p><p><code class="code"><em><span class="remark">X</span></em><sub>3</sub> = <em><span class="remark">F</span></em></code></p><p>ahol <span class="emphasis"><em>X</em></span><sub>1</sub>, <span class="emphasis"><em>X</em></span><sub>2</sub> és <span class="emphasis"><em>X</em></span><sub>3</sub> a következő oszlopba átvitt számjegyet (0 vagy 1) reprezentáló <span class="strong"><strong>segédváltozó</strong></span>k (<span class="strong"><strong>auxiliary variable</strong></span>s). A magasabb rendű kényszereket egy <span class="strong"><strong>kényszerhipergráf</strong></span>fal (<span class="strong"><strong>constraint hyprergraph</strong></span>) lehet ábrázolni, amelynek egy példája az 5.2. (b) ábrán látható. Az éles szemű olvasónak feltűnhet, hogy a <span class="emphasis"><em>MindKül </em></span>kényszer felbontható bináris kényszerekre: <span class="emphasis"><em>F </em></span>≠<span class="emphasis"><em> T</em></span>,<span class="emphasis"><em> F </em></span>≠<span class="emphasis"><em> U</em></span> stb. Az 5.11. feladat éppen annak bizonyítását kéri, hogy elegendő segédváltozó bevezetésével mindegyik magasabb rendű véges tartományú kényszer átírható bináris kényszerek halmazává. Ebből kiindulva ebben a fejezetben csak bináris kényszerekkel foglalkozunk.</p><p>Az eddig említett kényszerek mind <span class="strong"><strong>abszolút kényszer</strong></span>ek voltak: egy kényszer megszegése kizár egy megoldásjelöltet. A valós alkalmazások során azonban sok kényszerkielégítési probléma tartalmaz <span class="strong"><strong>preferenciakényszer</strong></span>eket, melyek jelzik, hogy mely megoldások preferáltak. Egy egyetemi órarend meghatározásakor például X professzor talán inkább reggel tanítana, míg Y professzor a délutáni órákat részesítené előnyben. Egy olyan órarend, amely szerint X professzornak délután kettőkor kellene tanítania, még megoldás lenne (persze csak ha X professzor éppenséggel nem a tanszékvezető), de ez nem lenne optimális megoldás. A preferenciakényszerek gyakran az egyedi változó-hozzárendelések költségeként ábrázolhatók: például ha X professzor egy délutáni időpontot kap, az két pontot ront az általános célfüggvényen, míg a reggeli óraidőpont csak egy pontba kerül. Így megfogalmazva a preferenciákkal kiegészített kényszerkielégítési problémák (útvonalalapú vagy lokális) optimalizációs keresési módszerekkel megoldhatók. Az ilyen kényszerkielégítési problémákkal a fejezetben többet nem foglalkozunk, de az irodalomjegyzékben megadunk néhány kiindulási pontként használható hivatkozást.</p><div class="figure"><a id="id562680"/><p class="title"><strong>5.2. ábra - (a) Egy betűrejtvény. Mindegyik betű különböző számjegyet jelöl, a rejtvény célja olyan számjegyeket helyettesíteni a betűk helyére, amelyekkel a kiadódó összeg aritmetikailag helyes lesz (azzal a külön megkötéssel, hogy nem kezdő nullák nem megengedettek). (b) A betűrejtvény kényszerhipergráfja a <span class="emphasis"><em>MindKül</em></span> kényszer és az oszloponkénti összeadási kényszerek feltüntetésével. A kényszereket négyzet alakú dobozok jelölik. Minden doboz azzal a változóval van összekötve, amelyre a doboz által jelzett kényszer vonatkozik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/05-02.png" alt="(a) Egy betűrejtvény. Mindegyik betű különböző számjegyet jelöl, a rejtvény célja olyan számjegyeket helyettesíteni a betűk helyére, amelyekkel a kiadódó összeg aritmetikailag helyes lesz (azzal a külön megkötéssel, hogy nem kezdő nullák nem megengedettek). (b) A betűrejtvény kényszerhipergráfja a MindKül kényszer és az oszloponkénti összeadási kényszerek feltüntetésével. A kényszereket négyzet alakú dobozok jelölik. Minden doboz azzal a változóval van összekötve, amelyre a doboz által jelzett kényszer vonatkozik."/></div></div></div></div></div></body></html>
