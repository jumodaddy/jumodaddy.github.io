<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Szoftverarchitektúrák a robotikában"><div class="titlepage"><div><div><h1 class="title"><a id="id794235"/>Szoftverarchitektúrák a robotikában</h1></div></div></div><p><span class="strong"><strong>Szoftverarchitektúrá</strong></span>nak (<span class="strong"><strong>software architecture</strong></span>) hívják az algoritmusok strukturálásának módszertanát. Egy architektúra általában nyelveket és eszközöket tartalmaz programok írásához, valamint egy átfogó szisztémát, amely alapján a programokat össze lehet illeszteni.</p><p>A modern robotikai szoftverarchitektúráknak sikeresen kell ötvözniük a reaktív irányítást és a modellalapú, tudatos vezérlést. Sok szempontból a reaktív és a tudatos irányítás eltérő előnyökkel és hátrányokkal rendelkezik. A reaktív szabályozás szenzoros információn alapul, és nagyon jól használható valós idejű, alacsony szintű döntéshozásra. Ugyanakkor ritkán ad globális szinten elfogadható megoldást, mert a globális döntések olyan információt igényelnek, amely a döntés meghozatalakor még nincs a robot birtokában. Ilyen esetekben a modellalapú tervezés a megfelelő.</p><p>Következésképpen a legtöbb robotarchitektúra reaktív technikákat használ az alacsony szintű irányításhoz, és modellalapút a magasabb szintűhöz. Amikor a PD szabályozóról beszéltünk, számításba vettünk egy ilyen kombinációt, ahol a (reaktív) PD szabályozó együtt dolgozik a (modellalapú) pályatervezővel. <span class="strong"><strong>Hibrid architektúrá</strong></span>nak (<span class="strong"><strong>hybrid architecture</strong></span>) hívják általában azokat az architektúrákat, amelyek ötvözik a reaktív és a modellalapú technikákat.</p><div class="section" title="Alárendelt architektúra"><div class="titlepage"><div><div><h2 class="title"><a id="id794264"/>Alárendelt architektúra</h2></div></div></div><p>Az <span class="strong"><strong>alárendelt architektúra</strong></span> (<span class="strong"><strong>subsumption architecture</strong></span>) (Brooks, 1986) egy olyan keretrendszer, amelyen belül lehetőség nyílik reaktív szabályozók véges automatákból történő összeállítására. Ezeknél az automatáknál, állapotgépeknél a csomópontok egyes szenzoros változók vizsgálatát tartalmazzák olyan esetekben, ahol a véges automatánál is a változó vizsgálatának eredménye határozta meg a végrehajtás menetét. Az éleket el lehet látni címkékkel, amelyek akkor generálódnak, amikor az éleken áthaladunk, és amelyeket a robot motorjához vagy egy másik véges automatához küldünk. Azonfelül a véges automatáknak vannak belső időzítőik (óráik), amik irányítják, hogy mennyi idő alatt lehet átjutni egy-egy élen. Az így kapott állapotgépet szokás <span class="strong"><strong>kiterjesztett véges automatá</strong></span>nak (KVA) – (<span class="strong"><strong>augmented finite state machine,</strong></span> <span class="strong"><strong>AFSM</strong></span>) hívni, ahol a kiterjesztés a belső órajel használatára vonatkozik.</p><p>Egy egyszerű KVA használatára példa a 25.22. (b) ábrán látható négyállapotú gép, amely ciklikus mozgást generál a hexapod robot számára. Ez az KVA ciklikus szabályozót használ, aminek működése tulajdonképpen nem függ a környezetből jövő visszacsatolástól. Az előrenyújtási szakasz során viszont már használja a szenzoros információt. Ha a láb elakad, azaz nem tudja végrehajtani az előremozgást, a robot visszahúzza a lábat, majd magasabbra emelve újra próbálkozik. Azaz a szabályozó képes <span class="emphasis"><em>reagálni</em></span> a robot környezettel való fizikai érintkezésére.</p><p>Az alárendelt architektúra további primitíveket szolgáltat az KVA-ek szinkronizálásához, és a többszörös, esetleg ellentmondásban lévő KVA-ák kimenetének összehangolásához. Ezáltal lehetővé válik a programozó számára, hogy egyre bonyolultabb szabályozókat építsen fel bottom-up, alulról felfelé technikával. Példánkban egy-egy KVA-val kezdhetünk az egyes lábak vezérléséhez, majd a következő KVA már több láb működésének összehangolását végezheti. Mindezekfölött megvalósíthatunk valamilyen magas szintű viselkedést, mondjuk, egy ütközés elkerülését, amely már hátrálást és visszafordulást is tartalmaz.</p><p>Az ötlet, hogy KVA-ákkal valósítsuk meg a robot szabályozását, igen nagy előrelépés. Képzeljük el, milyen nehéz lenne ugyanezt a viselkedést leírni a konfigurációs térben, bármelyik korábban tárgyalt pályatervező algoritmussal! Először is szükségünk lenne a terep pontos modelljére. A hatlábú robot konfigurációs tere összesen tizennyolc dimenziós (tizenkét dimenzió a lábankénti két-két motortól származik, hat pedig a robot pozíciója és orientációja a környezethez képest). Még ha a számítógépeink elég gyorsak is lennének, hogy kiszámoljanak egy pályát egy ilyen kiterjedt térben, további problémát jelentenének az egyéb előforduló hatások, mint például az, ha a robot megcsúszik a lejtőn. Az ilyen sztochasztikus hatások miatt egyetlen út a konfigurációs térben csaknem bizonyosan túl törékeny lenne, és még egy PID szabályozó sem tudna megbirkózni a felmerülő problémákkal. Más szavakkal, a modellalapú mozgástervezés túl bonyolult feladat a mai robotok pályatervező algoritmusainak.</p><p>Sajnos azonban az alárendelt architektúrának is megvannak a maga problémái. Először is, az KVA-ák általában feldolgozatlan szenzoros információt kapnak, ami csak akkor elegendő a döntéshozáshoz, ha az adatok megbízhatók, és tartalmazzák az összes szükséges információt. De ha a szenzoros adatokat nemtriviális módon kell időben integrálni, akkor sikertelen lehet a döntéshozás. Éppen ezért az alárendelt típusú szabályozókat lokális feladatokra használják, mint például fal mentén haladás vagy egy látható fényforrás követése. Másodszor, a modell hiánya nehézkessé teszi a robot feladatának megváltoztatását. Az alárendelt típusú robot általában csak egy feladatot hajt végre, és nincs is elképzelése arról, hogy hogyan módosíthatná vezérlését úgy, hogy más feladatokat is el tudjon látni (mint a ganajtúró bogár a 2.2. alfejezetben). Végezetül, az alárendelt típusú vezérlést elég nehéz átlátni. A gyakorlatban több tucat bonyolult, együttműködő KVA és a környezet kölcsönhatásait a legtöbb programozó már nem tudja követni. Ezen okok miatt az alárendelt architektúrát – nagy történeti jelentősége ellenére – ritkán szokták kereskedelmi forgalomba kerülő robotoknál használni. Ugyanakkor néhány leszármazottját már igen.</p></div><div class="section" title="Háromréteges architektúra"><div class="titlepage"><div><div><h2 class="title"><a id="id794308"/>Háromréteges architektúra</h2></div></div></div><p>A hibrid architektúra modellbe épített tudással ötvözi a reaktivitást. Messze a legnépszerűbb hibrid architektúra az úgynevezett <span class="strong"><strong>háromréteges architektúra</strong></span> (<span class="strong"><strong>three-layer architecture</strong></span>), amely egy reaktív, egy végrehajtó és egy modellező rétegből áll.</p><p>A <span class="strong"><strong>reaktív réteg</strong></span> (<span class="strong"><strong>reactive layer</strong></span>) alacsony szintű vezérlést biztosít a robot számára. Ezt egy szoros szenzorcselekvés-hurok jellemzi. Döntési ciklusa gyakran milliszekundum nagyságrendű.</p><p>A <span class="strong"><strong>végrehajtó</strong></span> vagy <span class="strong"><strong>szekvenciális réteg</strong></span> (<span class="strong"><strong>executive/sequencing layer</strong></span>) kapcsolja össze a reaktív réteget a modellezővel. Direktívákat fogad a modellező rétegtől, és egymás után továbbítja azokat a reaktív réteg számára. A végrehajtó réteg kezelheti például a modellező réteg pályatervező algoritmusa által generált útvonalpontokat, és eldönti, hogy melyik reaktív viselkedést hívja meg. A döntési idő a végrehajtó réteg esetében átlagosan másodperc nagyságrendű. Ez a réteg felelős továbbá azért is, hogy a szenzoros információkat egy belsőállapot-reprezentációba integráljuk. Kezeli például a robot lokalizációs és online térképezési rutinjait.</p><p>A <span class="strong"><strong>modellező réteg</strong></span> (<span class="strong"><strong>deliberate layer</strong></span>) a beépített tudással komplex feladatokra globális megoldásokat generál, tervezéssel. A bonyolult feladatok nagy számítási igénye miatt a döntési ciklusidő perc nagyságrendű is lehet. A modellező vagy tervező rétegmodelleket használ a döntések meghozásához. Ezek a modellek lehetnek előzetesen betápláltak vagy adatokból tanulás útján létrejöttek, és általában a végrehajtó modell által gyűjtött állapotinformációt használják.</p><p>A háromrétegű architektúra különböző változatait találhatjuk meg a legtöbb mai robot szoftverrendszerében. A három rétegre való bontás nem kötelező. Egyes robotszoftverrendszerek további rétegeket is tartalmaznak, például felhasználói interfész réteget – az emberekkel való kommunikálás vezérlésére –, vagy olyan rétegeket, amelyek a cselekvésnek a többi, ugyanabban a környezetben tevékenykedő robottal való összehangolásáért felelősek.</p></div><div class="section" title="Robotprogramozási nyelvek"><div class="titlepage"><div><div><h2 class="title"><a id="id794370"/>Robotprogramozási nyelvek</h2></div></div></div><p>Sok robotvezérlőnek megvan a saját külön programozási nyelve. Például az alárendelt architektúra sok programja a Brooks (Brooks, 1990) által megalkotott <span class="strong"><strong>viselkedési nyelv</strong></span>et (<span class="strong"><strong>behavior language</strong></span>) alkalmazza. Ez egy szabályalapú, valós idejű nyelv AFSM vezérlésekhez. A LISP-hez hasonló szintaxisú, egyedi szabályokat fordít AFSM-ekra, valamint több AFSM lokális és globális üzenetküldő mechanizmussal van integrálva.</p><p>Csakúgy, mint az alárendelt architektúra, a viselkedési nyelv is csak egyetlen AFSM-re képes fókuszálni, és relatív alacsony szintű kommunikációt enged meg az egységek között. Az újabb kutatások erre az ötletre építve olyan nyelvek sorát fejlesztették ki, amelyek alapvetően hasonlítanak a viselkedési nyelvre, de nagyobb teljesítményűek, és gyorsabban futnak. Ilyen nyelv például az <span class="strong"><strong>általános robot nyelv</strong></span> (<span class="strong"><strong>generic robot language,</strong></span> <span class="strong"><strong>GRL</strong></span>), amely Horswill (Horswill, 2000) nevéhez fűződik. A GRL egy funkcionális programozási nyelv nagyméretű moduláris irányítási rendszerekhez. Ugyanúgy, mint a viselkedési nyelv, a GRL is véges automatákból építkezik. Ezenfelül sokkal nagyobb lehetőséget hagy a különböző modulok közötti kommunikációs formák és szinkronizációs lehetőségek definiálására. A GRL-programok hatékony imperatív nyelvekre fordítódnak le, mint amilyen például a C.</p><p>Egy másik fontos, modern programozási nyelv (és hozzá tartozó architektúra) a Firby (Firby, 1994) által megalkotott reaktív akciótervrendszer (reactive action plan system, RAPS). A RAPS lehetővé teszi, hogy a programozók célokat és ezekhez tartozó terveket (vagy részleges stratégiákat) definiáljanak, valamint feltételeket, amelyek esetén az adott terv nagy valószínűséggel sikeres lesz. Ami nagyon fontos, hogy a RAPS lehetőséget ad az esetleges <span class="emphasis"><em>kudarc</em></span> kezelésére is, ami szükségszerű velejárója a valódi robotikai rendszereknek. A programozó számos érzékelő rutint specifikálhat a különböző típusú kudarcok esetére, és mindegyikhez definiálhat egy kivételkezelési rutint. Háromrétegű architektúráknál gyakran használják a RAPS-ot a végrehajtó rétegben, az újratervezést nem igénylő kis eltérések, váratlan események kezelésére.</p><p>Számos más nyelv létezik, amely lehetővé teszi a robot számára, hogy mérlegeljen és tanuljon. Ilyen például a <code class="code">GOLOG</code> (Levesque és társai, 1997b), amely akadályok nélkül egyesíti a modellalapú problémamegoldást (tervezést) és a reaktív irányítás közvetlen megvalósítását. A <code class="code">GOLOG</code>-programok szituációkalkulus (10.3. alfejezet) formájában jutnak kifejezésre, nemdeterminisztikus mozgásoperátorok hozzáadásának a lehetőségével. Ha a vezérlőprogramban nemdeterminisztikus mozgások is specifikáltak, a programozónak teljes modellt kell szolgáltatnia a robotról és környezetéről. Amikor a vezérlőprogram egy nemdeterminisztikus választási lehetőséghez ér, egy tervező algoritmust hív meg (szabálykészítő formában), hogy az meghatározza a következő lépést. Ilyen módon a programozó részleges vezérlőket ír, és a végső irányítási döntéshozást a beépített mechanizmusra bízza. A <code class="code">GOLOG</code> szépsége a modellalapú és a reaktív vezérlés probléma nélküli összeillesztésében van. Annak ellenére, hogy a <code class="code">GOLOG</code> alkalmazásának több feltétele van (teljes megfigyelhetőség, diszkrét állapotok, teljes modell), sok beltéri robot számára nyújt megfelelő, magas szintű irányítást.</p><p>A <span class="strong"><strong>CES</strong></span>, C++ beágyazott rendszerekhez (C++ for embedded systems), a C++ nyelv kiterjesztése, amely már valószínűségeket és tanulást is tartalmaz (Thrun, 2000). A CES adattípusai valószínűségi eloszlások, amelyek a programozó számára lehetővé teszik a bizonytalan információk kezelését a korábbi nehézségek nélkül. Ami még fontosabb, hogy a CES lehetőséget nyújt a robot szoftverpéldákkal való tanítására, nagyon hasonlóan a 20. fejezetben tárgyalt tanulási algoritmusokhoz. Ennek kihasználásával a programozók hagyhatnak helyet a programban a később megtanulható függvények számára – ezek tipikusan differenciálható parametrikus reprezentációk, mint például a neurális hálók. Ezeket a függvényeket a külön tanulási fázisban tanulja meg a rendszer, ahol a tanító határozza meg a kívánt kimeneti viselkedést. A CES sikeresnek bizonyult részlegesen megfigyelhető és folytonos esetekben is.</p><p>Az <span class="strong"><strong>ALisp</strong></span> (Andre és Russell, 2002) a LISP továbbfejlesztett változata. Az Alisp lehetővé tesz nemdeterminisztikus döntési pontok megadását, hasonlóan a <code class="code">GOLOG</code> döntési pontjaihoz. De ahelyett, hogy a tételbizonyítóra bízná a döntést, az ALisp induktív módon, megerősítéses tanulással megtanulja a helyes cselekvést. Az ALisp-ot rugalmas eszköznek tekinthetjük a tárgytartományról szóló – főleg a megfelelő döntések szubrutinjainak hierarchikus szerkezetére vonatkozó – tudásnak megerősítéses tanulással tanuló rendszerbe való beépítésére. Eddig csak szimulációk során alkalmazták az ALisp-ot, de nagyon ígéretes módszernek tűnik olyan robotok építéséhez, amelyek tanulnak a környezetükkel való kölcsönhatásból.</p></div></div></body></html>
