<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id548868"/>Összefoglalás</h1></div></div></div><p>Ez a fejezet olyan módszereket ismertetett, amelyekkel az ágens a cselekvéseit választhatja meg determinisztikus, megfigyelhető, statikus és teljesen ismert környezetben. Ilyen esetekben az ágens olyan cselekvéssorozatokat konstruálhat, amelyekkel a céljait elérheti. Ezt a folyamatot <span class="strong"><strong>keresés</strong></span>nek (<span class="strong"><strong>search</strong></span>) nevezzük.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">A megoldás keresésének megkezdése előtt az ágensnek előbb meg kell fogalmaznia a <span class="strong"><strong>cél</strong></span>t (<span class="strong"><strong>goal</strong></span>), majd a célt fel kell használnia a <span class="strong"><strong>probléma</strong></span> megfogalmazására.</p></li><li class="listitem"><p class="List Paragraph">Egy <span class="strong"><strong>probléma</strong></span> (<span class="strong"><strong>problem</strong></span>) négy részből: a <span class="strong"><strong>kiinduló állapot</strong></span>ból (<span class="strong"><strong>initial state</strong></span>), egy <span class="strong"><strong>cselekvés</strong></span>- (<span class="strong"><strong>action</strong></span>) készletből, egy <span class="strong"><strong>célteszt</strong></span>- (<span class="strong"><strong>goal test</strong></span>) függvényből és egy <span class="strong"><strong>útkölt</strong></span><span class="strong"><strong>ség</strong></span>- (<span class="strong"><strong>path cost</strong></span>) függvényből áll. A probléma környezetét az <span class="strong"><strong>állapottér</strong></span> (<span class="strong"><strong>state spac</strong></span><span class="strong"><strong>e</strong></span>) írja le. Az állapottérben a kiinduló állapotból a célállapotba vezető <span class="strong"><strong>út</strong></span> (<span class="strong"><strong>path</strong></span>) a probléma egy<span class="strong"><strong> megoldás</strong></span>a (<span class="strong"><strong>solution</strong></span>).</p></li><li class="listitem"><p class="List Paragraph">Egyetlen általános <code class="code">FA-KERESÉS</code> algoritmus felhasználható bármilyen probléma megoldására. Az algoritmus konkrét változatai eltérő stratégiákat valósítanak meg.</p></li><li class="listitem"><p class="List Paragraph">A keresési algoritmusokat azok <span class="strong"><strong>teljesség</strong></span>e (<span class="strong"><strong>completeness</strong></span>), <span class="strong"><strong>optimalitás</strong></span>a (<span class="strong"><strong>optimality</strong></span>), <span class="strong"><strong>időigény</strong></span>e (<span class="strong"><strong>time complexity</strong></span>) és <span class="strong"><strong>tárigény</strong></span>e (<span class="strong"><strong>space complexity</strong></span>) alapján értékeljük. A komplexitást a probléma <span class="emphasis"><em>b</em></span> elágazási tényezője és a legsekélyebben fekvő megoldás <span class="emphasis"><em>d</em></span> mélysége határozza meg.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>szélességi keresés</strong></span> (<span class="strong"><strong>breadth-first search</strong></span>) először a legsekélyebben fekvő csomópontot fejti ki a keresési fában. Ez a keresés teljes, azonos költségű operátorok esetén optimális és <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>d</sup></em></span>) idő- és tárigénnyel rendelkezik. Tárigénye miatt a legtöbb esetben nem célszerű alkalmazni. Az <span class="strong"><strong>egyenletes költségű keresés</strong></span> (<span class="strong"><strong>uniform-cost search</strong></span>) hasonló a szélességi kereséshez, de először a legkisebb <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>) útköltségű csomópontot fejti ki. Teljes és optimális, ha minden lépés költsége valamilyen pozitív ε korlátnál nagyobb.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>mélységi keresés</strong></span> (<span class="strong"><strong>depth-first search</strong></span>) először a keresési fa legmélyebben fekvő csomópontját fejti ki. Se nem teljes, se nem optimális, és időigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>m</sup></em></span>), tárigénye pedig <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bm</em></span>), ahol <span class="emphasis"><em>m</em></span> az állapottérbeli utak maximális mélysége.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>mélységkorlátozott keresés</strong></span> (<span class="strong"><strong>depth-limited search</strong></span>) egy korlátot ad a mélységi keresés keresési mélységére.</p></li><li class="listitem"><p class="List Paragraph">Az <span class="strong"><strong>iteratívan mélyülő keresés</strong></span> (<span class="strong"><strong>iterative deepening search</strong></span>) a cél megtalálásáig egyre növekvő mélységkorláttal hívja meg a mélységkorlátozott keresést. Teljes és egységnyi lépésköltség esetén optimális, időigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>d</sup></em></span>), tárigénye pedig <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bd</em></span>).</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>kétirányú keresés</strong></span> (<span class="strong"><strong>bidirectional search</strong></span>) radikálisan csökkentheti az időigényt, de nem mindig alkalmazható, és a tárigénye túl nagy lehet.</p></li><li class="listitem"><p class="List Paragraph">Ha az állapotér inkább egy gráf, mint egy fa, kifizetődő lehet az ismétlődő állapotokat megvizsgálni. A <code class="code">GRÁF-KERESÉS</code> algoritmus az összes duplikált állapotot kiküszöböli.</p></li><li class="listitem"><p class="List Paragraph">Ha a környezet csak részben megfigyelhető, az ágens a keresési algoritmust a <span class="strong"><strong>hiedelmi állapot</strong></span>ok (<span class="strong"><strong>belief state</strong></span>s) terében alkalmazhatja, vagyis olyan lehetséges állapotok terében, amelyekben az ágens tartózkodhat. Egyes esetekben egyetlen megoldási szekvencia konstruálható, más esetekben az ágensnek <span class="strong"><strong>eshetőségi terv</strong></span>re (<span class="strong"><strong>contingency plan</strong></span>) van szüksége, hogy a felmerülő ismeretlen helyzetekkel megbirkózzon.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id549226"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>Az ebben a fejezetben elemzett állapottér-keresési problémák többségének hosszú története van az irodalomban, és e problémák sokkal kevésbé triviálisak, mint azt első ránézésre gondolnánk. A 3.9. feladatban említett hittérítők és kannibálok problémáját Amarel elemezte részletesen (Amarel, 1968). A mesterséges intelligencia területén Simon és Newell (Simon és Newell, 1961), míg a számítástudomány és az operációkutatás területén Bellman és Dreyfus már korábban foglalkoztak e problémával (Bellman és Dreyfus, 1962). Az ilyen tanulmányok és Simon és Newell Logic Theoristra vonatkozó munkája (Simon és Newell, 1957), valamint a GPS (Simon és Newell, 1962) hatására váltak a keresési algoritmusok az 1960-as években az MI-kutatók fegyvertárának elsődleges eszközeivé, illetve ezek hatására vált a problémamegoldás kanonikus MI-feladattá. Sajnos eddig nagyon kevés történt a problémamegfogalmazás lépéseinek automatizálása irányában. A problémareprezentáció és -absztrakció frissebb tárgyalását Knoblock adta meg (Knoblock, 1990), beleértve olyan MI-programok leírását is, amelyek (részben) maguk végzik el ezeket a feladatokat. </p><p>A 8-as kirakójáték a bonyolultabb 15-ös kirakójáték kisebb rokona, amit a híres amerikai játéktervező, Sam Loyd talált ki az 1870-es években (Loyd, 1959). A játék akkoriban gyorsan óriási, Rubik bűvös kockájához mérhető népszerűségre tett szert Amerikában. A matematikusok is felfigyeltek a problémára (Johnson és Story, 1879; Tait, 1880). Az <span class="emphasis"><em>American Journal of Mathematics</em></span> szerkesztői megállapították: „A 15-ös kirakójáték az elmúlt hetekben teljesen lebilincselte az amerikai embereket – 10 emberből 9 nemre, korra és származásra való tekintet nélkül a játék bűvöletébe került. Ez azonban még nem hatott volna a szerkesztőkre olyan mértékben, hogy rávegye őket, erről a témáról cikkeket jelentessenek meg az <span class="emphasis"><em>American Journal of Mathematics</em></span> folyóiratban, de figyelembe véve azt a tényt, hogy…” (itt a 15-ös kirakójáték által felvetett érdekes matematikai kérdések rövid taglalása következett). A 8-as játék esetén P. D. A. Schofield számítógép segítségével elvégezte a probléma kimerítő elemzését (Schofield, 1967). Ratner és Warmuth megmutatta, hogy a legrövidebb megoldás megkeresése a 15-ös játék <span class="emphasis"><em>n </em></span>× <span class="emphasis"><em>n</em></span>-es általánosításánál az NP-teljes problémák osztályába tartozik (Ratner és Warmuth, 1986).</p><p>A 8-királynő problémát először 1848-ban a <span class="emphasis"><em>Schach</em></span> német sakkszaklapban névtelenül publikálták, később a problémát Max Bezzel nevéhez kapcsolták. A problémát 1850-ben újra publikálták, ami akkor felkeltette a kiváló matematikus, Karl Friedrich Gauss figyelmét, aki megkísérelte felsorolni az összes megoldást, azonban csak 72 megoldást talált meg. Az összes, 92 megoldást Nauck publikálta 1850-ben. A problémát Netto <span class="emphasis"><em>n </em></span>királynő esetére általánosította (Netto, 1901), Abramson és Young pedig találtak egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) algoritmust (Abramson és Young, 1989).</p><p>A fejezetben említett valósvilág-beli keresési problémák közül mindegyik komoly kutatási erőfeszítések tárgya volt. Az optimális repülőjárat megválasztásának módszereit általában bizalmasan kezelik, azonban Carl de Marcken kimutatta (magánközlés), hogy a repülőtársaságok által alkalmazott jegytarifák és egyéb korlátozások annyira összekuszálódtak, hogy az optimális járat megválasztása formálisan <span class="emphasis"><em>eldönthetetlen</em></span>. Az elméleti számítástudományban standard kombinatorikus probléma az utazó ügynök problémája (TSP) (Lawler, 1985; Lawler és társai, 1992). A problémáról Karp bizonyította be, hogy NP-nehéz (Karp, 1972), azonban megoldására hatékony heurisztikus közelítő módszereket dolgoztak ki (Lin és Kernighan, 1973). Az euklideszi térben zajló TSP-re Arora dolgozta ki a teljesen polinomiális közelítő sémát (Arora, 1998). A VLSI-elrendezés módszereit Shahookar és Mazumder (Shahookar és Mazumder, 1991) tekintették át, számos optimalizációs cikk VLSI-újságokban jelent meg. Robotnavigálási és szerelési problémákkal a 25. fejezet foglalkozik.</p><p>A problémamegoldás nem informált keresési algoritmusai központi szerepet töltenek be a klasszikus számításelméletben (Horowitz és Sahni, 1978), az operációkutatásban (Dreyfus, 1969). Deo és Pang, továbbá Gallo és Pallottino egy frissebb áttekintést adnak erről a területről (Deo és Pang, 1984; Gallo és Pallottino, 1988). A szélességi keresést labirintusok megoldására Moore (Moore, 1959) fogalmazta meg. A <span class="strong"><strong>dinamikus programozás</strong></span> (<span class="strong"><strong>dynamic programming</strong></span>) módszere (Bellman és Dreyfus, 1962), amely szisztematikusan jegyzi meg az összes növekvő nagyságú részprobléma megoldását, egy gráfokon futó szélességi keresésnek tekinthető. A Dijkstra-féle kétpontos legrövidebb út algoritmus (Dijkstra, 1959) az egyenletes költségű keresés kiindulópontja. </p><p>Az iteratívan mélyülő algoritmus egy változatát Slate és Atkin használta először a <code class="code">CHESS</code> 4.5 sakkprogramjában (Slate és Atkin, 1977), hogy a sakkórát hatékonyabban lehessen használni. De az ötletet gráfokban a legrövidebb út keresésére először Korf használta (Korf, 1985a). A Pohl bevezette kétirányú keresés (Pohl, 1969; 1971) bizonyos esetekben szintén igen hatékony lehet.</p><p>A részben megfigyelhető és a nemdeterminisztikus környezeteket a problémamegoldási megközelítésen belül nem tanulmányozták behatóan. A hiedelmi állapotok terében történő keresés bizonyos hatékonysági problémáival Genesereth és Nourbakhsh foglalkoztak (Genesereth és Nourbakhsh, 1993). Koenig és Simmons (Koenig és Simmons, 1998) az ismeretlen kezdeti pozícióból induló robotnavigálást tanulmányozták. Erdmann és Mason (Erdmann és Mason, 1988) pedig a szenzorok nélküli robot manipuláció problémáját vizsgálták a hiedelem állapottérbeli keresés folytonos változatát használva. Eshetőségi kereséssel a tervkészítés területen belül foglalkoztak (lásd 12. fejezet). A bizonytalan információt felhasználó tervkészítést és cselekvést a valószínűség-elmélet és döntéselmélet eszköztárával oldották meg (lásd 17. fejezet).</p><p>Nilsson könyvei a klasszikus keresési algoritmusokkal kapcsolatban hasznos információkat tartalmaznak (Nilsson, 1971; 1980). Korf egy átfogó, naprakészebb áttekintést ad a klasszikus keresési algoritmusokról (Korf, 1988). Az új keresési algoritmusokról – amelyek feltárása figyelemre méltó módon folytatódik – olyan folyóiratokban jelennek meg cikkek, mint például az <span class="emphasis"><em>Artificial Intelligence</em></span>.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id549298"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>3.1.</strong></span></p><p>Definiálja saját szavaival a következő fogalmakat: állapot, állapottér, keresési fa, keresési csomópont, cél, cselekvés, állapotátmenet-függvény és elágazási tényező.</p><p><span class="strong"><strong>3.2.</strong></span></p><p>Magyarázza meg, hogy a problémamegfogalmazásnak miért kell a célmegfogalmazást követnie.</p><p><span class="strong"><strong>3.3.</strong></span></p><p>Tegyük fel, hogy a <code class="code">LEGÁLIS-CSELEKVÉS</code>(<span class="emphasis"><em>s</em></span>) azon cselekvések halmazát jelöli, amelyek legálisak az <span class="emphasis"><em>s</em></span> állapotban, és az <code class="code">EREDMÉNY</code>(<span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>s</em></span>) pedig azt az állapotot, ami az <span class="emphasis"><em>s</em></span> állapotban a végrehajtott legális cselekvés eredménye. Definiálja az <code class="code">ÁLLAPOTÁTMENET-FV</code>-t a <code class="code">LEGÁLIS-CSELEKVÉS</code> és az <code class="code">EREDMÉNY</code> függvényében, és <span class="emphasis"><em>megfordítva</em></span>.</p><p><span class="strong"><strong>3.4.</strong></span></p><p>Mutassa meg, hogy a 8-as játék állapottere két diszjunkt részből áll, ahol egyik részhez tartozó állapotot semmilyen véges lépésszekvenciával sem lehet a másik részhez tartozó állapotba áttranszformálni. (<span class="emphasis"><em>Segítség: </em></span>Berlekamp és társai, 1982). Dolgozzon ki egy eljárást, amely el tudja dönteni, hogy az állapot melyik részhez tartozik, és magyarázza meg, hogy ez miért hasznos, ha az állapotokat véletlen módon generáljuk.</p><p><span class="strong"><strong>3.5.</strong></span></p><p>Gondolja át az <span class="emphasis"><em>n</em></span>-királynő problémát a <a class="xref" href="ch03s02.md#ID_105_oldal">„Játékproblémák”</a> részben ismertetett „hatékony” inkrementális megfogalmazást felhasználva. Magyarázza meg, hogy az állapottér mérete miért lesz legalább<span class="inlinemediaobject"><img src="kepek/03-03ma.png" alt="Feladatok"/></span>és becsülje meg azt a legnagyobb <span class="emphasis"><em>n</em></span>-et, amire a kimerítő feltárás még elfogadható. (<span class="emphasis"><em>Segítség</em></span>: számolja ki az elágazási tényező alsó korlátját figyelembe véve, hogy mekkora a királynő által támadható sakktáblahelyek maximális száma egy tetszőleges oszlopban.)</p><p><span class="strong"><strong>3.6.</strong></span></p><p>Egy véges állapottér mindig véges keresési fához vezet-e? Mi a helyzet egy olyan véges állapottérrel, amely maga is egy fa? Meg tudja-e precízebben fogalmazni, hogy milyen állapottérfajták vezetnek mindig véges keresési fákhoz? Átvéve (Bender, 1996)-ből.</p><p><span class="strong"><strong>3.7.</strong></span></p><p>Az alábbiak mindegyikéhez adja meg a kiinduló állapotot, a céltesztet, az állapotátmenet-függvényt és az útköltségfüggvényt. Válasszon meg egy olyan megfogalmazást, amely elegendően precíz, hogy azt implementálni lehessen.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Négy szín felhasználásával ki kell színeznie egy síkbeli térképet úgy, hogy minden szomszédos tartomány különböző színű legyen.</p></li><li class="listitem"><p>Egy 1 m magas majom egy szobában tartózkodik, ahol van két 1 m magas láda (amelyeket egymásra lehet rakni, lehet mozgatni, és meg lehet mászni), és néhány banán lóg a 2,5 m magas mennyezetről. A majom el szeretné érni a banánt.</p></li><li class="listitem"><p>Van egy olyan programja, amely „illegális input rekord” üzenetet ad, ha az input rekordok egy bizonyos állományát dolgozza fel. Ön tudja, hogy egy-egy rekord feldolgozása a többitől független. Szeretné az illegális rekordot megtalálni.</p></li><li class="listitem"><p>Van három kancsója, egy 12 l-es, egy 8 l-es és egy 3 l-es és egy vízcsapja. A kancsókat megtöltheti, kiöntheti belőlük a vizet a földre, vagy az egyikből áttöltheti a vizet egy másikba. Pontosan 1 l vizet kell kimérnie.</p></li></ol></div><p><span class="strong"><strong>3.8.</strong></span></p><p>Tekintsen egy olyan állapotteret, ahol a kezdő állapot az 1-es számú és az állapotátmenet-függvény az <span class="emphasis"><em>n </em></span>sorszámú állapotra két állapottal, a 2<span class="emphasis"><em>n</em></span> és a 2<span class="emphasis"><em>n </em></span>+ 1 sorszámú állapotokkal tér vissza.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Rajzolja fel az állapottérnek az 1-es állapottól a 15-es állapotig terjedő részét.</p></li><li class="listitem"><p>Tételezze fel, hogy a célállapot a 11-es. Listázza ki a csomópontok kifejtési sorrendjét szélességi, 3-as mélységkorláttal rendelkező mélységkorlátos és iteratívan mélyülő keresés esetén.</p></li><li class="listitem"><p>Jó lenne-e a probléma megoldására a kétirányú keresés? Ha igen, magyarázza meg részletesen, hogyan fog ez működni.</p></li><li class="listitem"><p>Mennyi a kétirányú keresés elágazási tényezője mindkét irányban?</p></li><li class="listitem"><p>Vajon a (c) pontra adott válasz azt sugallja-e, hogy a problémának lehetséges olyan átfogalmazása, hogy az 1-es állapotból egy adott célállapothoz majdnem keresés nélkül el tudnánk jutni?</p></li></ol></div><p><span class="strong"><strong>3.9.</strong></span></p><div class="informalexample"><p>A hittérítők és kannibálok problémáját általában az alábbi módon szokás megadni. Három hittérítő és három kannibál egy folyó azonos oldalán tartózkodik. Rendelkeznek csónakkal, amely egy vagy két embert bír el. Találjuk meg annak a módját, hogy mindenkit a folyó másik oldalára átjuttassunk, arra ügyelve, hogy a hittérítők soha, sehol ne legyenek kisebbségben a kannibálokkal szemben. Ez a probléma híres az MI-ben, mert ez volt témája az első olyan publikációnak, ahol a problémamegfogalmazást analitikus szemszögből kísérelték meg (Amarel, 1968). </p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Fogalmazza meg precízen a problémát. Csak azokat a megkülönböztetéseket tegye meg, amelyek a helyes megoldás érdekében szükségesek. Rajzolja fel a teljes állapottér diagramját.</p></li><li class="listitem"><p>Implementálja és oldja meg optimális módon a problémát, megfelelő keresési algoritmust választva. Jó ötlet-e az ismétlődő állapotok ellenőrzése?</p></li><li class="listitem"><p>Véleménye szerint miért nehéz e feladvány az emberek számára, annak ellenére, hogy az állapottér ilyen egyszerű?</p></li></ol></div><p><span class="strong"><strong>3.10.</strong></span></p><div class="informalexample"><p>Implementálja az állapotátmenet-függvény két változatát a 8-as játék számára. Az egyik az összes követőt egyszerre generálja a 8-as játék adatstruktúrájának másolásával és editálásával. A másik hívásakor, csak egy követőt generál, a szülő állapot közvetlen módosításával (és szükség esetén a módosítások visszaállításával). Írja meg az iteratívan mélyülő keresés olyan változatait, amelyek a függvény fenti változatait használják, és hasonlítsa össze a megoldások hatékonyságát. </p></div><p><span class="strong"><strong>3.11.</strong></span></p><div class="informalexample"><p>A <a class="xref" href="ch03s04.md#ID_119_oldal">„Iteratívan mélyülő mélységi keresés”</a> részben az <span class="strong"><strong>iteratívan megnyúló keresés</strong></span>t (<span class="strong"><strong>iterative lengthening search</strong></span>) említettük, amely az egyenletes költségű keresés iteratív változata. Az ötlet az útköltségre vonatkozó növekvő korlát használata. Egy újonnan generált csomópontot eldobunk, ha az útköltsége a korlátnál nagyobb. A következő iterációban a korlátot az előző iterációban eldobott csomópontok közül a legkisebb útköltségre állítjuk be. </p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Mutassa meg, hogy ez az algoritmus általános útköltségek esetén optimális.</p></li><li class="listitem"><p>Tekintsen egy homogén fát <span class="emphasis"><em>b</em></span> elágazási tényezővel, <span class="emphasis"><em>d</em></span> megoldásmélységgel és egységnyi lépésköltséggel. Hány iterációra lesz szüksége az iteratívan megnyúló keresésnek?</p></li><li class="listitem"><p>Most tekintsen egy olyan lépésköltséget, amit a [0, 1] folytonos tartományból sorsolnak, egy minimális pozitív ε költséggel. Hány iterációra lesz szükség a legrosszabb esetben?</p></li><li class="listitem"><p>Implementálja az algoritmust és alkalmazza a 8-as játék és az utazó ügynök probléma konkrét eseteire. Hasonlítsa össze az algoritmus hatékonyságát az egyenletes költségű algoritmus hatékonyságával, és értelmezze az eredményeit.</p></li></ol></div><p><span class="strong"><strong>3.12.</strong></span></p><p>Bizonyítsa be, hogy az egyenletes költségű keresés és a szélességi keresés konstans lépésköltség mellett optimálisak, ha azokat a <code class="code">GRÁF-KERESÉS</code> algoritmusával együtt alkalmazzuk. Mutasson egy olyan állapotteret változó lépésköltséggel, ahol a <code class="code">GRÁF-KERESÉS</code> algoritmus, iteratív mélyülést használva, csak egy szuboptimális megoldást talál.</p><p><span class="strong"><strong>3.13.</strong></span></p><p>Adjon meg egy olyan keresési teret, amelyben az iteratívan mélyülő keresési algoritmus a mélységi keresésnél lényegesen rosszabb teljesítményt nyújt (például <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) az <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>)-nel szemben).</p><p><span class="strong"><strong>3.14.</strong></span></p><div class="informalexample"><p>Írjon egy olyan programot, amely bementként két weblap URL-jét kapja meg, és megoldásul megtalálja az azokat összekapcsoló hivatkozási utat (linkeket). Mi a megfelelő keresési stratégia? Jó ötlet-e a kétirányú keresés? Alkalmazható-e egy keresőgép az elődcsomópont függvény megvalósítására? </p></div><p><span class="strong"><strong>3.15.</strong></span></p><div class="informalexample"><p>Gondolja végig egy sík két pontja közötti legrövidebb út megtalálásának a problémáját, ha a síkon konvex sokszög akadályok találhatók (lásd 3.22. ábra). Ez annak a problémának egy idealizált változata, amivel egy robotnak kell szembesülnie, amikor egy zsúfolt környezetben kell navigálnia. </p></div><div class="figure"><a id="id549610"/><p class="title"><strong>3.22. ábra - Egy elrendezés sokszögakadályokkal</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-22.png" alt="Egy elrendezés sokszögakadályokkal"/></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Tegyük fel, hogy az állapottér a sík összes (x, y) pozíciójából áll. Hány állapotról beszélhetünk ekkor? Hány út vezet a célig?</p></li><li class="listitem"><p class="List Paragraph">Magyarázza el röviden, hogy egy sokszög csúcsát egy másikkal a síkban összekötő legrövidebb útnak miért kell olyan egyenes vonalszakaszokból állnia, amelyek az egyes sokszögek csúcsait kapcsolják össze? Adjon most egy jó állapottér definíciót. Milyen nagy ez a tér?</p></li><li class="listitem"><p class="List Paragraph">Definiálja a keresési probléma implementálásához szükséges függvényeket, beleértve az állapotátmenet-függvényt, amely bemenetként egy csúcsot kap, és a belőle egyenes vonalban elérhető csúcsok halmazát adja vissza (ne felejtsük ki a szomszédos csúcsokat ugyanazon a sokszögön sem). Heurisztikus függvénynek az egyenes vonalbeli távolságot használja.</p></li><li class="listitem"><p class="List Paragraph">Alkalmazzon a fejezetben ismertetett algoritmusok közül egyet vagy többet a tárgyterülethez tartozó problémák megoldására, és értékelje azok teljesítményét.</p></li></ol></div><p><span class="strong"><strong>3.16.</strong></span></p><div class="informalexample"><p>A 3.15. feladat navigációs problémáját a következőképpen transzformálja át egy környezetbe: </p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az érzékelés az ágens által látható sokszögcsúcsok az ágenshez viszonyított helyzetének listája. Az érzékelés a robot pozícióját nem tartalmazza! A robotnak a saját pozícióját a térkép alapján kell megtanulnia. Azt is tételezzük fel ideiglenesen, hogy minden lokációnak eltérő a „panorámája”.</p></li><li class="listitem"><p class="List Paragraph">Minden cselekvés egy a követendő egyenes utat leíró vektor lesz. Ha az úton nincsenek akadályok, a cselekvés sikeres. Egyébként a robot azon a ponton megáll, ahol az út az első akadályt metszi. Ha az ágens a zérus mozgás vektorát adja vissza és a célpozícióban van (ami rögzített és ismert), akkor a környezetnek teleportálnia kell az ágenst egy véletlen lokációba (de nem egy akadályon belülre).</p></li><li class="listitem"><p class="List Paragraph">A hatékonysági mérték 1 pontot kér az ágenstől a megtett távolság minden egységtávjáért és 1000 ponttal díjazza  a cél mindenkori elérését.</p></li></ul></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Implementálja ezt a környezetet és egy erre a környezetre vonatkozó problémamegoldó ágenst. Minden teleportálás után az ágensnek új célt kell megfogalmaznia, beleértve a saját pozíció felfedezését.</p></li><li class="listitem"><p class="List Paragraph">Dokumentálja az ágens teljesítményét (kommentálja az ágens mozgását), és írjon egy jelentést az ágens 100 epizódra vonatkozó teljesítményéről.</p></li><li class="listitem"><p class="List Paragraph">Módosítsa a környezetet úgy, hogy az ágens az esetek 30%-ban ne a szándékolt helyen találja magát (a helyet a látható sokszögcsúcsokból sorsoljuk, ha van ilyen egyáltalán, különben nincs mozgás). Ez a valós robot hibás mozgásának egy durva modellje. Módosítsa ágensét úgy, hogyha az ilyen hibát detektál, derítse ki, hol van, és készítsen tervet, hogy az eredeti pozícióba visszakerülhessen, ahonnan az eredeti tervét folytatja. Emlékezzen arra, hogy néha az eredeti pozícióba való visszatérés is kudarccal végződhet! Mutasson egy olyan ágenst, amely két egymás utáni hibás mozgással is sikeresen megbirkózik, és eléri a célt.</p></li><li class="listitem"><p class="List Paragraph">Most két különböző visszaállítási sémával kísérletezzen egy hiba megtörténte után: (1) induljon az eredeti út legközelebb eső csúcsa felé, és (2) tervezze át az utat a cél felé az új pozícióból kiindulva. Hasonlítsa össze a három visszaállítási séma teljesítményét. Meg fogja-e változtatni az összehasonlítás eredményét a keresési költségek figyelembevétele?</p></li><li class="listitem"><p class="List Paragraph">Most tételezze fel, hogy vannak lokációk azonos „panorámával” (tételezzük fel például, hogy a világ egy négyzetrács négyzetes akadályokkal). Milyen problémákkal kell most az ágensnek szembenéznie? Milyenek most a megoldások?</p></li></ol></div><p><span class="strong"><strong>3.17.</strong></span></p><p>A <a class="xref" href="ch03.md#ID_100_oldal">„Jól definiált problémák és megoldások”</a> részben azt mondtuk, hogy nem tárgyaljuk a negatív útköltséggel rendelkező problémákat. Ennek a feladatnak a kapcsán részletesebben megvizsgáljuk a kérdést. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Tegyük fel, hogy a cselekvéseknek tetszőlegesen nagy negatív költségük lehet. Magyarázza meg, hogy ez a lehetőség miért kényszerít minden optimális algoritmust a teljes állapottér felkutatására. </p></li><li class="listitem"><p class="List Paragraph">Segíteni fog-e, ha ragaszkodunk ahhoz, hogy a lépésköltség egy negatív c konstansnál nagyobb vagy azzal egyenlő legyen? Mind a fákra, mind a gráfokra gondoljon.</p></li><li class="listitem"><p class="List Paragraph">Tételezzük fel, hogy cselekvések egy halmaza ciklust alkot úgy, hogy a halmaz cselekvéseit valamilyen sorrendben végrehajtva az állapot nem változik. Milyen következményekkel jár egy ilyen környezetben tevékenykedő ágens optimális viselkedésére, ha ezen cselekvések mindegyike negatív költségű?</p></li><li class="listitem"><p class="List Paragraph">Könnyen el tudunk képzelni nagy negatív költségű operátorokat még az útkeresési probléma esetén is. Például néhány útszakasz olyan gyönyörű tájakon halad, hogy az idő és üzemanyag tekintetében messze túlszárnyalja a normál költségeket. Pontos megfogalmazásban magyarázza el, hogy az emberek miért nem kocsikáznak a végtelenségig a szép tájak körül, és hogyan lehetne az útkeresési problémához az állapotteret és az operátorokat definiálni, hogy a mesterséges ágens is el tudja kerülni a ciklusokat.</p></li><li class="listitem"><p class="List Paragraph">Tud olyan valódi problémakört mondani, amelyben a lépések költsége ciklust okoz?</p></li></ol></div><p><span class="strong"><strong>3.18.</strong></span></p><p>Gondoljon a Murphy-törvény uralma alatt álló kétlokációjú, szenzor nélküli porszívóvilágra. Rajzolja fel az {1, 2, 3, 4, 5, 6, 7, 8} kezdeti hiedelmi állapotból elérhető hiedelem-állapotteret, és magyarázza meg, hogy a probléma miért megoldhatatlan. Mutassa meg azt is, hogy ha a világ teljesen megfigyelhető, minden kezdeti állapotból létezik egy megoldási szekvencia.</p><p><span class="strong"><strong>3.19.</strong></span></p><div class="informalexample"><p>Tekintse a 2.2. ábrán látható porszívóvilágot. </p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">A fejezetben ismertetett algoritmusok közül amelyik lenne alkalmas e probléma megoldására? Szükséges-e, hogy az algoritmus ellenőrizze az ismételt állapotokat?</p></li><li class="listitem"><p class="List Paragraph">A 3 × 3 világban alkalmazza a megválasztott algoritmust az optimális cselekvési szekvencia kiszámítására egy olyan kezdeti állapottal, ahol a felső három négyzet mindegyikében található piszok, és az ágens a középső négyzetben tartózkodik.</p></li><li class="listitem"><p class="List Paragraph">Építsen kereső ágenst, és értékelje a teljesítményét egy olyan 3 × 3 porszívóvilág halmaz számára, ahol minden négyzetben 0,2 a kosz valószínűsége. A teljesítmény mérésénél mind az útköltséget, mind a keresési költséget vegye figyelembe, egy értelmes átszámítási tényezőt használva.</p></li><li class="listitem"><p class="List Paragraph">Hasonlítsa össze az eddigi legjobb kereső ágens viselkedését egy olyan egyszerű, randomizált reflexszerű ágensével, amely koszt szív, ha azt megtalálja, különben véletlen módon mozog. </p></li><li class="listitem"><p class="List Paragraph">Értékelje, hogy mi történne, ha a világot n × n-re nagyítanánk. Hogyan változna a kereső és a reflexszerű ágens teljesítménye n növelésével?</p></li></ol></div></div></div></body></html>
