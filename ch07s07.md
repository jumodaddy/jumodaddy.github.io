<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id590883"/>Összefoglalás</h1></div></div></div><p class="2">Bevezettük a tudásbázisú ágens ötletét, és megmutattuk, hogy hogyan tudunk olyan logikát definiálni, amellyel az ágens képes következtetni a világról. A legfontosabb pontok a következők:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az intelligens ágensnek szüksége van tudásra a világról, hogy jó döntéseket hozhasson.</p></li><li class="listitem"><p class="List Paragraph">A tudást az ágens egy <span class="strong"><strong>tudásbázis</strong></span>ban (<span class="strong"><strong>knowledge base</strong></span>) egy <span class="strong"><strong>tudásreprezentációs nyelv</strong></span> (<span class="strong"><strong>knowledge represantion language</strong></span>)<span class="strong"><strong> mondat</strong></span>ainak<span class="strong"><strong> </strong></span>(<span class="strong"><strong>sentence</strong></span>s) formájában tárolja.</p></li><li class="listitem"><p class="List Paragraph">Egy tudásbázisú ágenst a tudásbázis és a következtetési mechanizmus alkotja. Működésének lényege, hogy a tudásbázisában a világot leíró mondatokat tárol és következtetési mechanizmust alkalmaz új mondatok következtetésére, majd felhasználja ezeket cselekvések meghatározására.</p></li><li class="listitem"><p class="List Paragraph">Egy reprezentációs nyelvet <span class="strong"><strong>szintaxis</strong></span>a (<span class="strong"><strong>syntax</strong></span>) és <span class="strong"><strong>szemantiká</strong></span>ja (<span class="strong"><strong>semantics</strong></span>) definiál. A szintaxis a mondatok struktúráját határozza meg, a szemantika a mondatok <span class="strong"><strong>igazság</strong></span>át (<span class="strong"><strong>truth</strong></span>) határozza meg minden lehetséges <span class="strong"><strong>világ</strong></span>ban (<span class="strong"><strong>world</strong></span>) vagy <span class="strong"><strong>modell</strong></span>ben (<span class="strong"><strong>model</strong></span>), </p></li><li class="listitem"><p class="List Paragraph">A mondatok közötti <span class="strong"><strong>vonzat</strong></span> (<span class="strong"><strong>entailment</strong></span>) kapcsolatnak alapvetően fontos szerepe van a következtetés megértésében. Egy <span class="emphasis"><em>α</em></span> mondat maga után vonz egy másik <span class="emphasis"><em>β</em></span> mondatot, ha <span class="emphasis"><em>β </em></span> igaz minden világban, ahol <span class="emphasis"><em>α </em></span>igaz. Ezzel ekvivalens definíciók az <span class="emphasis"><em>α </em></span> ⇒ <span class="emphasis"><em>β </em></span> mondat <span class="strong"><strong>érvényesség</strong></span>ét (<span class="strong"><strong>validity</strong></span>) és a <span class="emphasis"><em>α </em></span>∧ <span class="emphasis"><em>¬β </em></span> mondat <span class="strong"><strong>kielégíthetetlenség</strong></span>ét (<span class="strong"><strong>unsatisfiability</strong></span>) meghatározó definíciók.</p></li><li class="listitem"><p class="List Paragraph">A következtetés az a folyamat, amivel új mondatok vezethetők le régiekből. A <span class="strong"><strong>helyes</strong></span> (<span class="strong"><strong>sound</strong></span>) következtetési algoritmusok <span class="emphasis"><em>csak</em></span> vonzat mondatokat vezetnek le; a <span class="strong"><strong>teljes</strong></span> (<span class="strong"><strong>c</strong></span><span class="strong"><strong>omplete</strong></span>) algoritmus az <span class="emphasis"><em>összes</em></span> következményt levezeti.</p></li><li class="listitem"><p class="List Paragraph">Az <span class="strong"><strong>ítéletkalkulus</strong></span> (<span class="strong"><strong>propositional logic</strong></span>) egy nagyon egyszerű nyelv, amely <span class="strong"><strong>ítélet-</strong></span><span class="strong"><strong>szimbólumok</strong></span>ból (<span class="strong"><strong>proposition symbols</strong></span>) és <span class="strong"><strong>logikai összekötőjel</strong></span>ekből (<span class="strong"><strong>logical connective</strong></span>s) áll. Képes kezelni olyan állításokat, amelyekről tudjuk, hogy igazak, tudjuk, hogy hamisak, vagy teljesen ismeretlen az igazságértékük.</p></li><li class="listitem"><p class="List Paragraph">Ha adott egy ítéletkalkulus szimbólumszótár, akkor a lehetséges modellek száma véges, így a vonzatok ellenőrzése történhet a modellek felsorolásával is. Hatékony ítéletkalkulus <span class="strong"><strong>modellellenőrző</strong></span> (<span class="strong"><strong>model checking</strong></span>) algoritmusok többek között viszszalépéses vagy lokális keresési eljárásokat alkalmaznak, amelyekkel gyakran nagyméretű problémákat is nagyon gyorsan meg tudnak oldani.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>következtetési szabály</strong></span>ok (<span class="strong"><strong>inference rules</strong></span>) helyes következtetési minták, amelyeket felhasználhatunk bizonyítások megtalálásához. A <span class="strong"><strong>rezolúció</strong></span> (<span class="strong"><strong>resolution</strong></span>) szabály teljes következtetési algoritmust biztosít olyan tudásbázisokhoz, amelyek <span class="strong"><strong>konjunktív normál formá</strong></span>ban (<span class="strong"><strong>conjunctive normal form</strong></span>) vannak kifejezve. Az <span class="strong"><strong>előrefelé láncolás</strong></span> (<span class="strong"><strong>forward chaining</strong></span>) és a <span class="strong"><strong>hátrafelé láncolás</strong></span> (<span class="strong"><strong>backward chaining</strong></span>) igen természetes érvelési algoritmusok <span class="strong"><strong>Horn-formá</strong></span>ban (<span class="strong"><strong>Horn form</strong></span>) adott tudásbázisokon.</p></li><li class="listitem"><p class="List Paragraph">Kétfajta ágenst lehet építeni az ítéletkalkulus alkalmazására: a <span class="strong"><strong>következtetésalapú ágens</strong></span> (<span class="strong"><strong>inference-based agent</strong></span>) következtetési algoritmusokat használ a világ eseményeinek követésére, és képes rejtett jellemzőket is levezetni, míg az <span class="strong"><strong>áramkörön alapuló ágens</strong></span> (<span class="strong"><strong>circuit-based agent</strong></span>) az állításokat regiszterek bitjeiként reprezentálja, és jelek logikai áramkörökben történő terjesztésével végzi ezek frissítését. </p></li><li class="listitem"><p class="List Paragraph">Az ítéletkalkulus meglehetősen hatékony bizonyos feladatokra egy ágensben alkalmazva, de kezelhetetlen nemkorlátos méretű környezetekben, mivel hiányzik a megfelelő kifejező erő az idő, a tér és az objektumok közötti kapcsolatok általános mintáinak leírására.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id591241"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p class="3">John McCarthy cikke a „Programs with Common Sense” (McCarthy, 1958, 1968) tette híressé az ágens fogalmát, egy olyan programét, amely az érzetek és cselekvések összekapcsolására logikai következtetést használ. A cikk kitűzte a deklarativizmus zászlóját, megmutatva, hogy szoftverek írásának igen elegáns módszere az, ha a szükséges ismereteket közöljük az ágenssel. Allen Newell cikke (1982) a „The Knowledge Level” tárgyalja azt a megközelítést, hogy racionális ágensek leírhatók és elemezhetők egy absztrakt szinten, ami az általuk birtokolt tudást és nem azt a programot definiálja, amit futtatnak. A mesterséges intelligencia deklaratív és procedurális megközelítéseit hasonlítja össze Boden (Boden, 1977). A vitát, mások mellett  Brooks (Brooks, 1991) és Nilsson (Nilsson, 1991) írásai élesztették fel újra. </p><p>Magának a logikának az eredete az ősi görög filozófiában és matematikában található. Számos logikai alapelv – a mondatok szintaktikus struktúrájának összekötése az igaz vagy hamis jellegükkel, a jelentésükkel, a bennük megjelenő argumentumok érvényességével – elszórt helyeken megtalálható Platón műveiben. Arisztotelész készítette az első ismert, rendszerezett munkát a logikáról. Munkáját diákjai gyűjtötték össze halála után, i. e. 322-ben az <span class="emphasis"><em>Organon </em></span>c. tanulmányban. Arisztotelész <span class="strong"><strong>szillogizmus</strong></span>ai (<span class="strong"><strong>syllogism</strong></span>s) olyan logikai állítások voltak, amelyeket ma következtetési szabályoknak neveznénk. Habár a szillogizmus tartalmazott elemeket, mind a propozíciós, mind az elsőrendű logikából, a rendszer, mint egész, igen gyengének számít a modern kívánalmak szerint. Nem tette lehetővé tetszőleges komplexitású mondatok létrehozását a következtetési mintákban, mint a modern ítéletlogika. </p><p>A hasonló Megara és sztoikus iskolák (az i. e. 5. században indultak, és több száz éven keresztül működtek) vezették be az implikációt és más alapvető szerkezeteket, amelyeket ma is használunk a modern ítéletlogikában. Logikai összekötőjelek definiálására vezette be az igazságtábla használatát Philón és Megara. A sztoikusok öt alapvető következtetési szabályt használtak, amelyeket igazolás nélkül érvényesnek tartottak, köztük azt a szabályt, amelyet ma Modus Ponensnek nevezzünk. Számos szabályt vezettek le ebből az ötből, felhasználva többek között a dedukció elméletének alapelvét <a class="xref" href="ch07s04.md#ID_267_oldal">„Az ítéletkalkulus következtetési mintái”</a> részben, és sokkal tisztábban használták a bizonyítás fogalmát, mint azt Arisztotelész tette. A sztoikusok azt állították, hogy az ő logikájuk teljes abban az értelemben, hogy tartalmaz minden érvényes következtetést, de ami fennmaradt munkájukból, az túlságosan töredékes ahhoz, hogy elemezhető legyen. A Megara és a sztoikus logikák történetének, már amennyire ezek ismertek, jó beszámolóját készítette el Benson Mates (Mates, 1953).</p><p>Wilhelm Leibniztől (1646–1716) származik a mesterséges formális nyelvi minták létrehozásának ötlete a logikai kapcsolatok tisztázásának és a logikai következtetés egy tisztán formális és mechanikus folyamattá való egyszerűsítése céljából. Leibniz saját matematikai logikája azonban igencsak tökéletlen volt, és rá inkább ezeknek a gondolatoknak mint célkitűzéseknek a bevezetéséért és nem e célok megvalósítására tett kísérletei miatt emlékezünk.</p><p>George Boole vezette be első igazán átfogó és működőképes formális logikai alapú rendszert a <span class="emphasis"><em>The Mathematical Analysis of Logic </em></span>c. könyvében (Boole, 1847). Boole logikájának modellje közel állt a valós számok algebrájáéhoz, és elsődleges következtetési módszerként a logikailag ekvivalens mondatok helyettesítését használta. Bár Boole rendszere csak töredéke volt a teljes ítéletkalkulusnak, elég közel volt ahhoz, hogy a 19. század szerzői Boole-t követve hamar kitöltsék a hiányzó részeket. Schröder definiálta (Schröder, 1877) a konjunktív normál formát, míg a Horn-formát sokkal később Alfred Horn (Horn, 1951) vezette be. A modern ítéletkalkulus (és elsőrendű logika) első átfogó bemutatása Gottlob Frege <span class="emphasis"><em>Begriffschrift</em></span> (Az írás fogalma vagy Fogalmi jelölés) c. könyvében (Frege, 1879) található.</p><p>Az első mechanikai eszközt, amely logikai következtetést végzett, Stanhope harmadik grófja (1753–1816) készítette. A Stanhope Demonstrator képes volt szillogizmusokat kezelni és bizonyos valószínűségi következtetéseket végezni. Wiliam Stanley Jevons – egyike azoknak, akik továbbfejlesztették és kiegészítették Boole munkáját – 1869-ben a Boole-logikán alapuló következtetések végrehajtására megépítette a „logical pianó”-ját. Ezeknek és más korai következtetésre készített mechanikus eszközöknek szórakoztató és tanulságos története Martin Gardner (Gardner, 1968) munkájában olvasható. Az első logikai következtetést végző, publikált számítógépes program a „Logic Theorist” volt, amelyet Newell, Shaw és Simon (Newell, Shaw és Simon, 1957) készítettek. Ezt a programot az emberi gondolkodás modellezésére szánták a szerzők. Bár Martin Davis (Davis, 1957) tervezett egy programot, ami bizonyíthatóan 1954-ben készült, de a Logic Theorist eredményeit korábban publikálták. Mind Davis 1954-es programja, mind a Logic Theorist részben <span class="emphasis"><em>ad hoc</em></span> módszerekre épült, amelyek nem voltak jelentős hatással a későbbi automatikus dedukciós rendszerekre. </p><p>Az igazságtábláknak, mint az ítéletkalkulus nyelvében az érvényességnek vagy a mondat kielégíthetetlenségének a tesztjét egymástól függetlenül Ludwig Wittgenstein (1922) és Emil Post (1921) vezették be. A harmincas években jelentős haladást értek el az elsőrendű logika következtetési módszereinek terén. Nevezetesen, Gödel megmutatta (Gödel, 1930), hogy az elsőrendű logikában történő következtetésre egy teljes eljárást lehet kapni az ítéletlogikára történő redukcióval, felhasználva Herbrand elméletét (Herbrand, 1930). A 9. fejezetben újra áttekintjük ennek történetét, itt most a lényeges pont az, hogy a hatvanas években, a hatékony ítéletkalkulus algoritmusok fejlesztésében a matematikusok érdeklődését jelentős mértékben motiválta az a cél, hogy hatékony tételbizonyítót készítsenek az elsőrendű logika számára. A Davis–Putnam-algoritmus (Davis és Putnam, 1960) volt az első hatásos algoritmus az ítéletkalkulus rezolúció megvalósítására, de a legtöbb esetben ez is sokkal kevésbé hatékony, mint a DPLL visszalépéses algoritmus, amelyet két évvel később mutattak be (1962). A teljes rezolúciós szabály és a rezolúció teljességének bizonyítása J. A. Robinson (Robinson, 1965) nagyhatású tanulmányában jelent meg, ami azt is megmutatta, hogyan lehet elsőrendű logikai következtetést végezni ítéletkalkulus technikák igénybevétele nélkül.</p><p>Stephen Cook (Cook, 1971) mutatta meg, hogy a kielégíthetőség eldöntése az ítéletlogikában NP-teljes. Mivel a vonzat meghatározása ekvivalens a kielégíthetetlenség eldöntésével, ez is NP-teljes. Az ítéletlogika számos részhalmaza ismert, amelyről tudjuk, hogy bennük a kielégíthetőség problémája polinomiális időben megoldható. A Horn-klózok az egyik ilyen rézhalmaz. A Horn-klózokon működő, lineáris időben futó előreláncolási algoritmust Dowlingnak és Galliernek (Dowling és Gallier, 1984) köszönhetjük, akik az algoritmusokat egy adatfolyam-eljárásként írták le, hasonlóan a jelek terjedéséhez az áramkörökben. A kielégíthetőség ellenőrzése alapvető módszerré vált a problémák NP-teljességének vizsgálatában; például Kaye (Kaye, 2000), megmutatta, hogy az Aknakereső játék (lásd 7.11. feladat) NP-teljes.</p><p>Számos szerző próbálkozott lokális keresési algoritmusokat használni a kielégíthetőség eldöntésére a nyolcvanas években. Minden ilyen algoritmus a kielégíthetetlen klózok számának minimalizálásának elvén (Hansen és Jaumard, 1990) alapult. Különlegesen hatékony algoritmust fejlesztett ki Gu (Gu, 1989), és tőle függetlenül Selman és társai (Selman és társai, 1992), amelyet ez utóbbi szerzők GSAT-nak neveztek el, és megmutatták, hogy az algoritmus képes nehéz problémák széles körét igen gyorsan megoldani. A <code class="code">WALKSAT</code> algoritmust, amelyet ebben a fejezetben bemutattunk, szintén Selma és társai publikálták (1996).</p><p>A „fázisátmenet” létezését a véletlen <span class="emphasis"><em>k</em></span>-SAT problémák kielégíthetőségében először Simon és Dubois (Simon és Dubois, 1989) figyelték meg. Crawford és Auton tapasztalati eredményei (Crawford és Auton, 1993) azt sejtették, hogy nagyméretű, véletlenszerű 3-SAT problémák esetén ez az átmenet a 4,24-es klóz/változó arány környékén van. Cikkük szintén bemutat egy hatékony DPLL megvalósítást. Bayardo és Schrag leírt egy másik, kényszer-kielégítési technikákat alkalmazó hatékony DPLL megvalósítást (Bayardo és Schrag, 1997). Moskewicz és társai publikálták a <code class="code">CHAFF</code> algoritmust (Moskewicz és társai, 2001), amely millió változós hardververifikációs problémákat képes megoldani, és amely megnyerte a SAT 2002 versenyt. Li és Anbulagan gyors problémamegoldókat lehetővé tevő egységpropagáción alapuló heurisztikákat tárgyalt (Li és Anbulagan, 1997). Cheeseman és társai (1991) számos hasonló problémáról adtak adatokat, és megfogalmazták azt a feltevést, hogy minden NP-teljes problémának van állapotátmenete (Cheeseman és társai, 1991). Kirkpatrick és Selman módszereket mutattak arra (Kirkpatrick és Selman, 1994), hogy a statisztikus fizika technikáit hogyan lehet alkalmazni a fázisátmenetek pontos „alakjának” jobb megértéséhez. Az átmenetek <span class="emphasis"><em>helyének</em></span> meghatározására vonatkozó elméleti vizsgálatok igen gyengék: az egyetlen, amit sikerült bizonyítani, hogy az átmenet a [3,003 4,598] tartományba esik a véletlen 3-SAT problémáknál. Cook és Mitchell kiváló áttekintést készítettek ezekről és számos más kielégíthetőséggel kapcsolatos téma eredményeiről (Cook és Mitchell, 1997).</p><p>Korai elméleti kutatások megmutatták, hogy a DPLL átlagos komplexitása polinomiális a problémák egy bizonyos természetes eloszlású köreire. Ez a potenciálisan érdekes tény kevésbé izgalmassá vált, miután Franco és Paull megmutatták, hogy ugyanezek a problémák konstans időben megoldhatók egyszerűen találgatással, ahol véletlen hozzárendelésekkel dolgozunk (Franco és Paull, 1983). A véletlen generáló módszer, amelyet a fejezetben bemutattunk, sokkal nehezebb problémákat hoz létre. Az ilyen, a problémákon lokális kereséssel elért tapasztalati sikerek által motiválva, Koutsoupias és Papadimitriou megmutatta, hogy egy egyszerű hegymászó algoritmussal nagyon gyorsan megoldható <span class="emphasis"><em>szinte minden</em></span> kielégíthetőségi probléma példány (Koutsoupias és Papadimitriou, 1992), ami azt sugallja, hogy a nehéz problémák ritkák. Mi több, Schöning bejelentett (Schönig, 1999) egy véletlen elemeket tartalmazó GSAT változatot, amelynek a <span class="emphasis"><em>legrosszabb esetre</em></span> számított várható futási ideje 3-SAT problémákon 1,333<span class="emphasis"><em>n</em></span> – ami még mindig exponenciális, de lényegesen gyorsabb, mint a korábbi legrosszabb esetkorlátok. A kielégíthetőségi algoritmusok ma is igen aktív területét képezik a kutatásoknak; Du és társai  cikkgyűjteménye (Du és társai, 1999) jó kiindulási pontot jelent.</p><p>Az áramköralapú ágensek gondolata visszavezethető McCulloch és Pitts nagyhatású cikkére (McCulloch és Pitts, 1943), amely a neurális hálózatok témakör kezdetét jelentette. Népszerű vélekedésekkel szemben a cikk valójában logikai áramköralapú ágensterveknek az agyban történő megvalósításával foglalkozott. Azonban az áramköralapú ágens kis figyelmet kapott a mesterséges intelligenciában. A leginkább megjegyzendő kivétel Stan Rosenschein munkája (Rosenschein, 1985; Kaelbling és Rosenschein, 1990), aki módszert dolgozott ki áramköralapú ágensek lefordítására a feladat környezetének deklaratív leírására. A regiszterekben tárolt állítások frissítésének módszere közeli kapcsolatban van a Reiter által az elsőrendű logikára kifejlesztett <span class="strong"><strong>követő állapot axiómá</strong></span>hoz (<span class="strong"><strong>successor-state axiom</strong></span>) (Reiter, 1991). Rod Brooks munkája (1986, 1989) demonstrálta az áramköralapú megvalósítások hatékonyságát robotok vezérlésére – a 25. fejezetben foglalkozunk ezzel a témával. Brooks amellett érvelt (Brooks, 1991), hogy az áramköralapú ágensen kívül más nem is szükséges a mesterséges intelligenciához – mivel más módszerek nehézkesek, drágák és szükségtelenek. A mi nézetünk szerint, egyik módszer sem elégséges önmagában.</p><p>A wumpus világot Gregory Yob (Yob, 1975) találta ki. Némi iróniával, Yob azért fejlesztette ki, mert unta azokat a játékokat, amelyeket egy rácson játszanak: az eredeti wumpus világ dodekaéder alakú volt, mi helyeztük vissza a régi unalmas négyzetrácsba. Michael Genesereth javasolta először, hogy a wumpus világot az ágensek tesztkörnyezeteként alkalmazzuk.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id591339"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>7.1.</strong></span></p><p class="3">Írja le a wumpus világot a 2. fejezetben felsorolt feladatkörnyezetek tulajdonságainak felhasználásával.</p><p><span class="strong"><strong>7.2.</strong></span></p><p>Tegyük fel, hogy az ágens eljutott a 7.4. (a) ábra szerinti állapotba, úgy, hogy nem érzett semmit az [1, 1]-ben, szellőt érzett az [2, 1]-ben és bűzt az [1, 2]-ben, és most vizsgálja az [1, 3], [2, 2] és [3, 1] négyzetek tartalmát. Ezek bármelyike tartalmazhat csapdát, és legfeljebb az egyik tartalmazhatja a wumpust. A 7.5. ábra példáját követve hozza létre a lehetséges világokat (32 ilyet kell találnia). Jelölje meg azokat a világokat, amelyekben a <span class="emphasis"><em>TB</em></span> igaz, és azokat, amelyekben a következő mondatok igazak:</p><p><code class="code">		  <em><span class="remark">α</span></em><sub>2</sub> = „Nincsen csapda a [2, 2]-ben”</code></p><p><code class="code">		  <em><span class="remark">α</span></em><sub> 3</sub><em><span class="remark"> </span></em>= „Az [1,3]-ban wumpus van”</code></p><p>	Mutassa meg ezenkívül, hogy <span class="emphasis"><em>TB</em></span> ⊨ <span class="emphasis"><em>α</em></span><sub> 2</sub><span class="emphasis"><em> </em></span>és <span class="emphasis"><em>TB</em></span> ⊨ <span class="emphasis"><em>α</em></span><sub> 3</sub>.</p><p><span class="strong"><strong>7.3.</strong></span></p><p>Tekintsük azt a problémát, hogy hogyan dönthető el egy ítéletkalkulus mondat igazsága egy adott modellben. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Írjon egy <code class="code">IK-IGAZ</code>?(<span class="emphasis"><em>s</em></span>,<span class="emphasis"><em> m</em></span>) rekurzív programot, amely akkor és csakis akkor ad vissza <span class="emphasis"><em>igaz</em></span>at, ha az <span class="emphasis"><em>s</em></span> mondat igaz az <span class="emphasis"><em>m</em></span> modellben (ahol <span class="emphasis"><em>m </em></span>minden <span class="emphasis"><em>s</em></span> szimbólumhoz egy igazságértéket rendel). Az algoritmusnak a mondat méretével lineárisan változó időben kell futnia. (Használhatja ennek a függvénynek egy változatát az online kódtárból.)</p></li><li class="listitem"><p class="List Paragraph">Adjon három példát olyan mondatokra, amelyekről meghatározható, hogy igazak vagy hamisak egy <span class="emphasis"><em>részleges</em></span> modellben, amely nem specifikálja minden szimbólum igazságértékét. </p></li><li class="listitem"><p class="List Paragraph">Mutassa meg, hogy egy részleges modellben egy mondat igazságértéke (ha van ilyen) általánosságban nem határozható meg hatékonyan. </p></li><li class="listitem"><p class="List Paragraph">Módosítsa az <code class="code">IK-IGAZ</code>? algoritmust úgy, hogy néha részleges modell alapján is meg tudjon határozni igazságértékeket és közben tartsa meg a függvény igazságértékét és lineáris futási idejét. Adjon meg három példát olyan mondatokra, amelyek igazságértékét a részleges modellben nem állapítja meg az algoritmus. </p></li><li class="listitem"><p class="List Paragraph">Vizsgálja meg, hogy a módosított algoritmus hatékonyabbá teszi-e az IT<code class="code">-VONZAT</code>? eljárást.</p></li></ol></div><p><span class="strong"><strong>7.4.</strong></span></p><p>Bizonyítsa be a következő állításokat:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>α</em></span> akkor és csakis akkor érvényes, ha <span class="emphasis"><em>Igaz</em></span> ⊨ <span class="emphasis"><em>α</em></span>.</p></li><li class="listitem"><p class="List Paragraph">Bármilyen <span class="emphasis"><em>α</em></span>-ra <span class="emphasis"><em>Hamis</em></span> ⊨ <span class="emphasis"><em>α</em></span>.</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>α</em></span> ⊨ <span class="emphasis"><em>β </em></span>akkor és csakis akkor, ha az (<span class="emphasis"><em>α </em></span> ⇒ <span class="emphasis"><em>β</em></span>) mondat érvényes.</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>α </em></span>≡<span class="emphasis"><em> β </em></span> akkor és csakis akkor, ha az (<span class="emphasis"><em>α </em></span>⇔ <span class="emphasis"><em>β</em></span>) mondat érvényes.</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>α </em></span>⊨ <span class="emphasis"><em>β </em></span> akkor és csakis akkor, ha az (<span class="emphasis"><em>α </em></span> ∧ ¬<span class="emphasis"><em>β</em></span>) mondat kielégíthetetlen.</p></li></ol></div><p><span class="strong"><strong>7.5.</strong></span></p><p>Vegyünk egy szótárat, amelyben csak négy ítéletkalkulus állítás létezik, az <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>C</em></span> és <span class="emphasis"><em>D</em></span>. Hány modellje létezik a következő mondatoknak?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">(<span class="emphasis"><em>A </em></span>∧<span class="emphasis"><em> B</em></span>) ∨ (<span class="emphasis"><em> B </em></span>∧<span class="emphasis"><em> C </em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>A </em></span>∨<span class="emphasis"><em> B</em></span></p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>A </em></span>⇔<span class="emphasis"><em> B</em></span> ⇔<span class="emphasis"><em> C</em></span></p></li></ol></div><p><span class="strong"><strong>7.6.</strong></span></p><p>Definiáltunk 4 bináris logikai összekötőjelet.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Léteznek-e még továbbiak, amelyek hasznosak lehetnek?</p></li><li class="listitem"><p class="List Paragraph">Hány bináris összekötőjel lehetséges?</p></li><li class="listitem"><p class="List Paragraph">Miért nem túlságosan hasznos közülük néhány?</p></li></ol></div><p><span class="strong"><strong>7.7.</strong></span></p><p>Egy szabadon választott módszer felhasználásával igazolja a 7.11. ábra ekvivalenciáit.</p><p><span class="strong"><strong>7.8.</strong></span></p><p>Vizsgálja meg a következő mondatokat, és döntse el mindegyikre, hogy érvényesek, kielégíthetetlenek, vagy egyik sem. Igazolja a döntését igazságtáblával, vagy felhasználva a 7.11. ábra ekvivalencia szabályait. Van-e olyan, amit elsőre eltévesztett?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Füst </em></span>⇔<span class="emphasis"><em> Füst</em></span></p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Füst </em></span>⇒<span class="emphasis"><em> Tűz</em></span></p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>(Füst </em></span>⇒<span class="emphasis"><em> Tűz</em></span>)<span class="emphasis"><em> </em></span>⇒ (¬<span class="emphasis"><em>Füst </em></span>⇒ ¬<span class="emphasis"><em>Tűz</em></span>)<span class="emphasis"><em> </em></span></p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Füst </em></span>∨<span class="emphasis"><em> Tűz </em></span>∨ ¬<span class="emphasis"><em>Tűz</em></span></p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>((Füst </em></span>∧<span class="emphasis"><em> Hőség</em></span>) ⇒<span class="emphasis"><em> Tűz</em></span>) ⇔ ((<span class="emphasis"><em>Füst </em></span>⇒<span class="emphasis"><em> Tűz</em></span>) ∨ (<span class="emphasis"><em>Hőség </em></span>⇒<span class="emphasis"><em> Tűz</em></span>))</p></li><li class="listitem"><p class="List Paragraph">(<span class="emphasis"><em>Füst </em></span>⇒<span class="emphasis"><em> Tűz</em></span>) ⇒ ((<span class="emphasis"><em>Füst </em></span>∧<span class="emphasis"><em> Hőség</em></span>) ⇒<span class="emphasis"><em> Tűz</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Nagy </em></span>∨<span class="emphasis"><em> Hallgatag </em></span>∨ (<span class="emphasis"><em>Nagy </em></span>⇒<span class="emphasis"><em> Hallgatag</em></span>)</p></li><li class="listitem"><p class="List Paragraph"> (<span class="emphasis"><em>Nagy </em></span>∧<span class="emphasis"><em> Hallgatag</em></span>) ∨ ←<span class="emphasis"><em>Hallgatag</em></span></p></li></ol></div><p><span class="strong"><strong>7.9.</strong></span></p><p>(Barwise és Etchemendy, 1993 alapján) Be tudja-e bizonyítani, hogy az unikornis mitikus, ha adottak az alábbiak? Mit mondhatunk a mágikusságról? Van-e szarva?</p><p>	Ha az unikornis mitikus, akkor halhatatlan, de ha nem halhatatlan, akkor egy halandó emlős. Ha az unikornis vagy halhatatlan, vagy emlős, akkor van szarva. Az unikornis mágikus állat, ha van szarva.</p><p><span class="strong"><strong>7.10.</strong></span></p><p>Minden logikai mondat logikailag ekvivalens azzal az állítással, hogy minden lehetséges világ, amelyben hamis volna, nem az eset. Felhasználva ezt a megfigyelést, bizonyítsa be, hogy minden mondat átírható konjugált normált formára. </p><p><span class="strong"><strong>7.11.</strong></span></p><p>Az ismert számítógépes játék, az Aknakereső igen hasonló a wumpus világhoz. Az aknakereső világ egy <span class="emphasis"><em>N</em></span> négyzetet tartalmazó négyzetes rács, amelyek közül <span class="emphasis"><em>M </em></span>elszórtan elhelyezkedő négyzet láthatatlan aknát takar. Minden négyzetet megpróbálhat az ágens, de azonnali halállal lakol, ha ott egy aknát talál. Az Aknakereső játék minden kipróbált négyzetben felfedi, hogy <span class="emphasis"><em>hány</em></span> közvetlenül vagy átlósan szomszédos négyzetben van akna, ezzel mutatva az aknák jelenlétét. A cél az, hogy minden aknát nem tartalmazó négyzetet megpróbáljunk. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Legyen <span class="emphasis"><em>X</em></span><sub><span class="emphasis"><em>i</em></span>,<span class="emphasis"><em>j </em></span></sub>igaz akkor és csakis akkor, ha az [<span class="emphasis"><em>i</em></span>, <span class="emphasis"><em>j</em></span>] tartalmaz egy aknát. Írja le az <span class="emphasis"><em>X</em></span><sub><span class="emphasis"><em>i</em></span>,<span class="emphasis"><em>j </em></span></sub>szimbólum logikai kombinációját tartalmazó mondattal azt a kijelentést, hogy pontosan két akna szomszédos az [1<span class="emphasis"><em>, </em></span>1]-gyel.</p></li><li class="listitem"><p class="List Paragraph">Általánosítsa az (a)-beli kijelentést megmutatva, hogy hogyan hozható létre konjugált normál formájú mondat annak kifejezésére, hogy az <span class="emphasis"><em>n</em></span> szomszédos négyzetből <span class="emphasis"><em>k</em></span> négyzet tartalmaz aknát.</p></li><li class="listitem"><p class="List Paragraph">Magyarázza meg pontosan, hogy hogyan használhat egy ágens DPLL algoritmust annak bizonyítására, hogy egy adott négyzet tartalmaz (vagy nem tartalmaz) aknát, figyelmen kívül hagyva azt a globális korlátot, hogy pontosan <span class="emphasis"><em>M</em></span> akna van összesen.</p></li><li class="listitem"><p class="List Paragraph">Tegyük fel, hogy a globális korlát a (b) feladatrészben megfogalmazott módon van létrehozva. Hogyan függ a klózok száma <span class="emphasis"><em>M</em></span>-től és <span class="emphasis"><em>N</em></span>-től? Javasoljon egy módosítást a DPLL algoritmushoz, amellyel a globális korlátot nem kell explicit módon reprezentálni.</p></li><li class="listitem"><p class="List Paragraph">Van-e olyan a (c) feladatrészben definiált eljárás által előállított következmény, amely érvénytelenné válna, ha figyelembe vennénk a globális kényszert?</p></li><li class="listitem"><p class="List Paragraph">Mutasson példát olyan lehetséges konfigurációkra, amelyek <span class="emphasis"><em>távoli függőségeket</em></span> idéznek elő, olyanokat, ahol egy ki nem próbált négyzet tartalma távoli négyzetek tartalmáról ad információt. [<span class="emphasis"><em>Segítség:</em></span> vizsgáljon meg egy <span class="emphasis"><em>N</em></span> × 1-es táblát.]</p></li></ol></div><p><span class="strong"><strong>7.12.</strong></span></p><p>Ez a feladat a klózok és az implikációs mondatok közötti kapcsolatot vizsgálja. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Mutassa meg, hogy a (¬<span class="emphasis"><em>P</em></span><sub>1</sub> ∨…∨ ¬<span class="emphasis"><em>P<sub>m</sub></em></span> ∨ <span class="emphasis"><em>Q</em></span>) klóz logikailag ekvivalens a (<span class="emphasis"><em>P</em></span><sub>1</sub> ∧ … ∧ <span class="emphasis"><em>P<sub>m</sub></em></span> ⇒ <span class="emphasis"><em>Q</em></span>) implikációs mondattal.</p></li><li class="listitem"><p class="List Paragraph">Mutassa meg, minden klóz (függetlenül a pozitív literálok számától) felírható (<span class="emphasis"><em>P</em></span><sub>1</sub> ∧ … ∧ <span class="emphasis"><em>P<sub>m</sub></em></span>) ⇒ (<span class="emphasis"><em>Q</em></span><sub>1<span class="emphasis"><em> </em></span></sub>∨…∨ <span class="emphasis"><em>Q<sub>m</sub></em></span>) alakban, ahol <span class="emphasis"><em>P</em></span>-k és <span class="emphasis"><em>Q</em></span>-k ítéletkalkulus szimbólumok. Az ilyen mondatokat tartalmazó tudásbázist <span class="strong"><strong>implikatív normál formá</strong></span>júnak (<span class="strong"><strong>implicative normal form</strong></span>) vagy <span class="strong"><strong>Kowalski formá</strong></span>júnak (<span class="strong"><strong>Kowalski form</strong></span>) nevezzük. </p></li><li class="listitem"><p class="List Paragraph">Írja le a teljes rezolúciós szabályt implikatív normál formájú mondatokra.</p></li></ol></div><p><span class="strong"><strong>7.13.</strong></span></p><p>Ebben a feladatban tervezze tovább az áramkörön alapuló wumpus ágenst.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Írjon egy a (7.4) egyenlethez hasonló egyenletet a <span class="emphasis"><em>Nyíl</em></span> kijelentéshez, amelynek igaznak kell lennie, amikor az ágensnek még van nyíla.</p></li><li class="listitem"><p class="List Paragraph">Ismételje meg az (a) feladatot egy <span class="emphasis"><em>ArccalJobbra</em></span> kijelentésre, ahol használja fel a (7.5) egyenletet modellként. </p></li><li class="listitem"><p class="List Paragraph">Készítsen változatokat a (7.7) és (7.8) egyenletekre a wumpus megtalálásához, és rajzolja fel az áramkört.</p></li></ol></div><p><span class="strong"><strong>7.14.</strong></span></p><p>Elemezze, hogy mit is jelent az <span class="emphasis"><em>optimális</em></span> viselkedés a wumpus világban! Mutassa meg, hogy az <code class="code">IT-WUMPUS-ÁGENS </code>definíciója nem optimális, és tegyen javaslatot a fejlesztésére!</p><p><span class="strong"><strong>7.15.</strong></span></p><div class="informalexample"><p/><p>Bővítse ki az <code class="code">IT-WUMPUS-ÁGENS</code>-t úgy, hogy képes legyen folyamatosan követni a releváns tényeket a tudásbázisban!</p><p/></div><p><span class="strong"><strong>7.16.</strong></span></p><p>Mennyi ideig tart a DPLL számára a  bizonyítása, ahol α egy literális, amelyet <span class="emphasis"><em>már tartalmaz</em></span> a <span class="emphasis"><em>TB</em></span>? Adjon magyarázatot!</p><p><span class="strong"><strong>7.17.</strong></span></p><p>Kövesse a DPLL viselkedését a 7.15. ábrán leírt tudásbázison, amikor <span class="emphasis"><em>Q</em></span>-t próbáljuk meg bizonyítani, és hasonlítsa össze ezt a működést az előrefelé láncolási algoritmussal. </p></div></div></body></html>
