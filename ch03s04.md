<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Nem informált keresés"><div class="titlepage"><div><div><h1 class="title"><a id="id545725"/>Nem informált keresés</h1></div></div></div><p>Ez az alfejezet öt keresési stratégiát tárgyal, amelyek a <span class="strong"><strong>nem informált</strong></span> (<span class="strong"><strong>vak</strong></span>nak is nevezett)<span class="strong"><strong> keresés</strong></span> (<span class="strong"><strong>noninformed</strong></span> (<span class="strong"><strong>blind</strong></span>) <span class="strong"><strong>search</strong></span>) cím alá sorolhatók. A kifejezés azt jelenti, hogy ezen stratégiáknak semmilyen információjuk nincs az állapotokról a probléma definíciójában megadott információn kívül. Működésük során mást nem tehetnek, mint a következő állapotok generálása és a célállapot megkülönböztetése a nem célállapottól. Azokat a stratégiákat, amelyek tudják, hogy az egyik közbülső állapot „ígéretesebb”, mint egy másik közbülső állapot, <span class="strong"><strong>informált keresés</strong></span>i (<span class="strong"><strong>informed search</strong></span>) vagy <span class="strong"><strong>heurisztikus keresés</strong></span>i (<span class="strong"><strong>heuristic search</strong></span>) stratégiának nevezzük. Ezeket majd a 4. fejezet tárgyalja. A keresési stratégiákat a csomópontok kifejtési <span class="emphasis"><em>sorrendje</em></span> különbözteti meg egymástól. </p><div class="section" title="Szélességi keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id545783"/>Szélességi keresés</h2></div></div></div><p>A <span class="strong"><strong>szélességi keresés</strong></span> (<span class="strong"><strong>breadth-first search</strong></span>) egy egyszerű keresési stratégia, ahol először a gyökércsomópontot fejtjük ki, majd a következő lépésben az összes a gyökércsomópontból generált csomópontot, majd <span class="emphasis"><em>azok</em></span> követőit stb. Általánosságban a keresési stratégia minden adott mélységű csomópontot hamarabb fejt ki, mielőtt bármelyik, egy szinttel lejjebbi csomópontot kifejtené. </p><p>A szélességi keresést meg lehet valósítani a <code class="code">FA-KERESÉS</code> algoritmussal egy olyan üres peremmel, amely egy először-be-először-ki (first-in-first-out – FIFO) sor, biztosítva ezzel, hogy a korábban meglátogatott csomópontokat az algoritmus korábban fejti ki. Más szóval a <code class="code">FA-KERESÉS</code> (<span class="emphasis"><em>probléma</em></span>, FIFO-<code class="code">SOR</code> ()) meghívása szélességi keresést eredményez. A FIFO sor az összes újonnan legenerált követőt a sor végére teszi, magyarán a sekélyebb csomópontok korábban kerülnek kifejtésre, mint a mélyebben fekvők. A 3.10. ábra illusztrálja a keresés előrehaladását egy egyszerű bináris fa esetén.</p><div class="figure"><a id="id545819"/><p class="title"><strong>3.10. ábra - Szélességi keresés egy egyszerű bináris fában. Minden lépésnél a következő kifejtendő csomópontot egy marker jelzi.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-10.png" alt="Szélességi keresés egy egyszerű bináris fában. Minden lépésnél a következő kifejtendő csomópontot egy marker jelzi."/></div></div></div><p>A szélességi keresés elemzéséhez az előbbi részben tárgyalt négy jellemzőt fogjuk használni. Könnyű belátni, hogy ez a keresés <span class="emphasis"><em>teljes</em></span>. Ha a legsekélyebb célcsomópont valamilyen véges <span class="emphasis"><em>d</em></span> mélységben fekszik, a szélességi keresés eljut hozzá az összes nála sekélyebben fekvő csomópontot kifejtve (feltéve persze, hogy a <span class="emphasis"><em>b</em></span> elágazási tényező véges). A <span class="emphasis"><em>legsekélyebb</em></span> célcsomópont nem szükségképpen <span class="emphasis"><em>optimális</em></span>. Pontosabban a szélességi keresés optimális, ha az útköltség a csomópont mélységének nem csökkenő függvénye (például ha minden cselekvésnek ugyanannyi a költsége). </p><p>Eddig a szélességi keresésnek csak a jó tulajdonságait láttuk. Ahhoz, hogy megértsük miért nem mindig ezt a stratégiát választjuk, meg kell vizsgálnunk a keresés végrehajtásához szükséges idő és memória mennyiségét. Ehhez egy olyan hipotetikus állapotteret veszünk alapul, amelyben minden egyes állapotot kifejtve <span class="emphasis"><em>b</em></span> új állapot keletkezik. A keresési fa gyökércsomópontja <span class="emphasis"><em>b</em></span> csomópontot generál az első szinten, amelyek mindegyike újabb <span class="emphasis"><em>b</em></span> csomópontot, összesen <span class="emphasis"><em>b</em></span><sup>2</sup> csomópontot generál a második szinten. <span class="emphasis"><em>Ezek </em></span>mindegyike újabb <span class="emphasis"><em>b</em></span> csomópontot generál, összesen <span class="emphasis"><em>b</em></span><sup>3 </sup>csomópontot a harmadik szinten és így tovább. Tételezzük fel, hogy ezen probléma megoldása <span class="emphasis"><em>d</em></span> mélységben található. Ekkor a legrosszabb esetben a <span class="emphasis"><em>d-</em></span>edik szinten az utolsót kivéve (mert a célt magát nem fejtjük ki) a csomópontok mindegyikét ki kell fejtenünk, a (<span class="emphasis"><em>d </em></span>+ 1)-edik szinten <span class="emphasis"><em>b<sup>d</sup></em></span><sup>+1</sup> <span class="emphasis"><em>–</em></span> <span class="emphasis"><em>b</em></span> csomópontot generálva. A generált csomópontok össz-száma így:</p><p><code class="code"><em><span class="remark">b</span></em> + <em><span class="remark">b</span></em><sup>2 </sup>+ <em><span class="remark">b</span></em><sup>3 </sup>+ ... + <em><span class="remark">b<sup>d </sup></span></em>+<em><span class="remark"> </span></em>(<em><span class="remark">b<sup>d+</sup></span></em><sup>1</sup><em><span class="remark">– b</span></em>) = <em><span class="remark">O</span></em>(<em><span class="remark">b<sup>d+</sup></span></em><sup>1</sup>)</code></p><p>Minden legenerált csomópontot a memóriában el kell tárolni, mert vagy a perem eleme, vagy egy perembeli csomópont őse. A tárigény így az időigénnyel azonos (meg egy további csomópont a gyökér számára). </p><p>Azok, akik járatosak a komplexitáselemzésben, kezdenek aggódni (vagy izgatottak lesznek, ha szeretik a kihívásokat), amikor exponenciális komplexitást látnak, mint amilyen például az <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>d+</sup></em></span><sup>1</sup>). A 3.11. ábra megmutatja, hogy miért. Az ábra egy <span class="emphasis"><em>b</em></span> = 10 elágazási tényezővel rendelkező szélességi keresést mutat a <span class="emphasis"><em>d</em></span> megoldás mélység több értékére. A táblában feltételezzük, hogy másodpercenként 10 000 csomópontot generálunk, illetve egy csomópont tárolásához 1000 bájtra van szükség. Számos feladvány jellegű probléma felel meg ezeknek a feltételezéseknek (egy 100-as tényezővel ide vagy oda), ha azokat modern személyi számítógépeken futtatjuk.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A 3.11. ábra alapján két tanulságot vonhatunk le. Először is a <span class="emphasis"><em>szélességi keresés esetén a tárigény nagyobb problémát jelent az időigénynél.</em></span> A legtöbb ember, amennyiben érdekli a válasz egy fontos problémára, türelmesen ki tud várni 31 órát, hogy egy 8 mélységű keresés lefusson, de csak kevés számítógépnek van a kereséshez szükséges Tbájtnyi memóriája. Szerencsére léteznek ennél kevesebb memóriát igénylő keresési algoritmusok is.</p></div><div class="figure"><a id="id545989"/><p class="title"><strong>3.11. ábra - A szélességi keresés idő- és tárigénye. Az ábra adatai <span class="emphasis"><em>b</em></span> = 10-es elágazási tényezőt, 10 000 csomópont/percet és 1000 bájt/csomópontot feltételeznek.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-11.png" alt="A szélességi keresés idő- és tárigénye. Az ábra adatai b = 10-es elágazási tényezőt, 10 000 csomópont/percet és 1000 bájt/csomópontot feltételeznek."/></div></div></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A második tanulság, hogy az időigény még mindig fontos tényező. Ha a problémánk 12 mélységű, akkor (a feltételezéseink mellett) a szélességi keresésnek (vagy akármlyik nem informált keresési algoritmusnak) 35 évbe telne a megoldás megtalálása. Általánosságban <span class="emphasis"><em>az exponenciális komplexitású keresési problémák közül csak a legkisebb problémapéldányok oldhatók meg.</em></span></p></div></div><div class="section" title="Egyenletes költségű keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id546009"/>Egyenletes költségű keresés</h2></div></div></div><p>A szélességi keresés optimális, ha minden lépés költsége azonos, mert mindig a <span class="emphasis"><em>legsekélyebb</em></span> ki nem fejtett csomópontot fejti ki. Egyszerű általánosítással egy olyan algoritmust találhatunk ki, amely tetszőleges lépésköltség mellett optimális. Az <span class="strong"><strong>egyenletes költségű keresés</strong></span> (<span class="strong"><strong>uniform cost search</strong></span>) mindig a <span class="emphasis"><em>legkisebb útköltségű</em></span> <span class="emphasis"><em>n</em></span> csomópontot fejti ki először, nem pedig a legkisebb mélységű csomópontot. Egyszerűen belátható, hogy a szélességi keresés is egyenletes költségű keresés, amennyiben minden lépésköltség azonos.</p><p>Az egyenletes költségű keresés nem foglalkozik azzal, hogy <span class="emphasis"><em>hány</em></span> lépésből áll egy bizonyos út, hanem csak az összköltségükkel törődik. Emiatt mindig végtelen hurokba kerül, ha egy csomópont kifejtése zérus költségű cselekvéshez és ugyanahhoz az állapothoz való visszatérést eredményez (például a <span class="emphasis"><em>NoOp</em></span> cselekvés). A teljességet csak úgy garantálhatjuk, hogy minden lépés költsége egy kis pozitív<span class="emphasis"><em> </em></span>e konstansnál nagyobb, vagy azzal egyenlő. Ez a feltétel egyben az <span class="emphasis"><em>optimalitás</em></span> elégséges feltétele is. Ez azt jelenti, hogy egy út költsége az út mentén mindig növekszik. Ebből a tulajdonságból látszik, hogy az algoritmus a csomópontokat mindig a növekvő útköltség függvényében fejti ki. Azaz az első kifejtésre kiválasztott célcsomópont egyben az optimális megoldás is (emlékezzünk arra, hogy a <code class="code">FA-KERESÉS</code> a célállapottesztet csak a kifejtésre megválasztott csomópontokra alkalmazza). Javasoljuk, hogy próbálják ki az algoritmust, hogy a Bukarestbe vezető legrövidebb utat megtalálják. </p><p>Az egyenletes költségű keresést nem a mélység, hanem az útköltség vezérli, így komplexitását a <span class="emphasis"><em>b</em></span> és a <span class="emphasis"><em>d</em></span> függvényében nehéz jellemezni. Helyette legyen <span class="emphasis"><em>C</em></span><sup>∗</sup> az optimális megoldás költsége, és tételezzük fel, hogy minden cselekvés költsége legalább e. Az algoritmus idő- és tárigénye legrosszabb esetben<span class="inlinemediaobject"><img src="kepek/03-01ma.png" alt="Egyenletes költségű keresés"/></span>, ami sokkal több lehet, mint <span class="emphasis"><em>b<sup>d</sup></em></span>. Ez azért lehetséges, mert az egyenletes költségű keresés képes (és sokszor ezt meg is teszi) a kis lépésekből álló nagy fákat felkutatni a nagy és feltehetően hasznos lépéseket tartalmazó utak előtt. Amikor minden lépés költsége ugyanannyi, az<span class="inlinemediaobject"><img src="kepek/03-02ma.png" alt="Egyenletes költségű keresés"/></span>,  persze azonos <span class="emphasis"><em>b<sup>d</sup></em></span>-nel.</p></div><div class="section" title="Mélységi keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id546101"/>Mélységi keresés</h2></div></div></div><a id="ID_115_116_oldal"/><p>A <span class="strong"><strong>mélységi keresés</strong></span> (<span class="strong"><strong>depth-first search</strong></span>) mindig a keresési fa aktuális peremében a <span class="emphasis"><em>legmélyebben</em></span> fekvő csomópontot fejti ki. A keresés lefolyását a 3.12. ábra illusztrálja. A keresés azonnal a fa legmélyebb szintjére jut el, ahol a csomópontoknak már nincsenek követőik. Kifejtésüket követően kikerülnek a peremből és a keresés „visszalép” ahhoz a következő legmélyebben fekvő csomóponthoz, amelynek vannak még ki nem fejtett követői.</p><p>Ez a stratégia egy olyan <code class="code">FA-KERESÉS</code> függvénnyel implementálható, amelynek a sorbaállító függvénye az utolsónak-be-elsőnek-ki (last-in-first-out, LIFO), más néven verem. A mélységi keresést szokás a <code class="code">FA-KERESÉS</code> függvény alternatívájaként egy rekurzív függvénnyel is implementálni, amely a gyermekcsomópontokkal meghívja önmagát (mélységkorláttal dolgozó rekurzív mélységi keresés algoritmusát a 3.13. ábra mutatja).</p><p>A mélységi keresés nagyon szerény tárigényű. Csak egyetlen, a gyökércsomóponttól egy levélcsomópontig vezető utat kell tárolnia, kiegészítve az út minden egyes csomópontja melletti kifejtetlen csomópontokkal. Egy kifejtett csomópont el is hagyható a memóriából, feltéve, hogy az összes leszármazottja meg lett vizsgálva. Egy <span class="emphasis"><em>b</em></span> elágazási tényezőjű és <span class="emphasis"><em>m</em></span> maximális mélységű állapottér esetén a mélységi keresés tárigénye <span class="emphasis"><em>bm </em></span>+<span class="emphasis"><em> </em></span>1. A 3.11. ábra<span class="emphasis"><em> </em></span>feltételezéseivel élve és feltételezve, hogy a célcsomópont mélységű csomópontoknak nincsenek követőik, azt találjuk, hogy például <span class="emphasis"><em>d</em></span> = 12 mélység esetén a mélységi keresés 118 kbájtot igényelne a 10 Pbájttal szemben, ami tízmilliárdos redukciót jelent a tárigényben.</p><p>A mélységi keresés <span class="strong"><strong>visszalépéses keresés</strong></span>nek (<span class="strong"><strong>backtracking search</strong></span>) nevezett változata még kevesebb memóriát használ. A visszalépéses keresés az összes követő helyett egyidejűleg csak egy követőt generál. Minden részben kifejtett csomópont emlékszik, melyik követője jön a legközelebb. Ily módon csak <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>m</em></span>) memóriára van szükség, <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bm</em></span>) helyett. A visszalépéses keresés még egy memória- (és idő-) spóroló trükkhöz folyamodik. Az ötlet a követő csomópont generálása az aktuális állapot <span class="emphasis"><em>módosításával</em></span>, anélkül hogy az állapotot átmásolnánk. Ezzel a memóriaszükséglet egy állapotra és <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>m</em></span>) cselekvésre redukálódik. Ahhoz, hogy az ötlet működjön, amikor visszalépünk, hogy a következő követőt generáljuk, mindegyik módosítást vissza kell tudnunk csinálni. Nagy állapottérrel rendelkező problémák esetén, mint például robot-összeszerelés esetén, az ilyen módszerek lényegesek a sikerességhez.</p><p>A mélységi keresés hátrányos tulajdonsága, hogy egy rossz választással egy hosszú (akár végtelen) út mentén lefelé elakadhat, miközben például egy más döntés elvezetne a gyökérhez közeli megoldáshoz. A 3.12. ábrán például a mélységi keresés kifejti az egész bal oldali részfát, annak ellenére, hogy a <span class="emphasis"><em>C</em></span> csomópont a megoldás. Ha a <span class="emphasis"><em>J </em></span>csomópont szintén megoldás lenne, a mélységi keresés azt adná vissza megoldásul, következésképpen a mélységi keresés nem optimális. Ha a bal oldali részfa korlátlanul mély lenne és nem tartalmazna megoldást, a mélységi keresés soha nem állna meg, következésképpen a mélységi keresés nem teljes. A legrosszabb esetben a mélységi keresés a keresési fában az összes <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>m</sup></em></span>) csomópontot generálni fogja, ahol <span class="emphasis"><em>m </em></span>a csomópontok maximális mélysége. Jegyezzük meg, hogy <span class="emphasis"><em>m</em></span> sokkal nagyobb lehet, mint <span class="emphasis"><em>d</em></span> (a legsekélyebb megoldás mélysége), és korlátlan fák esetén értéke végtelen.</p><div class="figure"><a id="id546227"/><p class="title"><strong>3.12. ábra - Mélységi keresés egy bináris keresési fában. A kifejtett csomópontok, amelyeknek a peremben nincsenek követőik, el is hagyhatók a memóriából. Ezeket feketével jelöltük meg. A 3-as mélységű csomópontokról feltételezzük, hogy nincsenek követőik, valamint azt is feltesszük, hogy <span class="emphasis"><em>M</em></span> az egyetlen célcsomópont.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-12.png" alt="Mélységi keresés egy bináris keresési fában. A kifejtett csomópontok, amelyeknek a peremben nincsenek követőik, el is hagyhatók a memóriából. Ezeket feketével jelöltük meg. A 3-as mélységű csomópontokról feltételezzük, hogy nincsenek követőik, valamint azt is feltesszük, hogy M az egyetlen célcsomópont."/></div></div></div></div><div class="section" title="Mélységkorlátozott keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id546241"/>Mélységkorlátozott keresés</h2></div></div></div><p>A végtelen fák problémáját a mélységi keresés azáltal küszöböli ki, hogy az utak maximális mélységére egy <span class="emphasis"><em>ℓ</em></span> korlátot ad. Az <span class="emphasis"><em>ℓ</em></span> mélységben lévő csomópontokat úgy kezeli, mintha nem is lennének követőik. A módszer neve a <span class="strong"><strong>mélységkorlátozott keresés</strong></span>, <span class="strong"><strong>MKK</strong></span> (<span class="strong"><strong>depth-limited search</strong></span>, <span class="strong"><strong>DLS</strong></span>). A mélységkorlát a végtelen út problémáját ugyan megoldja, de a nemteljesség egy újabb forrását hozza be, ha <span class="emphasis"><em>ℓ</em></span> &lt; <span class="emphasis"><em>d</em></span> -t választunk, azaz, ha a legsekélyebb célcsomópont a mélységkorláton túl van (ez nem is esélytelen, ha <span class="emphasis"><em>d</em></span> eleve ismeretlen). A mélységkorlátozott keresés <span class="emphasis"><em>ℓ</em></span> &gt; <span class="emphasis"><em>d</em></span> választással sem lesz optimális. A keresés időigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>ℓ</sup></em></span>), tárigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bℓ</em></span>). A mélységi keresés egy olyan speciális mélységkorlátozott keresésének tekinthető, amelynek mélységkorlátja <span class="emphasis"><em>ℓ</em></span> = ∞. </p><p>A mélységi korlátot néha a probléma ismeretére lehet alapozni. Például Románia térképén 20 város található, így tudjuk, hogy ha létezik egy megoldás, az maximálisan 19 lépés hosszú lehet, így az <span class="emphasis"><em>ℓ</em></span> = 19 egy lehetséges választás. Ha azonban a térképet tüzetesebben tanulmányoznánk, felfedeznénk, hogy minden város bármelyik másik városból legfeljebb 9 lépésben elérhető. Ez a szám, amit az állapottér <span class="strong"><strong>átmérő</strong></span>jének (<span class="strong"><strong>diameter</strong></span>) nevezünk, jobb mélységkorlátot ad, ami hatékonyabb mélységkorlátozott keresést eredményez. A legtöbb probléma esetén azonban mindaddig nem tudunk jó mélységkorlátot adni, amíg meg nem oldottuk a problémát.</p><p>A mélységkorlátozott keresést az általános fakeresési vagy a rekurzív mélységi keresési algoritmus egyszerű módosításával lehet implementálni. A 3.13. ábra mutatja a rekurzív mélységkorlátozott keresés pszeudokódját. Jegyezzük meg, hogy a mélységkorlátozott keresés kudarccal kétféle módon állhat le: a standard <span class="emphasis"><em>kudarc</em></span> csomópont jelzi a megoldás hiányát, a <span class="emphasis"><em>vágás</em></span> érték viszont jelzi a megoldás mélységkorláton belüli hiányát.</p><div class="figure"><a id="id546340"/><p class="title"><strong>3.13. ábra - A mélységkorlátozott keresés rekurzív implementációja</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-13.png" alt="A mélységkorlátozott keresés rekurzív implementációja"/></div></div></div></div><div class="section" title="Iteratívan mélyülő mélységi keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id546349"/>Iteratívan mélyülő mélységi keresés</h2></div></div></div><a id="ID_118_oldal"/><p>Az <span class="strong"><strong>iteratívan mélyülő keresés</strong></span> (<span class="strong"><strong>iterative deepening search</strong></span>) – vagy iteratívan mélyülő mélységi keresés – egy általános stratégia, amit sokszor a mélységi kereséssel együtt alkalmaznak a legjobb mélységkorlát megtalálására. Az algoritmus képes erre, mert fokozatosan növeli a mélységkorlátot – legyen az először 0, majd 1, majd 2 stb. – amíg a célt meg nem találja. Ez akkor következik be, ha a mélységkorlát eléri a <span class="emphasis"><em>d</em></span>-t, a legsekélyebben fekvő célcsomópont mélységét. Az algoritmust a 3.14. ábra mutatja. Az iteratívan mélyülő keresés ötvözi a szélességi és a mélységi keresés előnyös tulajdonságait. A mélységi kereséshez hasonlóan szerény, pontosabban <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bd</em></span>) memóriaigénnyel rendelkezik. A szélességi kereséshez hasonlóan teljes, ha elágazási tényezője véges, és optimális, ha az útköltség a csomópontok mélységének nem csökkenő függvénye. A 3.15. ábra az <code class="code">ITERATÍVAN-MÉLYÜLŐ-KERESÉS</code> első négy iterációját mutatja egy bináris fán, ahol az algoritmus a megoldást a negyedik iterációban találja meg.</p><p>Az iteratívan mélyülő keresés tékozlónak tűnhet, mert felettébb sok állapotot többször is kifejt. Kiderül azonban, hogy a költségtöbblet nem lényeges. Ennek az az oka, hogy egy olyan keresési fában, ahol minden szinten ugyanaz (vagy közel ugyanaz) az elágazási tényező, majdnem az összes csomópont a legmélyebb szinten található, így nem túl sokat számít, hogy a magasabb szinteket többször is kifejtjük. Az iteratívan mélyülő keresésben a legmélyebb szinten (<span class="emphasis"><em>d</em></span> mélység) található csomópontokat csak egyszer fejtjük ki, egy szinttel feljebb kétszer stb. egészen a gyökér gyerekeiig, amelyeket <span class="emphasis"><em>d</em></span>-szer fejtünk ki. Így a kifejtett csomópontok össz-száma:</p><p><code class="code"><em><span class="remark">Cs</span></em>(IMK) = (<em><span class="remark">d</span></em>)<em><span class="remark">b</span></em> + (<em><span class="remark">d </span></em>– 1)<em><span class="remark">b</span></em><sup>2</sup> + ... + (1)<em><span class="remark">b<sup>d</sup></span></em></code></p><p>amely <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>d</sup></em></span>) időkomplexitást eredményez. Összehasonlításul nézzük meg a szélességi keresés által generált csomópontok számát:</p><p><code class="code"><em><span class="remark">Cs</span></em>(SZK) = <em><span class="remark">b</span></em> + <em><span class="remark">b</span></em><sup>2</sup> + ... + <em><span class="remark">b<sup>d</sup> </span></em>+<em><span class="remark"> </span></em>(<em><span class="remark">b<sup>d</sup></span></em><sup>+1</sup> – <em><span class="remark">b</span></em>)</code></p><p>Vegyük észre, hogy a szélességi keresés <span class="emphasis"><em>d </em></span>+ 1 mélységben is generál csomópontokat, az iteratívan mélyülő kereséssel ellentétben. Ennek eredménye, hogy az iteratívan mélyülő keresés a szélességi keresésnél <span class="emphasis"><em>gyorsabb</em></span>, annak ellenére, hogy a csomópontokat többször fejti ki. Konkretizálva, például <span class="emphasis"><em>b </em></span>= 10 és <span class="emphasis"><em>d </em></span>= 5 esetén ezek a számok:</p><p><code class="code"><em><span class="remark">Cs</span></em>(IMK) = 50 + 400 + 3000 + 20 000 + 100 000 = 123 450</code></p><p><code class="code"><em><span class="remark">Cs</span></em>(SZK) = 10 + 100 + 1000 + 10 000 + 100 000 + 999 990 = 1 111 100</code></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p><span class="emphasis"><em>Általánosságban nagy keresési térrel rendelkező problémák esetén és ha a megoldás mélysége nem ismert, a nem informált módszerek köréből az iteratívan mélyülő keresés a javasolt.</em></span></p></div><div class="figure"><a id="id546505"/><p class="title"><strong>3.14. ábra - Az iteratívan mélyülő keresési algoritmus mélységkorlátozott keresést alkalmaz ismételten, növekvő mélységkorláttal. Az algoritmus megáll, ha a megoldást megtalálja, vagy ha a mélységkorlátozott keresés kudarccal tér vissza, jelezve, hogy megoldás nem létezik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-14.png" alt="Az iteratívan mélyülő keresési algoritmus mélységkorlátozott keresést alkalmaz ismételten, növekvő mélységkorláttal. Az algoritmus megáll, ha a megoldást megtalálja, vagy ha a mélységkorlátozott keresés kudarccal tér vissza, jelezve, hogy megoldás nem létezik."/></div></div></div><div class="figure"><a id="id546515"/><p class="title"><strong>3.15. ábra - Az iteratívan mélyülő keresési algoritmus négy iterációja egy bináris fán</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-15.png" alt="Az iteratívan mélyülő keresési algoritmus négy iterációja egy bináris fán"/></div></div></div><a id="ID_119_oldal"/><p>Az iteratívan mélyülő keresés a szélességi kereséssel abban rokon, hogy minden iterációban a csomópontok teljes rétegét megvizsgálja, mielőtt a következő rétegre térne rá. Hasznosnak látszik az egyenletes költségű keresés iteratív változatának kifejlesztése, amely örökölné ez utóbbi optimalitását, mellőzve annak a tárkövetelményeit. Az ötlet a növekvő útköltségkorlát használata a növekvő mélységkorlát helyett. Az eredményül kapott algoritmussal, amelynek neve <span class="strong"><strong>iteratívan megnyúló keresés</strong></span> (<span class="strong"><strong>iterative</strong></span><span class="strong"><strong> lengthening search</strong></span>) a 3.11. feladat foglalkozik. Sajnos az derül ki, hogy az iteratívan megnyúló keresés overheadje tekintélyes az egyenletes költségű kereséshez képest.</p></div><div class="section" title="Kétirányú keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id546544"/>Kétirányú keresés</h2></div></div></div><p>A kétirányú keresés mögött az az ötlet húzódik, hogy egyszerre el lehet indítani egy keresést előrefelé a kiinduló állapotból, illetve hátrafelé a célállapotból, és a keresés akkor fejeződik be, ha a két keresés valahol találkozik (lásd 3.16. ábra). Az érv az, hogy <span class="emphasis"><em>b</em></span><sup><span class="emphasis"><em>d</em></span>/2</sup> + <span class="emphasis"><em>b</em></span><sup><span class="emphasis"><em>d</em></span>/2</sup><span class="emphasis"><em> </em></span>sokkal kisebb, mint <span class="emphasis"><em>b<sup>d</sup></em></span>, illetve az ábrán szemlélve, hogy a két kisebb kör összterülete kisebb, mint annak a nagy körnek a területe, amelynek középpontja a kiinduló állapot, és amely a peremével a célállapotot eléri. </p><div class="figure"><a id="id546575"/><p class="title"><strong>3.16. ábra - A kétirányú szélességi keresés sematikus ábrája. Az ábrán a két keresési irány majdnem találkozik, amikor a kiinduló csomópontból kinyúló egyik ág összeér egy a célcsomópontból kinyúló másik ággal.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-16.png" alt="A kétirányú szélességi keresés sematikus ábrája. Az ábrán a két keresési irány majdnem találkozik, amikor a kiinduló csomópontból kinyúló egyik ág összeér egy a célcsomópontból kinyúló másik ággal."/></div></div></div><p>A kétirányú keresést úgy implementálják, hogy az egyik vagy mindkét keresés egy csomópont kifejtése előtt megvizsgálja, hogy az nem része-e a másik keresési fa peremének. Ha igen, megvan a cél. Ha a probléma például <span class="emphasis"><em>d</em></span> = <span class="emphasis"><em>6 </em></span>megoldás mélységű, és mindegyik irányban a szélességi keresést futtatjuk csomópontonként, a két keresés a legrosszabb esetben akkor találkozik, ha mindegyik algoritmus a 3-as mélységben egy csomópont kivételével minden csomópontot kifejtett. A <span class="emphasis"><em>b </em></span>=<span class="emphasis"><em> </em></span>10 esetén ez 22 200 csomópont generálását jelenti a standard szélességi keresés által generált 1 111 111 csomóponthoz képest. Annak ellenőrzését, hogy egy csomópont a másik keresési fához tartozik-e, egy hash-táblával konstans időben meg lehet oldani. A kétirányú keresés időkomplexitása így <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b</em></span><sup><span class="emphasis"><em>d</em></span>/2</sup>). Legalább az egyik keresési fát a memóriában kell tartani, hogy a tartozás ellenőrzése kivitelezhető legyen, a tárkomplexitás tehát szintén <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b</em></span><sup><span class="emphasis"><em>d</em></span>/2</sup>). Ez a tárkomplexitás a kétirányú keresés legnagyobb gyengéje. Ha mindkét keresés szélességi keresés, az algoritmus teljes és optimális (egyenletes költség esetén). Más módszerek kombinációja vagy a teljesség, vagy az optimalitás, vagy mindkettő elvesztéséhez vezethet.</p><p>Az időkomplexitás mérséklése a kétirányú keresést igen vonzóvá teszi, de mit is jelent a célállapotból hátrafelé keresni? Ez nem is olyan egyszerű, mint amilyennek hangzik. Legyenek <span class="emphasis"><em>x</em></span> csomópont <span class="strong"><strong>elődcsomópont</strong></span>jai (<span class="strong"><strong>predecessor</strong></span>s), az <span class="emphasis"><em>Előd</em></span>(<span class="emphasis"><em>x</em></span>)-ek azon csomópontok, amelyek mindegyikének <span class="emphasis"><em>x</em></span> a követő csomópontja. A kétirányú keresés feltételezi, hogy egy <span class="emphasis"><em>Előd</em></span>(<span class="emphasis"><em>x</em></span>) hatékonyan számítható. Legegyszerűbb az az eset, amikor az összes cselekvés az állapottérben reverzíbilis, így <span class="emphasis"><em>Előd</em></span>(<span class="emphasis"><em>x</em></span>) = <span class="emphasis"><em>Követő</em></span>(<span class="emphasis"><em>x</em></span>). Más esetben azonban igen nagy ötletességre lehet szükség.</p><p>Nézzük most, hogy mit is jelent az, hogy „cél”, ha a célállapotból hátrafelé kell keresni. A 8-as kirakójáték és a romániai útkeresés esetén egyetlenegy célállapot létezik csak, így a hátrafelé keresés és az előrefelé keresés igen hasonlítanak egymásra. Amennyiben létezik a célállapotoknak egy <span class="emphasis"><em>explicit</em></span> <span class="emphasis"><em>listája,</em></span> mint például a 3.3. ábra két koszmentes célállapota, akkor megkonstruálhatunk egy olyan ál-célállapotot, amelynek közvetlen követői az aktuális célállapotok. Más módon, néhány redundáns csomópont-generálás elkerülhető azzal, hogy a célállapotok halmazát egyetlenegy célállapotnak tekintjük, amelynek minden elődje szintén egy állapothalmaz – konkrétan azon állapotok halmaza, amelyek követője a célállapothalmaz eleme (lásd még 3.6. alfejezet).</p><p>A kétirányú keresés szempontjából a legnehezebb eset, amikor a célállapottesztnél a feltehetően nagy célállapothalmazról csak implicit <span class="emphasis"><em>leírás</em></span> áll rendelkezésünkre, például a sakkban az összes állapot, ami kielégíti a „matt” célt. A hátrafelé keresésnek az „<span class="emphasis"><em>m</em></span><sub>1</sub> cselekvés révén a »matt« állapotba vezető összes állapot” tömör leírását kellene tudnia megkonstruálni, és hasonló módon folytatni. E leírásokat az előrefelé haladó keresés által generált állapotokkal kellene tesztelni. Ennek nincs általánosan hatékony módja.</p></div><div class="section" title="A keresési stratégiák összehasonlítása"><div class="titlepage"><div><div><h2 class="title"><a id="id548334"/>A keresési stratégiák összehasonlítása</h2></div></div></div><p>A 3.17. ábra a 3.4. alfejezetben megfogalmazott négy kiértékelési kritérium tükrében összehasonlítja a keresési stratégiákat.</p><div class="figure"><a id="id548340"/><p class="title"><strong>3.17. ábra - A keresési stratégiák értékelése. <span class="emphasis"><em>b</em></span> az elágazási tényező, <span class="emphasis"><em>d</em></span> a legsekélyebb megoldás mélysége, <span class="emphasis"><em>m</em></span> a keresési fa maximális mélysége, <span class="emphasis"><em>ℓ</em></span> a mélységkorlát. A felső indexszel jelzett kikötések a következők: <sup>a</sup> teljes, ha <span class="emphasis"><em>b</em></span> véges; <sup>b</sup> teljes, ha a lépésköltség ≥ ε, pozitív ε-ra;  <sup>c</sup> optimális, ha a lépésköltségek mind azonosak; <sup>d</sup> ha mindkét irányban szélességi keresést használunk.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/03-17.png" alt="A keresési stratégiák értékelése. b az elágazási tényező, d a legsekélyebb megoldás mélysége, m a keresési fa maximális mélysége, ℓ a mélységkorlát. A felső indexszel jelzett kikötések a következők: a teljes, ha b véges; b teljes, ha a lépésköltség ≥ ε, pozitív ε-ra; c optimális, ha a lépésköltségek mind azonosak; d ha mindkét irányban szélességi keresést használunk."/></div></div></div></div></div></body></html>
