<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="4. fejezet - Informált keresési és felfedező módszerek"><div class="titlepage"><div><div><h1 class="title"><a id="id549778"/>4. fejezet - Informált keresési és felfedező módszerek</h1></div></div></div><p><span class="emphasis"><em>Ebben a fejezetben látni fogjuk, hogy az állapottérrel kapcsolatos információ segítségével az algoritmusok hogyan kerülhetik el a sötétben való tapogatózást.</em></span></p><p>A 3. fejezetben láttuk, hogy a nem informált keresési stratégiák oly módon képesek problémák megoldásait megtalálni, hogy szisztematikusan új állapotokat generálnak és összehasonlítják azokat a célállapottal. Sajnos ezek a stratégiák a legtöbb esetben hihetetlenül rossz hatékonysággal dolgoznak. Ezen fejezet megmutatja, hogy egy – problémaspecifikus tudást alkalmazó – informált keresési stratégia hatékonyabban képes a megoldást megtalálni. A 4.1. alfejezet bemutatja a 3. fejezetben tanulmányozott algoritmusok informált változatait, a 4.2. alfejezet pedig elmagyarázza, hogy a szükséges problémaspecifikus információ hogyan szerezhető meg. A 4.3. és a 4.4. alfejezet olyan algoritmusokkal foglalkozik, amelyek az állapottérben tisztán <span class="strong"><strong>lokális keresés</strong></span>t (<span class="strong"><strong>local search</strong></span>) hajtanak végre, egy vagy több aktuális állapotot értékelve és módosítva ahelyett, hogy szisztematikusan tárnák fel az utat a kezdeti állapottól indulva. Ezek az algoritmusok olyan problémák esetén jók, ahol az útköltség közömbös, és az egyetlen, ami számít, hogy megtaláljuk-e a megoldást. A lokális keresési algoritmusok családjába a statisztikai fizika inspirálta módszerek (<span class="strong"><strong>szimulált lehűtés</strong></span>, <span class="strong"><strong>simulated annealing</strong></span>) és az evolúciós biológia sugallta módszerek (<span class="strong"><strong>genetikus algoritmus</strong></span>ok, <span class="strong"><strong>genetic algorithm</strong></span>s) is beletartoznak. A 4.5. alfejezet végül az <span class="strong"><strong>online keresés</strong></span>sel (<span class="strong"><strong>online search</strong></span>) foglalkozik, ahol az ágens egy teljesen ismeretlen állapottérrel találja magát szembe.</p><div class="section" title="Informált (heurisztikus) keresési stratégiák"><div class="titlepage"><div><div><h1 class="title"><a id="id549826"/>Informált (heurisztikus) keresési stratégiák</h1></div></div></div><p>Ez a fejezet megmutatja, hogy az <span class="strong"><strong>informált keresés</strong></span>i (<span class="strong"><strong>informed search</strong></span>) stratégia – amely a probléma definícióján túlmenően problémaspecifikus tudást is felhasznál – hogyan képes hatékonyabban megtalálni a megoldást. </p><p>Az általunk vizsgált általános megközelítést a <span class="strong"><strong>legjobbat-először keresés</strong></span>nek (<span class="strong"><strong>best-first search</strong></span>) nevezzük. A legjobbat-először keresés az általános <code class="code">FA-KERESÉS</code> vagy <code class="code">GRÁF-KERESÉS</code> algoritmusok olyan speciális esete, ahol egy csomópont kifejtésre való kiválasztása egy <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) <span class="strong"><strong>kiértékelő függvény</strong></span>től (<span class="strong"><strong>evaluation function</strong></span>) függ. Hagyományosan a <span class="emphasis"><em>legkisebb</em></span> értékű csomópontot választjuk kifejtésre, mert a kiértékelő függvény a céltól való távolságot méri. A legjobbat-először keresés az eddigi általános keresési eljárások keretein belül egy prioritási sor segítségével implementálható, ami egy olyan adatstruktúra, mely a peremet a növekvő <span class="emphasis"><em>f</em></span>-értékek szerint rendezi.</p><p>A legjobbat-először keresés egy nagy múltú, azonban pontatlan elnevezés. Amenynyiben <span class="emphasis"><em>valóban</em></span> képesek lennénk a legjobb csomópontot kifejteni, akkor egyáltalán nem kellene keresnünk, nyílegyenesen elmasíroznánk a célhoz. Ezzel szemben csak a kiértékelő függvény szerint legjobbnak <span class="emphasis"><em>tűnő</em></span> csomópontot tudjuk kiválasztani. Ha kiértékelő függvényünk mindentudó, akkor a kiválasztott csomópont egyben a legjobb csomópont is. A valóságban azonban a kiértékelő függvény néha pontatlan, és félrevezetheti a keresést. Azonban a továbbiakban is ragaszkodni fogunk a legjobbat-először keresés elnevezéshez, mert a legjobbnak tűnőt először keresés egy kicsit furcsán hangzana.</p><p>A <code class="code">LEGJOBBAT-ELŐSZÖR-KERESÉS</code> algoritmus tulajdonképpen egy keresési algoritmus család, amelynek az elemeit az eltérő kiértékelő függvények<sup>[<a id="id549902" href="#ftn.id549902" class="footnote">33</a>]</sup> különböztetik meg. Ezeknek az algoritmusoknak a kulcseleme a <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>)-nel jelölt <span class="strong"><strong>heurisztikus függvény</strong></span><sup>[<a id="id549919" href="#ftn.id549919" class="footnote">34</a>]</sup> (<span class="strong"><strong>heuristic</strong></span><span class="strong"><strong> function</strong></span>):</p><p><code class="code"><em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>) = az <em><span class="remark">n</span></em> csomóponttól a célig vezető legolcsóbb út becsült útköltsége</code></p><p>Például Romániában az Arad és Bukarest közötti legolcsóbb út költségét az Arad és Bukarest közötti légvonaltávolsággal meg lehetne becsülni.</p><p>A heurisztikus függvény a leginkább megszokott módja annak, hogy a problémára vonatkozó pótlólagos tudást a keresési algoritmusba be tudjuk injektálni. A heurisztikus függvényekkel részletesen a 4.2. alfejezetben foglalkozunk. Egyelőre tetszőleges, ám problémaspecifikus függvényeknek fogjuk őket tekinteni, egy kikötéssel: ha <span class="emphasis"><em>n</em></span> egy célállapot, akkor <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) = 0. A jelen fejezet hátralévő része két olyan utat mutat be, ahol a heurisztikus információt a keresés irányítására használjuk fel.</p><div class="section" title="A mohó legjobbat-először keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id549976"/>A mohó legjobbat-először keresés</h2></div></div></div><p>A <span class="strong"><strong>mohó legjobbat-először keresés</strong></span><sup>[<a id="id549985" href="#ftn.id549985" class="footnote">35</a>]</sup> (<span class="strong"><strong>greedy best-first search</strong></span>) azt a csomópontot fejti ki a következő lépésben, amelyiknek az állapotát a legközelebbinek ítéli a célállapothoz, abból kiindulva, hogy így gyorsan megtalálja a megoldást. A csomópontokat az algoritmus tehát az <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) = <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) heurisztikus függvénnyel értékeli ki.</p><p>Nézzük meg, hogy hogyan működik ez a romániai útkeresésnél a <span class="strong"><strong>légvonalban mért távolság</strong></span>ot (<span class="strong"><strong>straight-line distance</strong></span>) felhasználva, amit <span class="emphasis"><em>h<sub>LMT</sub></em></span>-vel fogunk jelölni. Ha a cél Bukarest, szükségünk lesz Bukarest légvonalbeli távolságaira, amelyeket a 4.1. ábra ad meg. Például <span class="emphasis"><em>h<sub>LMT</sub></em></span>(<span class="emphasis"><em>Benn</em></span>(<span class="emphasis"><em>Arad</em></span>)) = 366. Vegyük észre, hogy a <span class="emphasis"><em>h<sub>LMT</sub></em></span> értékeit magának a problémának a leírásából kiszámítani nem lehet. Továbbá egy kis tapasztalat is szükséges ahhoz, hogy rájöjjünk, hogy a <span class="emphasis"><em>h<sub>LMT</sub></em></span> az úton megtett tényleges távolsággal korrelál, és így számunkra hasznos heurisztika lehet.</p><div class="figure"><a id="id550078"/><p class="title"><strong>4.1. ábra - A <span class="emphasis"><em>h<sub>LMT</sub></em></span> értékei – a légvonalbeli távolságok Bukarestig</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-01.png" alt="A hLMT értékei – a légvonalbeli távolságok Bukarestig"/></div></div></div><a id="ID_138_139_oldal"/><p>A 4.2. ábra egy Aradról Bukarestbe vezető út mohó legjobbat-először keresését mutatja, <span class="emphasis"><em>h<sub>LMT</sub></em></span>-t alkalmazva. Aradból az első kifejtett csomópont Nagyszeben, mert ez közelebb van Bukaresthez, mint Nagyzerénd vagy Temesvár. A következő kifejtendő csomópont pedig Fogaras, mert az van a legközelebb. Fogaras majd generálja Bukarestet, ami egyben a célállapot. Erre a konkrét problémára a <span class="emphasis"><em>h<sub>LMT </sub></em></span>-t alkalmazó mohó legjobbat-először keresés úgy talál megoldást, hogy soha sem fejt ki olyan csomópontot, ami nem a megoldási úton fekszik. Következésképpen minimális a keresési költsége. Azonban nem optimális: a Nagyszebenen és Fogarason keresztül Bukarestbe vezető út 32 kilométerrel hosszabb a Rimnicu Vilceán és Piteştin keresztül vezető útnál. Ebből látszik, hogy az algoritmus miért „mohó” – minden lépésben igyekszik annyira közel kerülni a célhoz, ahogy csak lehet.</p><div class="figure"><a id="id550110"/><p class="title"><strong>4.2. ábra - A mohó legjobbat-először keresés lépései Bukarest esetén a légvonalban mért távolságot (<span class="emphasis"><em>h<sub>LMT</sub></em></span>) alkalmazva. A csomópontok a saját <span class="emphasis"><em>h</em></span>-értékeikkel vannak felcímkézve.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-02.png" alt="A mohó legjobbat-először keresés lépései Bukarest esetén a légvonalban mért távolságot (hLMT) alkalmazva. A csomópontok a saját h-értékeikkel vannak felcímkézve."/></div></div></div><p>A <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) minimalizálása érzékeny a hibás kezdő lépésekre. Tekintsük például azt az esetet, amikor Iaşiról Fogarasra akarunk eljutni. A heurisztika alapján Neamtot kellene először kifejteni, hiszen ez fekszik Fogarashoz a legközelebb, azonban ez zsákutca. A megoldás, hogy először elmegyünk Vasluira – egy olyan lépést teszünk, ami a heurisztika szerint a céltól távolabb visz – és aztán elmegyünk Csalánosra, Bukarestre, majd Fogarasra. Ebben az esetben a heurisztika szükségtelen csomópontok kifejtését eredményezi. Továbbá, ha nem ügyelünk arra, hogy felismerjük az ismétlődő állapotokat, akkor soha nem találjuk meg a megoldást – a keresés Neamt és Iaşi között fog oszcillálni.</p><p>A mohó legjobbat-először keresés a mélységi keresésre hasonlít abból a szempontból, hogy egyetlen út végigkövetését preferálja a célig, azonban zsákutcába jutva visszalép. Ugyanazokkal a problémákkal küszködik, mint a mélységi keresés – nem optimális és nem teljes (mert elindulhat egy végtelen úton és soha sem tér vissza újabb lehetőségeket kipróbálni). A mohó keresés legrosszabb esetre számított (worst-case) idő- és tárigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>b<sup>m</sup></em></span>), ahol <span class="emphasis"><em>m</em></span> a keresési tér maximális mélysége. Jól megválasztott heurisztikus függvénnyel a komplexitás azonban jelentősen csökkenthető. A csökkenés mértéke az adott problémától és a heurisztikus függvény minőségétől függ.</p></div><div class="section" title="A* keresés: a teljes becsült útköltség minimalizálása"><div class="titlepage"><div><div><h2 class="title"><a id="id550154"/>A* keresés: a teljes becsült útköltség minimalizálása</h2></div></div></div><p>A legjobbat-először keresés leginkább ismert változata az <span class="bold"><strong>A<sup>*</sup> keresés</strong></span> (a kiejtése ’A csillag’). A csomópontokat úgy értékeli ki, hogy összekombinálja <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>) értékét – az aktuális csomópontig megtett út költsége – és <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) értékét – vagyis az adott csomóponttól a célhoz vezető út költségének becslőjét:</p><p><code class="code"><em><span class="remark">f</span></em>(<em><span class="remark">n</span></em>) = <em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>) + <em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>)</code></p><p>Mivel <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>) megadja a kiinduló csomóponttól az <span class="emphasis"><em>n</em></span> csomópontig számított útköltséget, és <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) az <span class="emphasis"><em>n</em></span> csomóponttól a célcsomópontba vezető legolcsóbb költségű út költségének becslője, így az alábbi összefüggést kapjuk:</p><p><code class="code"><em><span class="remark">f</span></em>(<em><span class="remark">n</span></em>)<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>a legolcsóbb, az <em><span class="remark">n</span></em> csomóponton keresztül vezető megoldás becsült költsége.</code></p><p>Így amennyiben a legolcsóbb megoldást keressük, ésszerű először a legkisebb <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>) + <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) értékkel rendelkező csomópontot kifejteni. Ezen stratégia kellemes tulajdonsága, hogy ez a stratégia több mint ésszerű: amennyiben a <span class="emphasis"><em>h</em></span> függvény eleget tesz bizonyos feltételeknek, az A<sup>*</sup> keresés teljes és optimális.</p><p>Az A<sup>*</sup> optimalitását könnyű elemezni, ha az algoritmust a <code class="code">FA-KERESÉS</code>-sel együtt alkalmazzuk. Ilyenkor A<sup>*</sup> optimális lesz, ha<span class="emphasis"><em> h</em></span>(<span class="emphasis"><em>n</em></span>) egy <span class="strong"><strong>elfogadható heurisztika</strong></span> (<span class="strong"><strong>admissible heuristic</strong></span>), azaz ha <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) <span class="emphasis"><em>soha nem becsüli felül</em></span> a cél eléréséhez szükséges költséget. Az elfogadható heurisztikák természetükből adódóan optimisták, mivel úgy gondolják, hogy a probléma megoldása kisebb költséggel jár, mint amekkora költséget a megoldás valójában igényel. Mivel <span class="emphasis"><em>g</em></span>(<span class="emphasis"><em>n</em></span>) az <span class="emphasis"><em>n</em></span> csomópont elérésének pontos költsége, azonnali következményként adódik, hogy <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) soha sem becsüli túl az <span class="emphasis"><em>n</em></span> csomóponton keresztül vezető legjobb megoldás valódi költségét.</p><a id="ID_140_oldal"/><p>Az elfogadható heurisztikus függvények talán egyik legnyilvánvalóbb példája a Bukarestbe történő utazás során felhasznált <span class="emphasis"><em>h<sub>LMT</sub></em></span> légvonalban mért távolság. A légvonalban mért távolság elfogadható, mert bármely két pont között a legrövidebb távolság a légvonalban mért távolság, így a légvonalbeli táv soha nem becsülhet túl. A 4.3. ábra a Bukarestet kereső A<sup>*</sup> fakeresés előrehaladását mutatja. A <span class="emphasis"><em>g </em></span>értékeket a 3.2. ábrán látható lépésköltségekből számítjuk ki, a <span class="emphasis"><em>h<sub>LMT</sub></em></span> értékei a 4.1. ábrán adottak. </p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Vegyük észre, hogy Bukarest először az (e) lépés peremében jelent meg, azonban kifejtésre nem került, mert Bukarest <span class="emphasis"><em>f</em></span>-értéke (450) magasabb, mint Piteştié (417). Ezt úgy lehetne megmagyarázni, hogy <span class="emphasis"><em>lehet</em></span>, hogy Piteştin keresztül létezik egy 417 költségű olcsó megoldás, így az algoritmus egy 450 költségű megoldást nem fog választani. Ebből a példából megalkothatjuk annak az általános bizonyítását, hogy a <code class="code">FA-KERESÉS</code>-t használó A<sup>*</sup> algoritmus <span class="emphasis"><em>optimális, ha h</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> elfogadható</em></span>. Tegyük fel, hogy a peremen egy <span class="emphasis"><em>G</em></span><sub>2</sub> szuboptimális célcsomópont jelenik meg, és az optimális megoldás költsége legyen C<sup>*</sup>. Így mivel G<sub>2</sub> szuboptimális és h(G<sub>2</sub>) = 0 (ami minden célállapotra igaz), tudjuk, hogy:</p><p><code class="code">f(G<sub>2</sub>) = g(G<sub>2</sub>) + h(G<sub>2</sub>) = g(G<sub>2</sub>) &gt; C<sup>*</sup></code></p></div><p>Gondoljunk most egy perembeli <span class="emphasis"><em>n</em></span> csomópontra, amely a megoldási útvonalon fekszik (ilyennek mindig léteznie kell, ha a megoldás létezik). Ha <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) nem becsüli túl a megoldáshoz vezető út folytatását, akkor tudjuk, hogy:</p><p><code class="code">f(n) = g(n) + h(n) ≤ C<sup>*</sup></code></p><p>Kimutattuk tehát, hogy f(n) ≤ C<sup>*</sup> &lt; f(G<sub>2</sub>), így G<sub>2</sub> nem kerül kifejtésre, és az A* egy optimális megoldással tér vissza.</p><p>A bizonyítás összeomlik, ha a <code class="code">FA-KERESÉS</code> helyett a 3.19. ábra szerinti <code class="code">GRÁF-KERESÉS</code> algoritmust használjuk. Az algoritmus visszatérhet szuboptimális megoldással, mert a <code class="code">GRÁF-KERESÉS</code> algoritmus elvetheti az ismétlődő állapothoz vezető optimális utat, ha az nem elsőnek került kiszámításra (lásd 4.4. feladat). A problémát kétféle módon lehet megoldani. Az első megoldás a <code class="code">GRÁF-KERESÉS</code> olyan kiterjesztése, hogy az az ugyanahhoz a csomóponthoz vezető két út közül a drágábbat fogja elvetni (lásd az értékelést a 3.5. alfejezetben). A pótlólagos adminisztrálás nem egyszerű, de az optimalitást garantálni fogja. A második megoldásnál azt kell biztosítani, hogy a bármelyik ismétlődő csomóponthoz vezető optimális út mindig az, amit az algoritmus elsőnek követ – mint ahogy ez az egyenletes költségű keresésénél volt. Ez a tulajdonság akkor áll fenn, ha a <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) függvényre extra követelményeket fogalmazunk meg, megkövetelve annak <span class="strong"><strong>konzisztenciá</strong></span>ját (<span class="strong"><strong>consistency</strong></span>), másképpen <span class="strong"><strong>monotonitás</strong></span>át (<span class="strong"><strong>monotonicity</strong></span>). A <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) heurisztikus függvény konzisztens, ha minden <span class="emphasis"><em>n</em></span> csomópontra és annak egy tetszőleges <span class="emphasis"><em>a</em></span> cselekvéssel generált minden <span class="emphasis"><em>n</em></span>′ utódcsomópontjára az <span class="emphasis"><em>n</em></span> csomóponttól elért cél becsült költsége nem kisebb, mint az <span class="emphasis"><em>n′ </em></span>-be kerülés lépésköltsége és az <span class="emphasis"><em>n′</em></span> csomóponttól elért cél becsült költsége:</p><p><code class="code"><em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>) ≤ <em><span class="remark">c</span></em>(<em><span class="remark">n</span></em>, <em><span class="remark">a</span></em>, <em><span class="remark">n′</span></em>) + <em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>′)</code></p><p>Ez az általános <span class="strong"><strong>háromszög egyenlőtlenség</strong></span> (<span class="strong"><strong>triangle inequality</strong></span>) egy formája, amely azt fejezi ki, hogy egy háromszög egy oldala sem lehet hosszabb, mint a két másik oldal összege. Itt a háromszöget az <span class="emphasis"><em>n</em></span>, az <span class="emphasis"><em>n</em></span>′ és az <span class="emphasis"><em>n</em></span>-hez legközebbi cél határozza meg. Könnyű megmutatni (4.7. feladat), hogy minden konzisztens heurisztika egyben elfogadható is. </p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A konzisztencia legfontosabb következménye az, hogy: <span class="emphasis"><em>a </em></span><code class="code">GRÁF-KERESÉS</code><span class="emphasis"><em>-t használó A<sup>*</sup> algoritmus optimális, ha h</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> konzisztens</em></span>.</p></div><div class="figure"><a id="id552612"/><p class="title"><strong>4.3. ábra - Az A* keresés lépései Bukarest keresése során. A csomópontok az <span class="emphasis"><em>f</em></span> = <span class="emphasis"><em>g</em></span> + <span class="emphasis"><em>h</em></span> értékekkel vannak felcímkézve. A <span class="emphasis"><em>h</em></span>-értékek a Bukaresttől légvonalban mért távolságokat jelölik, melyeket a 4.1. ábrából vettünk át.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-03.png" alt="Az A* keresés lépései Bukarest keresése során. A csomópontok az f = g + h értékekkel vannak felcímkézve. A h-értékek a Bukaresttől légvonalban mért távolságokat jelölik, melyeket a 4.1. ábrából vettünk át."/></div></div></div><a id="ID_142_oldal"/><p>Bár a konzisztencia az elfogadhatóságnál szigorúbb követelmény, igazán nehéz olyan elfogadható heurisztikát találni, ami nem lenne egyben konzisztens. Az ebben a fejezetben tárgyalt összes elfogadható heurisztika mind konzisztens. Vegyük például a <span class="emphasis"><em>h<sub>LMT</sub></em></span>-t. Tudjuk, hogy az általános háromszög egyenlőtlenség teljesül, ha az oldalakat egyenes vonalú távolságokkal mérjük, és hogy az <span class="emphasis"><em>n</em></span> és <span class="emphasis"><em>n</em></span>′ közötti egyenesvonalú távolság <span class="emphasis"><em>c</em></span>(<span class="emphasis"><em>n</em></span>, <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>n</em></span>′)-nél nem nagyobb. A <span class="emphasis"><em>h<sub>LMT</sub></em></span> így egy konzisztens heurisztika.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A konzisztencia egy másik fontos következménye az, hogy <span class="emphasis"><em>ha h</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> konzisztens, akkor az f</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> értékek akármilyen út mentén nem csökkennek</em></span>. A bizonyítás bizonyos <span class="emphasis"><em>a</em></span> mellett közvetlenül következik a konzisztencia definíciójából. Tegyük fel, hogy <span class="emphasis"><em>n</em></span>′ az <span class="emphasis"><em>n</em></span> utódja, ekkor: </p><p><code class="code"><em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>′) = <em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>) + <em><span class="remark">c</span></em>(<em><span class="remark">n</span></em>, <em><span class="remark">a</span></em>, <em><span class="remark">n</span></em>′)</code></p><p>és</p><p><code class="code"><em><span class="remark">f</span></em>(<em><span class="remark">n</span></em>′) = <em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>′) + <em><span class="remark">h</span></em>(<em><span class="remark">n′</span></em>) = <em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>) + <em><span class="remark">c</span></em>(<em><span class="remark">n</span></em>, <em><span class="remark">a</span></em>, <em><span class="remark">n</span></em>′) + <em><span class="remark">h</span></em>(<em><span class="remark">n′</span></em>) ≥ <em><span class="remark">g</span></em>(<em><span class="remark">n</span></em>) + <em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>) = <em><span class="remark">f </span></em>(<em><span class="remark">n</span></em>)</code></p></div><p>A <code class="code">GRÁF-KERESÉS</code>-t használó A<sup>*</sup> algoritmus által kifejtett csomópontok sorozata tehát <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>)-ben nem csökkenő. A kifejtésre választott első célcsomópont így egy optimális megoldás is egyben, mert minden utána következő csomópont legalább ilyen költséges lenne.</p><p>Ha az <span class="emphasis"><em>f</em></span>-költségek sohasem csökkenek, bármilyen utat választunk, akkor az állapottérben <span class="strong"><strong>határvonal</strong></span>akat (<span class="strong"><strong>contour</strong></span>) húzhatunk be, hasonlóan egy topografikus térkép kontúrjaihoz. A 4.4. ábra erre mutat egy példát. A 400-zal felcímkézett határvonalon belül az összes csomópont <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) értéke nem nagyobb 400-nál, és hasonló érvényes a többire is. Mivel az A<sup>*</sup> keresési algoritmus a legkisebb <span class="emphasis"><em>f</em></span> értékkel rendelkező levélcsomópontot fejti ki először, láthatjuk, hogy az A<sup>*</sup> keresési algoritmus a gyökércsomópontból legyezőszerűen halad kifelé, növekvő <span class="emphasis"><em>f</em></span> értékekhez tartozó koncentrikus sávokban hozzáadva a csomópontokat.</p><p>Az egyenletes költségű keresés esetén (A<sup>*</sup> keresés <span class="emphasis"><em>h </em></span>= 0 mellett) a csomópontsávok a kiinduló csomópont köré húzott koncentrikus „köröket” alkotnak. Pontosabb heurisztikus függvény alkalmazásával a sávok a célállapot felé elnyúlnak, és keskenyebben fókuszálódnak az optimális út körül. Ha <span class="emphasis"><em>C</em></span><sup>*</sup> az optimális megoldási út költségét jelöli, akkor az alábbiakat jelenthetjük ki:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az A<sup>*</sup> keresési algoritmus kifejti az összes <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> </em></span>&lt;<span class="emphasis"><em> C</em></span><sup>*</sup><span class="emphasis"><em> </em></span>értékkel rendelkező csomópontot.</p></li><li class="listitem"><p class="List Paragraph">Ezek után az A<sup>*</sup> keresési algoritmus egy célcsomópont kiválasztása előtt még kifejthet néhány csomópontot a „célhatárvonalon”, amelyekre <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> </em></span>=<span class="emphasis"><em> C</em></span><sup>*</sup>.</p></li></ul></div><p>Intuitíven nyilvánvaló, hogy az első megtalált megoldásnak optimális megoldásnak kell lennie, hiszen a következő határvonalakon az összes csomóponthoz nagyobb <span class="emphasis"><em>f</em></span> költség, ebből adódóan nagyobb <span class="emphasis"><em>g</em></span> költség tartozik (mivel minden célállapotra <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>)<span class="emphasis"><em> </em></span>=<span class="emphasis"><em> </em></span>0). Intuitíven az is nyilvánvaló, hogy az A<sup>*</sup> keresési algoritmus teljes. Ahogy egyre növekvő <span class="emphasis"><em>f</em></span> értékű sávokat adunk a kereséshez, előbb-utóbb elérünk egy sávot, amelyhez tartozó <span class="emphasis"><em>f</em></span> érték megegyezik egy célállapothoz vezető út költségével.<sup>[<a id="id552976" href="#ftn.id552976" class="footnote">36</a>]</sup></p><div class="figure"><a id="id552990"/><p class="title"><strong>4.4. ábra - Románia térképe. Az ábra Arad mint kiinduló állapot esetén az <span class="emphasis"><em>f</em></span> = 380, <span class="emphasis"><em>f</em></span> = 400 és <span class="emphasis"><em>f</em></span> = 420 értékekhez tartozó határvonalat mutatja. Egy adott határvonalon belüli csomópontokhoz a határvonal értékénél kisebb <span class="emphasis"><em>f</em></span> költség tartozik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-04.png" alt="Románia térképe. Az ábra Arad mint kiinduló állapot esetén az f = 380, f = 400 és f = 420 értékekhez tartozó határvonalat mutatja. Egy adott határvonalon belüli csomópontokhoz a határvonal értékénél kisebb f költség tartozik."/></div></div></div><p>Vegyük észre, hogy az A<sup>*</sup> nem fejt ki <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) &gt;<span class="emphasis"><em> C</em></span><sup>*</sup> tulajdonságú csomópontokat. A 4.3. ábrán például Temesvár nem kerül kifejtésre annak ellenére, hogy ez a gyökérnek egy utódcsomópontja. Azt mondjuk, hogy a Temesvár alatti fát <span class="strong"><strong>lenyestük</strong></span> (<span class="strong"><strong>pruned</strong></span>). Mivel <span class="emphasis"><em>h<sub>LMT</sub></em></span> elfogadható, az algoritmus biztonságosan figyelmen kívül hagyhat egy ilyen fát, miközben az optimalitást garantálja. A nyesés gondolata – a lehetőségek eliminálása anélkül, hogy megvizsgálnánk azokat – igen fontos az MI sok területén. </p><p>Egy végső észrevétel, az ilyen típusú – a gyökérből kiinduló utakat bővítő – optimális algoritmusok közül az A<sup>*</sup> keresési algoritmus bármely adott heurisztikus függvény mellett <span class="strong"><strong>optimális hatékonyságú</strong></span> (<span class="strong"><strong>optimally efficient</strong></span>). Ez azt jelenti, hogy egyetlen más optimális algoritmus sem fejt ki garantáltan kevesebb csomópontot, mint az A<sup>*</sup> (kivéve talán az <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) = <span class="emphasis"><em>C</em></span><sup>*</sup> típusú csomópontok körét, ahol holtverseny alakulhat ki). Ez azért van, mert az összes olyan algoritmus, amelyik <span class="emphasis"><em>nem</em></span> fejti ki az összes csomópontot, melyre <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>n</em></span>) &lt; <span class="emphasis"><em>C</em></span><sup>*,</sup> kockáztatja az optimális megoldás elkerülését.</p><p>Felettébb örömteli hír számunkra, hogy az A<sup>*</sup> keresési algoritmus teljes, optimális és az összes ilyen jellegű algoritmus között optimálisan hatékony. Sajnos ez azonban nem jelenti azt, hogy az A<sup>*</sup> algoritmus megoldja az összes kereséssel kapcsolatos problémánkat. A buktató a dologban az, hogy a legtöbb probléma esetén a csomópontok száma a keresési tér célhatárvonalon belüli részén a megoldás hosszának még mindig exponenciális függvénye. Bár az eredmény bizonyítása túlmutat ezen könyv keretein, megmutatható, hogy az exponenciális növekedéssel mindenképp szembe kell néznünk, kivéve, ha a heurisztikus függvényünk hibája legfeljebb az aktuális útköltség logaritmusával nő. Az exponenciálisnál lassabb növekedés feltétele matematikai megfogalmazásban:</p><p><code class="code">|<em><span class="remark">h</span></em>(<em><span class="remark">n</span></em>)<em><span class="remark"> – h<sup>*</sup></span></em>(<em><span class="remark">n</span></em>)| ≤<em><span class="remark"> O</span></em>(log <em><span class="remark">h<sup>*</sup></span></em>(<em><span class="remark">n</span></em>))</code></p><p>ahol <span class="emphasis"><em>h<sup>*</sup></em></span>(<span class="emphasis"><em>n</em></span>) az <span class="emphasis"><em>n</em></span> csomópontból a célcsomópontba való eljutás <span class="emphasis"><em>valódi</em></span> költségét jelöli. Majdnem minden, a gyakorlatban használt heurisztikus függvény esetén a hiba legalább arányos az útköltséggel, és az ebből adódó exponenciális növekedéssel egyetlen számítógép sem tud megbirkózni. Ezért ahhoz ragaszkodni, hogy egy optimális megoldást találjunk, gyakran nem is praktikus. Használhatjuk az A<sup>*</sup> olyan változatát, amely a szuboptimális megoldásokat gyorsan megtalálja, vagy pedig dolgozhatunk pontosabb, de nem elfogadható heurisztikákkal. Egy jól megválasztott heurisztikus függvény ettől függetlenül a nem informált keresési algoritmusokhoz képest jelentős megtakarítást eredményezhet. A 4.2. alfejezetben megvizsgáljuk, hogy hogyan is lehet jó heurisztikus függvényt tervezni.</p><p>Az A<sup>*</sup> algoritmusnak azonban nem a szükséges számítási idő a nagy problémája. Mivel az összes legenerált csomópontot a memóriában tárolja (ahogy ezt az összes <code class="code">GRÁF-KERESÉS</code> algoritmus teszi), ezért az algoritmus általában lényegesen hamarabb felemészti a rendelkezésére álló memóriát, mintsem kifutna az időből. Ezért az A<sup>*</sup> sok nagyméretű problémához nem praktikus. A közelmúltban kifejlesztett algoritmusok a végrehajtási idő kismértékű növekedése mellett a memóriaproblémát megoldották, anélkül hogy feláldoznák az optimalitást vagy a teljességet. Ezekkel az algoritmusokkal fogunk most foglalkozni.</p></div><div class="section" title="Memóriakorlátozott heurisztikus keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id553177"/>Memóriakorlátozott heurisztikus keresés</h2></div></div></div><p>Az A<sup>*</sup> memóriaigényének mérséklésére a legegyszerűbb módszer az iteratívan mélyülő algoritmus adaptálása heurisztikus keresés környezetre. Ennek eredménye az <span class="bold"><strong>iteratívan mélyülő A<sup>*</sup> algoritmus</strong></span> – <span class="bold"><strong>IMA<sup>*</sup></strong></span> – (<span class="bold"><strong>iterative deepening A<sup>*</sup></strong></span>, <span class="bold"><strong>IDA<sup>*</sup></strong></span>). Az IMA<sup>*</sup> és a közönséges iteratívan mélyülő algoritmus közötti fő különbség az, hogy a vágási mechanizmus nem a mélységen, hanem az <span class="emphasis"><em>f </em></span>költségen (<span class="emphasis"><em>g</em></span> + <span class="emphasis"><em>h</em></span>) alapul. Ezáltal minden egyes iterációban a vágási érték az a legkisebb <span class="emphasis"><em>f </em></span>költség, ami az előbbi iterációban használt vágási értéknél nagyobb. Az IMA<sup>*</sup> praktikus megoldás számos olyan probléma esetén, ahol egységnyi a lépésköltség és elkerüli a rendezett csomópontsor memóriában való tartásának jelentős overheadjét. Sajnos, az IMA<sup>*</sup> algoritmus a valós értékű költségektől ugyanúgy szenved, mint az egyenletes költségű keresés iteratív változata, amit a 3.11. feladatban írtunk le. Ebben a fejezetben megvizsgálunk a memóriakorlátozott algoritmusok köréből két frissebb ötletet – az RLEK-t és az MA<sup>*</sup>-t.</p><p>A <span class="strong"><strong>rekurzív legjobbat-először keresés</strong></span>, az <span class="strong"><strong>RLEK</strong></span> (<span class="strong"><strong>recursive best-first search</strong></span>, <span class="strong"><strong>RBFS</strong></span>) egy egyszerű rekurzív algoritmus, amely megkísérli a rendes legjobbat-először algoritmus működését mímelni, de csak lineáris tárat használva. Az algoritmust a 4.5. ábra<span class="emphasis"><em> </em></span>mutatja. A struktúrája hasonlít a rekurzív mélységi keresésre, azonban ahelyett, hogy az algoritmus egy utat a végtelenségig folytatna az aktuális pálya mentén, figyeli az aktuális csomóponthoz az elődeitől vezető eddigi legjobb alternatív út <span class="emphasis"><em>f</em></span>-értékét. Ha az aktuális csomópont ezt az értéket túlhaladja, a rekurzió az alternatív útra lép vissza. Ahogy a rekurzió visszalép, az RLEK minden csomópont <span class="emphasis"><em>f</em></span>-értékét a pálya mentén a gyerekeinek legjobb <span class="emphasis"><em>f</em></span>-értékével helyettesíti. Ily módon az RLEK emlékszik a legjobb levélértékre az elfelejtett alfában, és eldöntheti, vajon érdemes-e ezt a fát valamikor később újra kifejteni. A 4.6. ábra azt mutatja, hogy hogyan éri el Bukarestet az RLEK.</p><p>Az RLEK valamivel hatékonyabb, mint az IMA<sup>*</sup>, azonban még mindig túlságosan szenved a csomópontok túlzott újbóli generálása miatt. A 4.6. ábrán látható példában az RLEK először a Rimnicu Vilceán átmenő utat követi, majd „meggondolja magát” és Fogarassal kísérletezik, majd újra meggondolja magát. Ezek a meggondolások azért történnek meg, mert amikor az aktuális legjobb utat tovább fejtjük, nagy az esély arra, hogy az <span class="emphasis"><em>f</em></span>-érték nőni fog – <span class="emphasis"><em>h</em></span> általában kevésbé optimista a célhoz közeli csomópontok esetén. Amikor ez megtörténik, különösképpen nagy keresési terekben, a második legjobb út a legjobb úttá válhat, és a keresésnek vissza kell lépnie, hogy ezt az utat tudja követni. Minden meggondolás megfelel az IMA<sup>* </sup>egy-egy iterációjának és az elfelejtett csomópontok számos újbóli kifejtését teszi szükségessé, hogy a keresés képes legyen a legjobb utat visszaállítani, és azt egy csomóponttal meghosszabbítani.</p><div class="figure"><a id="id553298"/><p class="title"><strong>4.5. ábra - A rekurzív legjobbat-először keresés algoritmusa</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-05.png" alt="A rekurzív legjobbat-először keresés algoritmusa"/></div></div></div><p>Az A<sup>*</sup>-hoz hasonlóan az RLEK is optimális algoritmus, feltéve, hogy a <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) heurisztikus függvény elfogadható. Tárkomplexitása <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bd</em></span>), az időkomplexitását azonban nehezebb meghatározni. Ez függ a heurisztika pontosságától és attól is, mennyire gyakran változik a csomópontok kifejtése közben a legjobb út. Mind az IMA<sup>*</sup>, mind az RLEK elvileg ki vannak téve a gráfokban való kereséssel kapcsolatos exponenciális komplexitásnövekedésnek (lásd 3.5. alfejezet), tekintettel arra, hogy az ismétlődő állapotok jelenlétét csak az aktuális úton képesek ellenőrizni. Előfordulhat így, hogy ugyanazt az állapotot többször is kifejtik.</p><p>Az IMA<sup>*</sup>-nak és az RLEK-nek az a baja, hogy <span class="emphasis"><em>túl kevés</em></span> memóriát használ. Az egyes iterációk között az IMA<sup>*</sup> egyetlen számot, az aktuális <span class="emphasis"><em>f</em></span>-költség korlátot tárolja el. Az RLEK több információt tárol el a memóriában, azonban csak <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>bd</em></span>) memóriát használ. Még ha több memória is állna a rendelkezésére, az RLEK-nek nincs módja ezt kihasználni.</p><p>Ésszerűnek tűnik tehát az összes, rendelkezésre álló memóriát használni. Az erre képes két algoritmus az <span class="bold"><strong>MA<sup>*</sup></strong></span> (<span class="bold"><strong>memóriakorlátozott A<sup>*</sup></strong></span>) és az <span class="bold"><strong>EMA<sup>*</sup></strong></span> (<span class="strong"><strong>egyszerűsí</strong></span><span class="bold"><strong>tett MA<sup>*</sup></strong></span>). Itt az EMA<sup>*</sup>-t írjuk le, ami – mitagadás – az egyszerűbb. Az EMA<sup>* </sup>az A<sup>* </sup>módjára halad a legjobb levelet kifejtve, amíg a memória be nem telik. Ezen a ponton a keresési fához új csomópontot hozzáadni nem képes, hacsak egy régit nem töröl ki. Az EMA<sup>* </sup>mindig a <span class="emphasis"><em>legrosszabb</em></span> – a legmagasabb <span class="emphasis"><em>f</em></span>-értékű – csomópontot hagyja ki. Majd, mint az RLEK, az elfelejtett csomópont értékét a szülőjéhez továbbítja. Ily módon egy elfelejtett részfa elődje tudja a részfa legjobb útjának az értékét. Ezzel az információval az EMA<sup>* </sup>csak akkor fejti ki újra a fát, ha kimutatta, hogy <span class="emphasis"><em>minden más út</em></span> rosszabbnak tűnik, mint az elfelejtett út. Más szóval, ha az <span class="emphasis"><em>n</em></span> csomópont minden utódját elfelejtjük, nem tudjuk, hogy <span class="emphasis"><em>n</em></span>-ből merrefelé lehetne menni, tudni fogjuk azonban, hogy mennyire érdemes egyáltalán bárhová is menni az <span class="emphasis"><em>n</em></span>-ből kiindulva.</p><div class="figure"><a id="id553430"/><p class="title"><strong>4.6. ábra - Az RLEK lépései, miközben a legrövidebb utat keresi Bukarest felé. A mindenkori rekurzív hívás <span class="emphasis"><em>f</em></span>-korlát<span class="emphasis"><em> </em></span>értéke a mindenkori aktuális csomópont felett látható. (a) A Rimnicu Vilceán át vezető utat az algoritmus addig követi, amíg az aktuális legjobb levél (Piteşti) értéke nem lesz rosszabb, mint a legjobb alternatív út értéke (Fogaras). (b) A rekurzió visszalép és az elfelejtett alfa legjobb levélértékét (417) Rimnicu Vilceánál feljegyezzük. Majd Fogaras kifejtése következik 450-nel, mint a legjobb levélértékkel. (c) A rekurzió visszalép. Az elfelejtett alfa legjobb levélértékét (450) Fogarasnál jegyezzük fel. Következik Rimnicu Vilcea kifejtése. Ezúttal, mivel a legjobb alternatív út (Temesváron keresztül) 447-be kerül, a kifejtés folytatódik Bukarest felé.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/04-06.png" alt="Az RLEK lépései, miközben a legrövidebb utat keresi Bukarest felé. A mindenkori rekurzív hívás f-korlát értéke a mindenkori aktuális csomópont felett látható. (a) A Rimnicu Vilceán át vezető utat az algoritmus addig követi, amíg az aktuális legjobb levél (Piteşti) értéke nem lesz rosszabb, mint a legjobb alternatív út értéke (Fogaras). (b) A rekurzió visszalép és az elfelejtett alfa legjobb levélértékét (417) Rimnicu Vilceánál feljegyezzük. Majd Fogaras kifejtése következik 450-nel, mint a legjobb levélértékkel. (c) A rekurzió visszalép. Az elfelejtett alfa legjobb levélértékét (450) Fogarasnál jegyezzük fel. Következik Rimnicu Vilcea kifejtése. Ezúttal, mivel a legjobb alternatív út (Temesváron keresztül) 447-be kerül, a kifejtés folytatódik Bukarest felé."/></div></div></div><p>A teljes algoritmus túlságosan bonyolult, hogy itt írjunk róla,<sup>[<a id="id553450" href="#ftn.id553450" class="footnote">37</a>]</sup> azonban egy finom vonását érdemes megemlíteni. Azt mondtuk, hogy az EMA<sup>* </sup>a legjobb levelet fejti ki és a legrosszabb levelet felejti el. Mi van akkor, ha <span class="emphasis"><em>minden</em></span> levélnek ugyanaz az <span class="emphasis"><em>f</em></span>-értéke? Az algoritmus ekkor ugyanazt a csomópontot kifejtésre is, és elhagyásra is kiválaszthatná. Az EMA<sup>* </sup>ezt a problémát úgy oldja meg, hogy a kifejtésre a <span class="emphasis"><em>legújabb</em></span> csomópontot választja, és a <span class="emphasis"><em>legrégebbi</em></span> csomópontot törli. Ez a kettő ugyanaz a csomópont csak akkor lehet, ha csak egy levél van. Ebben az esetben az aktuális keresési fa egyetlen útból áll a gyökértől a levélig, ami kitölti a teljes memóriát. Ha a levél nem egy célcsomópont, akkor<span class="emphasis"><em> még ha a célhoz vezető optimális úton fekszik is</em></span>, ez a cél az adott memóriával nem érhető el. Következésképpen a csomópontot ugyanúgy el lehet dobni, mintha nem is lenne követője.</p><p>Az EMA<sup>*</sup> teljes, ha van egyáltalán elérhető megoldás – azaz ha <span class="emphasis"><em>D</em></span>, a legsekélyebb célcsomópont mélysége kevesebb, mint a memória nagysága (csomópontokban kifejezve). Optimális, ha van elérhető optimális megoldás, másképpen az algoritmus a legjobb elérhető megoldással tér vissza. Gyakorlatilag az EMA<sup>*</sup>-t messze a legjobb általánosan használatos algoritmusnak lehet tekinteni az optimális megoldások megkeresésére, különösképpen ha az állapottér egy gráf, a lépésköltség nem egyenletes, és a csomópontkifejtés drága a nyitott és zárt listák karbantartásának pótlólagos overheadjéhez képest. </p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Nagyon nehéz problémák esetén azonban az EMA<sup>*</sup> sokszor kénytelen folyamatosan oda-vissza kapcsolgatni a lehetséges megoldási utak között, amelyekből csak kevés fér be a memóriába (hasonló ez a diszkalapú memória lapozó rendszer <span class="strong"><strong>vergődés</strong></span>i (<span class="strong"><strong>thrashing</strong></span>) problémájára). Az ugyanazon csomópontok ismételt újrakifejtéséhez szükséges extra idő azt jelenti, hogy azok a problémák, amelyeket a végtelen memóriájú A<sup>*</sup> gyakorlatilag meg tudna oldani, az EMA<sup>*</sup> számára kezelhetetlenek. Ez azt jelenti, hogy <span class="emphasis"><em>memóriakorlát a problémát a számítási idő szempontjából kezelhetetlenné teheti. </em></span>Bár a memória és az idő közötti kompromisszum magyarázatára nincs elmélet, úgy tűnik, hogy ettől a problémától megmenekülni nem lehet. Egyetlen kiút elvetni az optimalitás követelményét.</p></div></div><div class="section" title="Tanuljunk, hogy jobban keressünk!"><div class="titlepage"><div><div><h2 class="title"><a id="id553522"/>Tanuljunk, hogy jobban keressünk!</h2></div></div></div><p>Az eddigiekben néhány rögzített stratégiát mutattunk be – szélességi, mohó legjobbat-először stb. keresés –, amelyeket számítógépes szakemberek terveztek. Meg tudná-e <span class="emphasis"><em>tanulni</em></span> egy ágens, hogy jobban keressen? A válasz igen, és a módszer alapját egy fontos fogalom, a <span class="strong"><strong>metaszintű állapottér</strong></span> (<span class="strong"><strong>metalevel state space</strong></span>) adja. A metaszintű állapottér minden állapota az <span class="strong"><strong>objektumszintű állapottér</strong></span>beli (<span class="strong"><strong>object-level state space</strong></span>) – amilyen például Románia – keresőprogram egy belső (számítási) állapotának felel meg. Az A<sup>*</sup> algoritmus belső állapota például az aktuális keresési fa. A metaszintű állapottér minden cselekvése egy számítási lépés, amely a belső állapotot változtatja meg. Az A<sup>*</sup> esetén például minden számítási lépés kifejt egy levelet, és a követőit a fához adja hozzá. A 4.3. ábra, amely az egyre növekvő keresési fák sorozatát mutatja, értelmezhető lehetne úgy, hogy a metaszintű állapottérben egy utat mutat, ahol az út minden állapota egy objektumszintű keresési fa.</p><p>A 4.3. ábrán az út öt lépésből áll, Fogaras kifejtését is beleszámítva, ami nem volt valami hasznos. Nehezebb problémák esetén sok ilyen téves lépésre lehet számítani, és a <span class="strong"><strong>metaszintű tanulási algoritmus</strong></span> (<span class="strong"><strong>metalevel learning</strong></span>) ilyen tapasztalatokból tanulhat, hogy elkerülje a haszontalan részfák kifejtését. Az ilyen tanuláshoz alkalmas módszereket a 21. fejezetben tárgyaljuk. A tanulás célja a problémamegoldás <span class="strong"><strong>totális költség</strong></span>ének (<span class="strong"><strong>total cost</strong></span>) a minimalizálása, kompromisszumot kötve a számítási kiadások és az útköltség között.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id549902" href="#id549902" class="para">33</a>] </sup> A 4.3. feladatban azt kérjük Öntől, hogy mutassa ki, hogy ez a család néhány jól ismert nem informált keresést is tartalmaz.</p></div><div class="footnote"><p><sup>[<a id="ftn.id549919" href="#id549919" class="para">34</a>] </sup> A <span class="emphasis"><em>h</em></span>(<span class="emphasis"><em>n</em></span>) heurisztikus függvény bemenete ugyan egy <span class="emphasis"><em>csomópont</em></span>, a függvény értéke azonban a csomóponthoz tartozó <span class="emphasis"><em>állapottól</em></span> függ.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id549985" href="#id549985" class="para">35</a>] </sup> A könyv első kiadásában ennek <span class="strong"><strong>mohó keresés</strong></span> (<span class="strong"><strong>greedy search</strong></span>) volt a neve. Más szerzők ezt <span class="strong"><strong>legjobbat-először </strong></span><span class="strong"><strong>keresés</strong></span>nek (<span class="strong"><strong>best-first search</strong></span>) nevezik. A második változat általunk választott általánosabb használata Pearlt (Pearl, 1984) követi.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id552976" href="#id552976" class="para">36</a>] </sup> A teljesség megkívánja, hogy a <span class="emphasis"><em>C</em></span><sup>*</sup> költségnél kisebb vagy azzal egyenlő költségű csomópontokból véges sok legyen. Ez a feltétel akkor lesz igaz, ha minden lépésköltség egy véges ε-nál nagyobb és <span class="emphasis"><em>b</em></span> véges.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id553450" href="#id553450" class="para">37</a>] </sup> Az algoritmus vázlatos leírása a könyv első kiadásában megtalálható.</p></div></div></div></body></html>
