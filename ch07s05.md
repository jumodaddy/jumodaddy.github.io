<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Hatékony ítéletkalkulus következtetés"><div class="titlepage"><div><div><h1 class="title"><a id="id586840"/>Hatékony ítéletkalkulus következtetés</h1></div></div></div><p class="2">Ebben a szakaszban az ítéletkalkulus következtetés két hatékony családját írjuk le, amelyek a modellellenőrzésen alapulnak: az egyik megközelítés a visszalépéses keresésen alapul, a másik a hegymászó keresésen. Ezek az algoritmusok az ítéletkalkulus „technológiájának” részei. Ez a szakasz átlapozható a fejezet első olvasásakor. </p><p>Az algoritmusok, amelyeket leírunk, a kielégíthetőséget ellenőrzik. Már megfigyeltük a kapcsolatot egy logikai mondatot kielégítő modell megtalálása és egy kényszerkielégítési probléma megoldásának megtalálása között, így talán nem meglepő, hogy a két algoritmus család igen hasonlít az 5.2. alfejezetben bemutatott visszalépéses algoritmusokra és az 5.3. alfejezet lokális keresési algoritmusaira. Ezek az algoritmusok azonban rendkívül fontosak saját maguk jogán is, mert számos kombinatorikai probléma a számítástechnikában visszavezethető egy ítéletkalkulus mondat kielégíthetőségének ellenőrzésére. A kielégíthetőségi algoritmusok terén elért bármilyen haladás általánosságban is óriási hatással van a képességeinkre a komplexitás kezelésében.</p><div class="section" title="Egy teljes visszalépéses algoritmus"><div class="titlepage"><div><div><h2 class="title"><a id="id586850"/>Egy teljes visszalépéses algoritmus</h2></div></div></div><p class="3">Az első algoritmus, amit megnézünk Martin Davis és Hilary Putnam (1960) jelentős konferenciacikke alapján, az úgynevezett <span class="strong"><strong>Davis–Putnam-algoritmus</strong></span>. Ez az algoritmus valójában egy változata annak, amelyet Davis, Logemann és Loveland (1962) publikált, így DPLL-nek fogjuk hívni szerzőik neveinek kezdőbetűi alapján. A DPLL bemenetként egy konjunktív normál formájú mondatot vesz – a klózok egy halmazát. Mint a <code class="code">VISSSZALÉPÉSES-KERESÉS</code> vagy az <code class="code">IK-VONZAT</code>?, ez is alapvetően rekurzív, mélységi felsorolását végzi a lehetséges modelleknek. Az algoritmus három továbbfejlesztést tartalmaz az <code class="code">IK-VONZAT</code>? egyszerű sémájához képest:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Korai leállás:</em></span> Az algoritmus észreveszi, ha egy mondat már biztos igaz vagy hamis, még részben elkészült modell alapján is. Egy klóz igaz, ha <span class="emphasis"><em>bármelyik</em></span> literál igaz, még akkor is, ha a többi literálnak még nincs igazság értéke. Ennélfogva a mondatot mint egészet igaznak ítélhetjük, még mielőtt a modell teljes volna. Például az (<span class="emphasis"><em>A</em></span> ∨ <span class="emphasis"><em>B</em></span>) ∧ (<span class="emphasis"><em>A</em></span> ∨ <span class="emphasis"><em>C</em></span>) igaz, ha <span class="emphasis"><em>A</em></span> igaz, függetlenül <span class="emphasis"><em>B</em></span> és <span class="emphasis"><em>C</em></span> értékétől. Hasonlóan, egy mondat hamis, ha <span class="emphasis"><em>bármelyik</em></span> klóz hamis, ami akkor fordul elő, ha ennek a klóznak minden literálja hamis. Ismételten, ez a modell teljessé válásánál sokkal korábban is előfordulhat. A korai leállás a keresési tér egész részfáinak átvizsgálását kerüli el.</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Tiszta szimbólum heurisztika:</em></span> Egy <span class="strong"><strong>tiszta szimbólum</strong></span> (<span class="strong"><strong>pure symbol</strong></span>) egy olyan szimbólum, amely mindig ugyanolyan „előjellel” szerepel minden klózban. Például a következő három mondatban, (<span class="emphasis"><em>A </em></span>∨ ¬<span class="emphasis"><em>B</em></span>), (¬<span class="emphasis"><em>B </em></span>∨ ¬<span class="emphasis"><em>C</em></span>) és az <span class="emphasis"><em>A</em></span> szimbólum tiszta, mivel csak a pozitív literálja jelenik meg, a <span class="emphasis"><em>B</em></span> tiszta, mivel csak a negatív literálja jelenik meg, és <span class="emphasis"><em>C</em></span> nem tiszta. Könnyű belátni, hogyha egy mondatnak van modellje, akkor létezik tiszta szimbólumokat tartalmazó modellje is, amelyben a tiszta szimbólumok értéke úgy van megválasztva, hogy literáljai <span class="emphasis"><em>igazak</em></span> legyenek, hiszen így egyetlen klózt sem teszünk hamissá. Vegyük észre, hogy egy szimbólum tisztaság tulajdonságának meghatározásakor az algoritmus figyelmen kívül hagyhatja azokat a klózokat, amelyekről már tudjuk, hogy igazak a modell eddigi konstruálása alapján. Például ha a modellünk tartalmazza a <span class="emphasis"><em>B </em></span>= <span class="emphasis"><em>hamis</em></span> hozzárendelést, akkor a (¬<span class="emphasis"><em>B </em></span>∨ ¬<span class="emphasis"><em>C</em></span>) klóz már igaz, és <span class="emphasis"><em>C</em></span> tisztává válik, mert csak a (<span class="emphasis"><em>C</em></span> ∨ <span class="emphasis"><em>A</em></span>)-ban jelenik meg.</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Egységklóz heurisztika:</em></span> Az <span class="strong"><strong>egységklóz</strong></span>t már definiáltuk korábban, mint egy olyan klózt, amelynek egy literálja van. A DPLL esetében, ez azokat a klózokat is jelenti, hogy egy kivételével minden literál <span class="emphasis"><em>hamis</em></span> értéket kapott a modellben. Például ha a modell tartalmazza a <span class="emphasis"><em>B</em></span> = <span class="emphasis"><em>hamis</em></span> hozzárendelést, akkor a (<span class="emphasis"><em>B</em></span> ∨ ¬<span class="emphasis"><em>C</em></span>) egység klózzá válik, mivel ekvivalens a (<span class="emphasis"><em>Hamis</em></span> ∨ ¬<span class="emphasis"><em>C</em></span>)-vel, azaz a ¬<span class="emphasis"><em>C</em></span>-vel. Természetesen ahhoz, hogy ez a klóz igaz legyen, <span class="emphasis"><em>C</em></span>-nek <span class="emphasis"><em>hamis</em></span> értéket kell adni. Az egységklóz heurisztika elvégzi ezeket a hozzárendeléseket, mielőtt elágazna a maradékon. Egy fontos konzekvenciája ennek a heurisztikának, hogy bármely, már a tudásbázisban található literálra vonatkozó (cáfolat általi) bizonyítási kísérlet azonnal sikeres lesz (7.16. feladat). Vegyük észre azt is, hogy értéket adva egy egységklózhoz újabb egységklózt hozhatunk létre. Például amikor <span class="emphasis"><em>C</em></span>-nek <span class="emphasis"><em>hamis</em></span> értéket adunk, akkor a (<span class="emphasis"><em>C </em></span>∨ <span class="emphasis"><em>A</em></span>) egységklózzá válik, ami az igaz <span class="emphasis"><em>A</em></span>-hoz való hozzárendelését eredményezi. Ezt az „egymást követő” kikényszerített hozzárendelések sorozatát <span class="strong"><strong>egységterjesztés</strong></span>nek (<span class="strong"><strong>unit propagation</strong></span>) nevezik. Hasonlít a folyamat a Horn-klózokkal történő előrefelé láncolásra, és valóban, abban az esetben ha a CNF formájú kifejezés csak Horn-klózokat tartalmaz, akkor a DPLL lényegében lemásolja az előrefelé láncolást (lásd 7.17. feladat).</p></li></ul></div><div class="figure"><a id="id587066"/><p class="title"><strong>7.16. ábra - A DPLL algoritmus ítéletkalkulus mondatok kielégíthetőségének ellenőrzése. A <code class="code">TISZTA-SZIMBÓLUM-KERESÉS</code> és az <code class="code">EGYSÉG-KLÓZ-KERESÉS </code>eljárásokat a szövegben elmagyaráztuk; mindkettő egy szimbólummal vagy nullával tér vissza, és a szimbólumhoz hozzárendelendő igazságértékkel. Mint az <code class="code">IT-VONZAT</code>? eljárás, ez is részleges modelleken dolgozik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-16.png" alt="A DPLL algoritmus ítéletkalkulus mondatok kielégíthetőségének ellenőrzése. A TISZTA-SZIMBÓLUM-KERESÉS és az EGYSÉG-KLÓZ-KERESÉS eljárásokat a szövegben elmagyaráztuk; mindkettő egy szimbólummal vagy nullával tér vissza, és a szimbólumhoz hozzárendelendő igazságértékkel. Mint az IT-VONZAT? eljárás, ez is részleges modelleken dolgozik."/></div></div></div><p>A DPLL algoritmust mutatja a 7.16. ábra. Az ábrán a lényeges elemeket tartalmazó vázat adtuk meg, ami bemutatja magát a keresési folyamatot. Nem szerepel az adatstruktúra leírása, amelyet fenn kell tartani, hogy a keresési lépéseket hatékonyan lehessen elvégezni, sem azoknak a trükköknek a leírása, amelyeket a teljesítmény fokozása céljából az alapalgoritmushoz hozzá lehet adni: klóztanulás, változó választási heurisztika és a véletlenszerű újraindítások technikája. Ha ezeket is beépítjük az algoritmusba, akkor a DPLL az egyik leggyorsabb kielégíthetőségi algoritmus, antikvitása ellenére is. A <code class="code">CHAFF</code> implementáció millió változós hardververifikációs problémák megoldására szolgált.</p></div><div class="section" title="Lokális keresés algoritmus"><div class="titlepage"><div><div><h2 class="title"><a id="id587092"/>Lokális keresés algoritmus</h2></div></div></div><a id="ID_278_oldal"/><p class="3">Számos lokális keresés algoritmust láttunk már a könyvben, beleértve a <code class="code">HEGYMÁSZÓ</code> algoritmust <a class="xref" href="ch04s03.md#ID_155_oldal">„Hegymászó keresés”</a> részben és a <code class="code">SZIMULÁLT-LEHŰTÉS</code>-t <a class="xref" href="ch04s03.md#ID_158_oldal">„Szimulált lehűtés”</a> részben. Ezek az algoritmusok alkalmazhatók közvetlenül is kielégíthetőségi problémákra, feltéve, hogy megfelelő kiértékelő függvényt választunk. Mivel a cél egy olyan hozzárendelés megtalálása, amely kielégít minden klózt, megfelel számunkra egy olyan kiértékelő függvény választása, amely a kielégítetlen klózok számát számolja. Valóban, ez pontosan az a mérték, amit a <code class="code">MIN-KONFLIKTUS</code> algoritmus használt kényszerkielégítési problémáknál <a class="xref" href="ch05s03.md#ID_197_oldal">„Lokális keresés kényszerkielégítési problémáknál”</a> részben. Minden ilyen algoritmus a teljes hozzárendelések terében végez lépéseket, cserélgetve egy-egy lépésben egy-egy szimbólum igazságértékét. A tér rendszerint számos lokális minimumot tartalmaz, amelyekből a meneküléshez a véletlenszerű lépések különféle formái szükségesek. Az utóbbi években nagyon sokat foglalkoztak azzal a kérdéssel, hogy hogyan lehet egy jó egyensúlyt találni a mohóság és a véletlenszerűség között.</p><p>Az egyik legegyszerűbb és leghatékonyabb algoritmus, amely ezen munkák között felbukkant a <code class="code">WALKSAT</code> (7.17. ábra). Minden iterációban az algoritmus vesz egy kielégítetlen klózt és egy szimbólumot a klózból, amelynek értékét ellenkezőre cseréli. Az értéket cserélő szimbólum kiválasztása a következő két módszer közül – véletlenszerűen választva – az egyikkel történik: (1) a „min-konfliktus” lépés, amely minimalizálja a kielégítetlen klózokat az új állapotban, és a (2) „véletlen-bejárás”, amely véletlenszerűen választja a szimbólumot.</p><div class="figure"><a id="id587131"/><p class="title"><strong>7.17. ábra - A <code class="code">WALKSAT</code> algoritmus, kielégíthetőségének ellenőrzése véletlenszerűen cserélgetetett változó értékekkel. Számos változata ismert az algoritmusnak.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-17.png" alt="A WALKSAT algoritmus, kielégíthetőségének ellenőrzése véletlenszerűen cserélgetetett változó értékekkel. Számos változata ismert az algoritmusnak."/></div></div></div><p class="Képalá">Működik-e egyáltalán a <code class="code">WALKSAT</code>? Az egyértelmű, hogy ha visszaad egy modellt, akkor a bemeneti mondat valóban kielégíthető. Mi van akkor, ha <span class="emphasis"><em>kudarccal</em></span> tér vissza? Sajnos ebben az esetben nem tudjuk megmondani, hogy a mondat kielégíthetetlen vagy az algoritmus számára több időt kellene hagyni a keresésre. Megpróbálhatjuk beállítani a <span class="emphasis"><em>max_csere</em></span> értékét végtelenre. Erre az esetre könnyű megmutatni, hogy a <code class="code">WALKSAT</code> végül vissza fog adni egy modellt (ha létezik ilyen), feltéve, hogy a <span class="emphasis"><em>p</em></span> valószínűségre igaz a <span class="emphasis"><em>p</em></span> &gt; 0. Ez azért van így, mert mindig létezik egy olyan cserélési sorozat, amely elvezet egy kielégítő hozzárendeléshez, és előbb-utóbb a véletlen bejárás lépések elő fogják állítani ezt a sorozatot. Persze ha a <span class="emphasis"><em>max_csere</em></span> végtelen, és a mondat kielégíthetetlen, akkor az algoritmus soha nem fog leállni!</p><p>Ezek az eredmények azt sugallják, hogy a lokális keresési algoritmusok, mint a <code class="code">WALKSAT</code>, akkor a leginkább hasznosak, ha feltételezhetjük, hogy létezik megoldás – mint például a 3. és 5. fejezetben tárgyalt problémáknak általában van megoldásuk. Viszont a lokális keresés nem képes detektálni a <span class="emphasis"><em>kielégíthetetlenséget,</em></span> amely szükséges a maga után vonzás kérdésének az eldöntéséhez. Például egy lokális keresést alkalmazó ágens nem tudja <span class="emphasis"><em>megbízhatóan </em></span>bizonyítani, hogy egy négyzet biztonságos a wumpus világban. Ehelyett azt tudja mondani, hogy „Egy órája gondolkodom a kérdésen, és nem tudtam olyan lehetséges világot találni, amiben a négyzet nem biztonságos.” Ha a lokális keresés algoritmus általában igazán gyors egy modell megtalálásában, ha létezik ilyen, akkor az ágenst tekinthetjük igazolhatónak, feltételezve, hogy a kudarc a kielégíthetetlenséget jelzi. Ez természetesen nem azonos egy bizonyítással, és az ágensnek kétszer is meg kell gondolnia, mielőtt erre bízza az életét. </p></div><div class="section" title="Nehéz kielégíthetőségi problémák"><div class="titlepage"><div><div><h2 class="title"><a id="id587186"/>Nehéz kielégíthetőségi problémák</h2></div></div></div><p class="3">Most megnézzük, hogyan is teljesít a DPLL és a <code class="code">WALKSAT</code> a gyakorlatban. Minket elsősorban a <span class="emphasis"><em>nehéz</em></span> problémák érdekelnek, mert a <span class="emphasis"><em>könnyű</em></span> problémák megoldhatóak bármely régi algoritmussal is. Az 5. fejezetben láttunk néhány meglepő felfedezést bizonyosfajta problémákkal kapcsolatban. Például az <span class="emphasis"><em>n</em></span>-királynő probléma – amely igen kemény feladat volt a visszalépéses keresés számára – triviálisan egyszerűnek bizonyult az olyan lokális keresési módszerek számára, mint például a min-konfliktus. Ennek az az oka, hogy a megoldások nagyon sűrűn oszlanak el a hozzárendelések terében, és bármely kezdeti hozzárendeléshez garantáltan találhatunk egy megoldást a közelben. Tehát az <span class="emphasis"><em>n</em></span>-királynő könnyű probléma, mert <span class="strong"><strong>alulhatározott</strong></span> (<span class="strong"><strong>underconstrained</strong></span>). </p><p>Amikor konjunktív normál formában levő kielégíthetőségi problémákat tekintünk, alulhatározott probléma az, amelyben viszonylag kevés a változókat korlátozó klóz szerepel. Például itt van egy véletlenszerűen létrehozott<sup>[<a id="id587223" href="#ftn.id587223" class="footnote">71</a>]</sup> 3-CNF mondat öt szimbólummal és öt klózzal:</p><p><code class="code">(¬<em><span class="remark">D</span></em> ∨ ¬<em><span class="remark">B</span></em> ∨ <em><span class="remark">C</span></em>) ∧ (<em><span class="remark">B</span></em> ∨ ¬<em><span class="remark">A</span></em> ∨ ¬<em><span class="remark">C</span></em>) ∧ (¬<em><span class="remark">C</span></em> ∨ ¬<em><span class="remark">B</span></em> ∨ <em><span class="remark">E</span></em>) ∧ (<em><span class="remark">E</span></em> ∨ ¬<em><span class="remark">D</span></em> ∨ <em><span class="remark">B</span></em>) ∧ (<em><span class="remark">B</span></em> ∨ <em><span class="remark">E</span></em> ∨ ¬<em><span class="remark">C</span></em>)</code></p><p>A 32 lehetséges hozzárendelésből 16 modellje a mondatnak, így átlagosan csak két véletlenszerű találgatásra van szükség egy modell megtalálásához. </p><p>Akkor melyek a nehéz problémák? Feltételezhető, hogyha <span class="emphasis"><em>növeljük</em></span> a klózok számát, miközben a szimbólumok számát rögzítve tartjuk, a problémát erősebben határozottá tesszük, és a megoldás megtalálása egyre nehezebbé válik. Legyen <span class="emphasis"><em>m</em></span> a klózok száma és <span class="emphasis"><em>n</em></span> a szimbólumok száma. A 7.18. (a) ábra mutatja annak a valószínűségét, hogy egy véletlenszerűen választott 3-CNF mondat kielégíthető-e a klóz/szimbólum arány (<span class="emphasis"><em>m</em></span>/<span class="emphasis"><em>n</em></span>) függvényében rögzített <span class="emphasis"><em>n </em></span>= 50 mellett. Ahogy vártuk, kis <span class="emphasis"><em>m</em></span>/<span class="emphasis"><em>n</em></span> aránynál a valószínűség közel van 1-hez, és nagy <span class="emphasis"><em>m</em></span>/<span class="emphasis"><em>n</em></span> aránynál közel van a 0-hoz. A valószínűség viszonylag élesen esik le az <span class="emphasis"><em>m</em></span>/<span class="emphasis"><em>n</em></span> =<span class="emphasis"><em> </em></span>4,3 értéknél. Azok a CNF mondatok, amelyek közel vannak ehhez a <span class="strong"><strong>kritikus pont</strong></span>hoz (<span class="strong"><strong>critical point</strong></span>), „alig kielégíthetőnek” vagy „alig kielégíthetetlennek” jellemezhetők. Ez volna az, ahol a nehéz problémák vannak?</p><p>A 7.18. (b) ábra mutatja a DPLL és a <code class="code">WALKSAT</code> futási időit ennek a pontnak a környezetében, csak a kielégíthető problémákat véve figyelembe. Három dolog tiszta: először is, a kritikus pont körüli problémák <span class="emphasis"><em>sokkal</em></span> nehezebbek, mint a többi probléma. Másodszor, a DPLL igen hatékony még a legnehezebb problémákra is – átlagosan néhány ezer lépést tesz, összehasonlítva az igazságtábla felsorolás 2<sup>50</sup> ≈ 10<sup>15</sup> számú lépésigényével. Harmadszor, a <code class="code">WALKSAT</code> a teljes tartományban sokkal gyorsabb, mint a DPLL.</p><p>Természetesen ezek az eredmények csak a véletlenszerűen generált problémákra vonatkoznak. A valós problémáknak nem feltétlenül hasonló a struktúrájuk – a pozitív és negatív állítások aránya, a klózok közti kapcsolatok sűrűsége, és egyéb más vonatkozások – mint a véletlen problémáknak. Mégis, a gyakorlatban a <code class="code">WALKSAT</code> és az ehhez kapcsolódó, hasonló algoritmusok nagyon jók valós problémák megoldásában is – gyakran ugyanolyan jók, mint az adott feladatra készített legjobb speciális célú algoritmus. Több ezer szimbólumot és milliónyi klózt tartalmazó problémákat megoldókkal szokás kezelni, mint amilyen a <code class="code">CHAFF</code>. Ezek a megfigyelések azt sugallják, hogy a min-konfliktus és a véletlen bejárás algoritmusok valamilyen kombinációja <span class="emphasis"><em>általános célú</em></span> képességet biztosít a legtöbb szituáció elemzéséhez, ahol kombinatorikai következtetés szükséges. </p><div class="figure"><a id="id587383"/><p class="title"><strong>7.18. ábra - (a) A grafikon a klóz/szimbólum arány függvényében annak valószínűségét mutatja, hogy <span class="emphasis"><em>n</em></span> = 50 mondat közül véletlenszerűen választott 3-CNF mondat kielégíthető-e. (b) A grafikon a DPLL és a <code class="code">WALKSAT</code> algoritmusok futási időinek középértékét mutatja 100 <span class="emphasis"><em>kielégíthető</em></span> 3-CNF mondaton <span class="emphasis"><em>n</em></span> = 50 mellett, a kritikus<span class="emphasis"><em> m</em></span>/<span class="emphasis"><em>n</em></span> arány melletti szűk sávban.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-18.png" alt="(a) A grafikon a klóz/szimbólum arány függvényében annak valószínűségét mutatja, hogy n = 50 mondat közül véletlenszerűen választott 3-CNF mondat kielégíthető-e. (b) A grafikon a DPLL és a WALKSAT algoritmusok futási időinek középértékét mutatja 100 kielégíthető 3-CNF mondaton n = 50 mellett, a kritikus m/n arány melletti szűk sávban."/></div></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id587223" href="#id587223" class="para">71</a>] </sup> Minden klóz három véletlenszerűen kiválasztott szimbólumot tartalmaz, amelyek 50% valószínűséggel negáltak.</p></div></div></div></body></html>
