<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Rezolúció"><div class="titlepage"><div><div><h1 class="title"><a id="id610493"/>Rezolúció</h1></div></div></div><p>A logikai rendszerek általunk bemutatandó három családjának az utolsó tagja a <span class="strong"><strong>rezolúció</strong></span>n (<span class="strong"><strong>resolution</strong></span>) alapul. Láttuk a 7. fejezetben, hogy a propozíciós rezolúció egy cáfolásteljes következtetési folyamat az ítéletlogikában. Ebben az alfejezetben meg fogjuk vizsgálni, hogyan lehet kiterjeszteni a rezolúciót az elsőrendű logikára.</p><p>A teljes bizonyítási eljárás létezésének kérdése a matematikusokat érdekli közvetlenül. Ha egy teljes bizonyítási eljárás megtalálható matematikai állításokra, ebből két dolog következik. Először is, az összes tétel előfeltételeit mechanikusan elő tudjuk állítani; másodszor, a teljes matematika felépíthető alapaxiómák halmazának logikai következményeként. A teljesség kérdésének vizsgálata így a 20. századi matematika néhány legfontosabb eredményének a megszületéséhez vezetett. 1930-ban Kurt Gödel német matematikus bebizonyította az első <span class="strong"><strong>teljességi tétel</strong></span>t (<span class="strong"><strong>completeness theor</strong></span><span class="strong"><strong>em</strong></span>) az elsőrendű logikára, megmutatva, hogy minden kikövetkeztetett mondatnak létezik véges bizonyítása. (Gyakorlatban is felhasználható bizonyítási módszert viszont nem találtak egészen addig, amíg J. A. Robinson nem publikálta a rezolúciós algoritmust 1965-ben.) 1931-ben Gödel bebizonyította a még híresebb <span class="strong"><strong>nemteljességi tétel</strong></span>t (<span class="strong"><strong>incompleteness theorem</strong></span>). A tétel kimondja, hogy egy logikai rendszer, amely tartalmazza az indukció elvét – amely nélkül a diszkrét matematika igen kis része építhető fel – szükségszerűen nem teljes. Ebből az következik, hogy léteznek olyan kikövetkeztetett mondatok, amelyeknek a rendszeren belül nincs véges bizonyítása. Lehet, hogy a tű ott van a metaforikus szénakazalban, de nincs olyan eljárás, amely garantálná, hogy megtaláljuk.</p><p>Gödel tétele ellenére, a rezolúcióalapú tételbizonyításokat széles körben alkalmazták matematikai tételek levezetésére, beleértve néhány olyan tételt is, amelyre előzőleg nem volt ismert bizonyítás. A tételbizonyításokat – más alkalmazások mellett – használták például hardvertervezés verifikálására vagy logikailag helyes programok generálására.</p><div class="section" title="Az elsőrendű logika konjunktív normál formája"><div class="titlepage"><div><div><h2 class="title"><a id="id610536"/>Az elsőrendű logika konjunktív normál formája</h2></div></div></div><p>Mint az ítéletlogika esetében, az elsőrendű rezolúció is megköveteli, hogy a mondatok <span class="strong"><strong>konjunktív normál formá</strong></span>ban (<span class="strong"><strong>conjunctive normal form</strong></span>) (<span class="strong"><strong>CNF</strong></span>) legyenek, tehát minden mondat klózok konjunkciója, ahol minden egyes klózt literálok diszjunkciója alkot.<sup>[<a id="id610556" href="#ftn.id610556" class="footnote">92</a>]</sup> A literálok tartalmazhatnak változókat, amelyeket univerzális kvantorral ellátottnak feltételezünk. Például a </p><p><code class="code">∀<em><span class="remark">x Amerikai</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Elad</span></em>(<em><span class="remark">x, y, z</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Ellenséges</span></em>(<em><span class="remark">z</span></em>) ⇒<em><span class="remark"> Bűnöző</span></em>(<em><span class="remark">x</span></em>)</code></p><p>mondat CNF-formára átalakítva ilyen lesz:</p><p><code class="code">¬<em><span class="remark">Amerikai</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∨ ¬<em><span class="remark">Fegyver</span></em>(<em><span class="remark">y</span></em>)  ∨ ¬<em><span class="remark">Elad</span></em>(<em><span class="remark">x, y, z</span></em>)  ∨ ¬<em><span class="remark">Ellenséges</span></em>(<em><span class="remark">z</span></em>)  ∨<em><span class="remark"> Bűnöző</span></em>(<em><span class="remark">x</span></em>)</code></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p><span class="emphasis"><em>Minden elsőrendű logikai mondat átalakítható a következtetés szempontjából egyenértékű CNF-mondattá. </em></span>Ami azt jelenti, hogy egy CNF-mondat akkor kielégíthetetlen, ha az eredeti mondat is kielégíthetetlen, ezáltal a CNF-mondatok között ellentmondásokat keresve létre tudunk hozni bizonyításokat.</p></div><p>A CNF-mondatok átalakításának eljárása nagyon hasonló az ítéletlogikai eljáráshoz, amelyet a <a class="xref" href="ch07s04.md#ID_269_oldal">„Konjunktív normál forma”</a>részben láthatunk. A legfontosabb különbség abból fakad, hogy ki kell vonnunk a mondatokból az egzisztenciális kvantorokat. Ezt az eljárást a következő mondat lefordításával illusztráljuk: „Mindenkit, aki az összes állatot szereti, valaki szeret”, vagyis:</p><p><code class="code">∀<em><span class="remark">x  </span></em>[∀<em><span class="remark">y  Állat</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>⇒ <em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)]<em><span class="remark"> </span></em>⇒ [∃<em><span class="remark">y  Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p>A lépések a következők:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az implikációk eliminálása.</p></li></ul></div><p><code class="code">	∀<em><span class="remark">x </span></em>[¬∀<em><span class="remark">y  </span></em>¬<em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∨<em><span class="remark"> Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ∨ [∃<em><span class="remark">y  Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>A ¬befelé mozgatása. </strong></span>A negált összekötőjelekre vonatkozó már ismert szabályok mellett szükségünk van a negált kvantorokra vonatkozó szabályokra is. Így ezt kapjuk:</p></li></ul></div><p><code class="code">	¬∀<em><span class="remark">x  p</span></em>-ből lesz ∃<em><span class="remark">x  </span></em>¬<em><span class="remark">p</span></em></code></p><p><code class="code">	¬∃<em><span class="remark">x  p</span></em>-ből lesz ∀<em><span class="remark">x  </span></em>¬<em><span class="remark">p</span></em></code></p><p>A mondatunk a következő átalakításokon megy keresztül:</p><p><code class="code">	∀<em><span class="remark">x  </span></em>[∃<em><span class="remark">y  </span></em>¬(¬<em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∨<em><span class="remark"> Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>))] ∨ [∃<em><span class="remark">y  Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p><code class="code">	∀<em><span class="remark">x  </span></em>[∃<em><span class="remark">y  </span></em>¬ ¬<em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>) ∧  ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ∨ [∃<em><span class="remark">y  Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p><code class="code">	∀<em><span class="remark">x  </span></em>[∃<em><span class="remark">y </span></em> <em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>) ∧ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ∨ [∃<em><span class="remark">y  Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p>	Figyeljük meg, hogyan alakítottuk át az univerzális kvantort (∀<span class="emphasis"><em>y</em></span>) az implikáció premisszájában egzisztenciális kvantorrá. A mondatot most így lehet kiolvasni „Vagy van olyan állat, amelyet <span class="emphasis"><em>x </em></span>nem szeret, vagy (ha ez nem áll fenn) valaki szereti <span class="emphasis"><em>x</em></span>-et.” Világos, hogy az eredeti mondat jelentését megőriztük.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>A változók átnevezése. </strong></span>Az olyan mondatokban, mint a (∀<span class="emphasis"><em>x </em></span> <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>)) ∨ (∃<span class="emphasis"><em>x </em></span> <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>x</em></span>)), amelyek ugyanazt a változó nevet kétszer is használják, változtassuk meg az egyik változó nevét. Ezzel elkerüljük, hogy később keveredés lehessen, amikor elhagyjuk a kvantorokat. Így ezt kapjuk:</p></li></ul></div><p><code class="code">	∀<em><span class="remark">x  </span></em>[∃<em><span class="remark">y</span></em>  <em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>) ∧ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ∨ [∃<em><span class="remark">z  Szereti</span></em>(<em><span class="remark">z</span></em>,<em><span class="remark"> x</span></em>)]</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Skolemizáció. </strong></span>A<span class="strong"><strong> skolemizáció</strong></span> (<span class="strong"><strong>skolemization</strong></span>) az az eljárás, amelynek során eliminációval eltávolítjuk az egzisztenciális kvantorokat. Egyszerű esetben ez megegyezik a 9.1. alfejezetben található egzisztenciális példányosítási szabállyal: fordítsuk le a ∃<span class="emphasis"><em>x  P</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em>-</em></span>et <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>)<span class="emphasis"><em>-</em></span>ra, ahol az <span class="emphasis"><em>A </em></span>egy új konstans. Ha ezt a szabályt alkalmazzuk a mintamondatunkra, akkor azonban ezt kapjuk:</p></li></ul></div><p><code class="code">	∀<em><span class="remark">x  </span></em>[<em><span class="remark">Állat</span></em>(<em><span class="remark">A</span></em>) ∧ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> A</span></em>)] ∨<em><span class="remark"> Szereti</span></em>(<em><span class="remark">B</span></em>,<em><span class="remark"> x</span></em>)</code></p><p>	amelynek teljesen téves a jelentése: azt mondja ki, hogy mindenki vagy nem tud szeretni egy bizonyos <span class="emphasis"><em>A</em></span> állatot, vagy egy bizonyos <span class="emphasis"><em>B </em></span>entitás szereti őt. Valójában, az eredeti mondatunk lehetővé teszi minden egyes személy számára, hogy ne szeressen egy másik állatot, vagy egy másik személy szeresse őt. Így tehát, azt szeretnénk, hogy a Skolem entitások az <span class="emphasis"><em>x-</em></span>től függjenek:</p><p><code class="code">	∀<em><span class="remark">x  </span></em>[<em><span class="remark">Állat</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>)) ∧ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> F</span></em>(<em><span class="remark">x</span></em>))] ∨<em><span class="remark"> Szereti</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>),<em><span class="remark"> x</span></em>)</code></p><p>	Itt az <span class="emphasis"><em>F </em></span>és a <span class="emphasis"><em>G </em></span><span class="strong"><strong>Skolem-függvény</strong></span>ek<span class="strong"><strong>.</strong></span> Az általános szabály az, hogy a Skolem-függvények argumentumai mind univerzális kvantorral ellátott változók, amelyeknek a hatókörében az egzisztenciális kvantor értelmezett. Hasonlóan az Egzisztenciális Példányosításhoz, a skolemizált mondat is pontosan akkor kielégíthető, ha az eredeti mondat is kielégíthető.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Az univerzális kvantorok elhagyása. </strong></span>Ezen a ponton minden megmaradt változó univerzális kvantorral van ellátva. Mi több, a mondat egyenértékű azzal a mondattal, amelyben az összes univerzális kvantort balra rendezték. Így tehát most már elhagyhatjuk az univerzális kvantorokat:</p></li></ul></div><p><code class="code">	[<em><span class="remark">Állat</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>)) ∧ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> F</span></em>(<em><span class="remark">x</span></em>))] ∨ <em><span class="remark">Szereti</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>),<em><span class="remark"> x</span></em>)</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Az </strong></span>∧ <span class="strong"><strong>elosztása a </strong></span>∨ <span class="strong"><strong>felett.</strong></span></p></li></ul></div><p>	[<span class="emphasis"><em>Állat</em></span>(<span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>x</em></span>)) ∨ <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>),<span class="emphasis"><em> x</em></span>)] ∧ [ ¬<span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> F</em></span>(<span class="emphasis"><em>x</em></span>)) ∨ <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>),<span class="emphasis"><em> x</em></span>)]</p><p>	Ennek a lépésnek az elvégzéséhez szükség lehet az egymásba ágyazott konjunkciók és diszjunkciók kibontására is.</p><p>A mondat most CNF formájú, és két klózból áll. Eléggé olvashatatlan lett. (Némiképpen segíthet, ha megmagyarázzuk, hogy az <span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>függvény egy, az <span class="emphasis"><em>x </em></span>személy által potenciálisan nem szeretett állatra vonatkozik, míg a <span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>olyan valakire utal, aki szeretheti <span class="emphasis"><em>x</em></span>-et.) Szerencsére, nekünk ritkán kell CNF-mondatokat vizsgálnunk – a fordítási folyamat könnyen automatizálható.</p></div><div class="section" title="A rezolúciós következtetési szabály"><div class="titlepage"><div><div><h2 class="title"><a id="id611356"/>A rezolúciós következtetési szabály</h2></div></div></div><p>Az elsőrendű klózokra vonatkozó következtetési szabály egyszerűen a <a class="xref" href="ch07s04.md#ID_268_oldal">„Rezolúció”</a> részben megadott propozíciós rezolúciós szabály kiterjesztett változata. Két klóz, amelyek standardizálva vannak, tehát nem tartalmaznak azonos változókat, akkor rezolválható, ha tartalmaznak komplememens literálokat. Az ítéletlogikai literálok akkor komplemensek, ha az egyik a negációja a másiknak; míg az elsőrendű literálok akkor komplemensek, ha az egyik <span class="emphasis"><em>egyesül </em></span>a másik negációjával. Így ezt kapjuk:</p><p><span class="inlinemediaobject"><img src="math/mi-09-0004.gif" alt="A rezolúciós következtetési szabály"/></span></p><p>ahol az <code class="code">EGYESÍT</code> (<span class="emphasis"><em>l<sub>i</sub></em></span>, ¬<span class="emphasis"><em>m<sub>j</sub></em></span>) = <span class="emphasis"><em>θ</em></span>. Például rezolválhatjuk ezt a két klózt:</p><p><code class="code">[<em><span class="remark">Állat</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>)) ∨ <em><span class="remark">Szereti</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>), (<em><span class="remark">x</span></em>)] és [¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">u</span></em>,<em><span class="remark"> v</span></em>) ∨  ¬<em><span class="remark">Megöli</span></em>(<em><span class="remark">u</span></em>,<em><span class="remark"> v</span></em>)]</code></p><p>a <span class="emphasis"><em>θ </em></span>=<span class="emphasis"><em> </em></span>{<span class="emphasis"><em>u</em></span>/<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>),<span class="emphasis"><em> v</em></span>/<span class="emphasis"><em>x</em></span>} egyesítő felhasználásával a komplemens literálokat, a <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>),<span class="emphasis"><em> x</em></span>)-t<span class="emphasis"><em> </em></span>és a ¬<span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>u</em></span>,<span class="emphasis"><em> v</em></span>)-t<span class="emphasis"><em> </em></span>eliminálva kapjuk meg a <span class="strong"><strong>rezolvens</strong></span> (<span class="strong"><strong>resolvent</strong></span>) klózt:</p><p><code class="code">[<em><span class="remark">Állat</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>)) ∨ ¬<em><span class="remark">Megöli</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>),<em><span class="remark"> x</span></em>)]</code></p><p>A bemutatott szabály neve <span class="strong"><strong>bináris rezolúció</strong></span>s (<span class="strong"><strong>binary resolution</strong></span>) szabály, mert pontosan két literált old fel. A bináris rezolúciós szabály önmagában nem eredményez egy teljes következtetési folyamatot. A teljes rezolúciós szabály literálok részhalmazait rezolválja minden egyes egyesíthető klózban. Egy alternatív megközelítés a <span class="strong"><strong>faktorálás</strong></span>nak (<span class="strong"><strong>factoring</strong></span>), a felesleges literálok eltávolításának a kiterjesztése az elsőrendű logikára. A propozíciós faktorálás két literált eggyé redukál, ha azok <span class="emphasis"><em>azonosak. </em></span>Az elsőrendű faktorálás két literált eggyé redukál, ha azok <span class="emphasis"><em>egyesíthetők. </em></span>Az egyesítőt a teljes klózra kell alkalmazni. A bináris rezolúció és a faktorálás kombinációja már teljes eljárást eredményez.</p></div><div class="section" title="Példabizonyítások"><div class="titlepage"><div><div><h2 class="title"><a id="id611576"/>Példabizonyítások</h2></div></div></div><p>A rezolúció a <span class="emphasis"><em>TB </em></span>⊨ <span class="emphasis"><em>α</em></span> állítást úgy igazolja, hogy bebizonyítja, hogy a <span class="emphasis"><em>TB </em></span>∧ ¬α nem kielégíthető, vagyis a bizonyítás az üres klóz származtatásával történik. Az algoritmikus megközelítés megegyezik az ítéletlogikában lévővel, amelyet a 7.12. ábrán már bemutattunk, így ezt itt most nem ismételjük meg. Ehelyett inkább két példabizonyítást adunk meg. Az első a bűntény példa a 9.3. alfejezetből. A mondatok CNF-ben a következők:</p><p><code class="code">¬<em><span class="remark">Amerikai</span></em>(<em><span class="remark">x</span></em>) ∨  ¬<em><span class="remark">Fegyver</span></em>(<em><span class="remark">y</span></em>) ∨ ¬<em><span class="remark">Elad</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>) ∨ ¬<em><span class="remark">Ellenséges</span></em>(<em><span class="remark">z</span></em>) ∨ <em><span class="remark">Bűnöző</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code">¬<em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ∨ ¬<em><span class="remark">Birtokol</span></em>(<em><span class="remark">Nono</span></em>, <em><span class="remark">x</span></em>) ∨ <em><span class="remark">Elad</span></em>(<em><span class="remark">West</span></em>, <em><span class="remark">x</span></em>, <em><span class="remark">Nono</span></em>)</code></p><p><code class="code">¬<em><span class="remark">Ellenség</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> Amerika</span></em>) ∨ <em><span class="remark">Ellenséges</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code">¬<em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ∨ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Birtokol</span></em>(<em><span class="remark">Nono</span></em>,<em><span class="remark"> M</span></em><sub>1</sub>)<em><span class="remark">       Rakéta</span></em>(<em><span class="remark">M</span></em><sub>1</sub>)</code></p><p><code class="code"><em><span class="remark">Amerikai</span></em>(<em><span class="remark">West</span></em>)<em><span class="remark">             Ellenség</span></em>(<em><span class="remark">Nono</span></em>,<em><span class="remark"> Amerika</span></em>)</code></p><p>Hozzáadjuk a mondatok halmazához a negált célt is ¬<span class="emphasis"><em>Bűnöző</em></span>(<span class="emphasis"><em>West</em></span>)<span class="emphasis"><em>. </em></span>A rezolúciós bizonyítást a 9.11. ábra mutatja be. Figyeljük meg a szerkezetét: a bizonyításnak egy egyszerű „gerince” van, amely a célklózzal kezdődik, és folyamatosan rezolvál a tudásbázisból származó klózokkal, mindaddig, amíg az üres klózt nem generálja. Ez jellemző a Horn-klózokat tartalmazó tudásbázisokon végzett rezolúcióra. Valójában a fő gerinc mentén található klózok <span class="emphasis"><em>pontosan </em></span>megfelelnek a 9.6. ábrán látható hátrafelé láncolási algoritmusban<span class="emphasis"><em> a célváltozók </em></span>egymást követő értékeinek. Ez azért van így, mert mindig azt a klózt választjuk ki rezolválásra, amelynek a pozitív literálja egyesíthető a gerincen lévő „aktuális” klóz bal szélen elhelyezkedő literáljával, és pontosan ez történik a hátrafelé láncolásban is. Így tehát a hátrafelé láncolás valójában a rezolúció egy speciális esete, egy különleges vezérlési stratégiával, amely meghatározza, hogy melyik rezolúciót hajtsuk végre legközelebb. </p><div class="figure"><a id="id612835"/><p class="title"><strong>9.11. ábra - Egy rezolúciós bizonyítás arra, hogy West bűnöző</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-11.png" alt="Egy rezolúciós bizonyítás arra, hogy West bűnöző"/></div></div></div><p>A második példánk kihasználja a skolemizációt, és nem határozott klózokat is tartalmaz. Ez valamivel bonyolultabb bizonyítási struktúrát eredményez. Természetes nyelven megfogalmazva a probléma a következő:</p><p><span class="strong"><strong>Mindenkit, aki az összes állatot szereti, szeret valaki.</strong></span></p><p><span class="strong"><strong>Bárkit, aki megöl egy állatot, senki sem szeret.</strong></span></p><p><span class="strong"><strong>Jankó szereti az összes állatot.</strong></span></p><p><span class="strong"><strong>Vagy Jankó, vagy a Kíváncsiság ölte meg a macskát, akinek a neve Tuna.</strong></span></p><p><span class="strong"><strong>A Kíváncsiság ölte meg a macskát?</strong></span></p><p>Először is leírjuk az eredeti mondatokat, némi háttértudást, és a G negált célt az elsőrendű logikában:</p><p><code class="code">   A.	∀<em><span class="remark">x </span></em>[∀<em><span class="remark">y Állat</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>⇒ <em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ⇒ [∃<em><span class="remark">y Szereti</span></em>(<em><span class="remark">y</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p><code class="code">   B.	∀<em><span class="remark">x </span></em>[∃<em><span class="remark">y Állat</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∧ <em><span class="remark">Megöli</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)] ⇒ [∀<em><span class="remark">z </span></em>¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">z</span></em>,<em><span class="remark"> x</span></em>)]</code></p><p><code class="code">   C.	∀<em><span class="remark">x Állat</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>⇒ <em><span class="remark">Szereti</span></em>(<em><span class="remark">Jankó</span></em>,<em><span class="remark"> x</span></em>)</code></p><p><code class="code">   D.	<em><span class="remark">Megöli</span></em>(<em><span class="remark">Jankó</span></em>,<em><span class="remark"> Tuna</span></em>)<em><span class="remark"> </span></em>∨ <em><span class="remark">Megöli</span></em>(<em><span class="remark">Kíváncsiság</span></em>,<em><span class="remark"> Tuna</span></em>)</code></p><p><code class="code">   E.	<em><span class="remark">Macska</span></em>(<em><span class="remark">Tuna</span></em>)</code></p><p><code class="code">   F.	∀<em><span class="remark">x Macska</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>⇒ <em><span class="remark">Állat</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code">G.	¬<em><span class="remark">Megöli</span></em>(<em><span class="remark">Kíváncsiság</span></em>,<em><span class="remark"> Tuna</span></em>)</code></p><p>Most pedig alkalmazzuk az átalakítási procedúrát, hogy minden egyes mondatot CNF-be konvertáljunk:</p><p><code class="code">  A1.	<em><span class="remark">Állat</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>))<em><span class="remark"> </span></em>∨ <em><span class="remark">Szereti</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>),<em><span class="remark"> x</span></em>)</code></p><p><code class="code">  A2.	¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> F</span></em>(<em><span class="remark">x</span></em>))  ∨ <em><span class="remark">Szereti</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">x</span></em>),<em><span class="remark"> x</span></em>)</code></p><p><code class="code">  B.	¬<em><span class="remark">Állat</span></em>(<em><span class="remark">y</span></em>)  ∨ ¬<em><span class="remark">Megöli</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)<em><span class="remark"> </span></em>∨ ¬<em><span class="remark">Szereti</span></em>(<em><span class="remark">z</span></em>,<em><span class="remark"> x</span></em>)</code></p><p><code class="code">  C.	¬<em><span class="remark">Állat</span></em>(<em><span class="remark">x</span></em>) ∨ <em><span class="remark">Szereti</span></em>(<em><span class="remark">Jankó</span></em>,<em><span class="remark"> x</span></em>)</code></p><p><code class="code">   D.	<em><span class="remark">Megöli</span></em>(<em><span class="remark">Jankó</span></em>,<em><span class="remark"> Tuna</span></em>) ∨ <em><span class="remark">Megöli</span></em>(<em><span class="remark">Kíváncsiság</span></em>,<em><span class="remark"> Tuna</span></em>)</code></p><p><code class="code">  E.	<em><span class="remark">Macska</span></em>(<em><span class="remark">Tuna</span></em>)</code></p><p><code class="code">  F.	¬<em><span class="remark">Macska</span></em>(<em><span class="remark">x</span></em>) ∨ <em><span class="remark">Állat</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em></code></p><p><code class="code">¬G.	¬<em><span class="remark">Megöli</span></em>(<em><span class="remark">Kíváncsiság</span></em>,<em><span class="remark"> Tuna</span></em>)</code></p><p>A 9.12. ábrán látható a rezolúciós bizonyítása annak, hogy a Kíváncsiság ölte meg a macskát. Magyarul a bizonyítást így írhatjuk át:</p><p><span class="strong"><strong>Tegyük fel, hogy a Kíváncsiság nem ölte meg Tunát. Tudjuk, hogy vagy Jankó, vagy a Kíváncsiság tette; tehát biztosan Jankó tehette. Mármost, Tuna egy macska, és a macskák állatok, tehát Tuna egy állat. Mivel bárkit, aki megöl egy állatot, senki sem szeret, tudjuk, hogy Jankót nem szereti senki. Másrészt, Jankó minden állatot szeret, tehát valaki szereti őt, tehát ez az ellentmondás áll fenn. Így tehát a Kíváncsiság ölte meg a macskát.</strong></span></p><p>A bizonyítás képes megválaszolni a „A Kíváncsiság ölte meg a macskát?” kérdést, de gyakran ennél általánosabb kérdéseket akarunk feltenni, mint például: „Ki ölte meg a macskát?” A rezolúció meg tudja válaszolni ezt is, de ennek a válasznak a levezetése egy kicsit több munkát igényel. A célállítás a ∃<span class="emphasis"><em>w Megöli</em></span>(<span class="emphasis"><em>w</em></span>,<span class="emphasis"><em> Tuna</em></span>)<span class="emphasis"><em>, </em></span>amely negáláskor CNF-ben ¬<span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>w</em></span>, <span class="emphasis"><em>Tuna</em></span>) lesz<span class="emphasis"><em>. </em></span>Megismételve a bizonyítást a 9.12. ábrán az új negált céllal, hasonló bizonyítási fát kapunk, de a következő helyettesítéssel: {<span class="emphasis"><em>w</em></span>/<span class="emphasis"><em>Kíváncsiság</em></span>} az egyik lépésben. Így ebben az esetben, annak a kiderítése, hogy ki ölte meg a macskát, nem áll másból, mint a lekérdezés változóiban lévő lekötések nyomon követése a bizonyításban.</p><p>Sajnos, a rezolúció csak <span class="strong"><strong>nem konstruktív bizonyítás</strong></span>t (<span class="strong"><strong>nonconstructive proof</strong></span>s) tud előállítani az egzisztenciális célmondatokra. Például a ¬<span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>w</em></span>,<span class="emphasis"><em> Tuna</em></span>)<span class="emphasis"><em> </em></span>rezolválható a <span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>Jankó</em></span>,<span class="emphasis"><em> Tuna</em></span>)<span class="emphasis"><em> </em></span>∨ <span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>Kíváncsiság</em></span>, <span class="emphasis"><em>Tuna</em></span>)-val<span class="emphasis"><em>,</em></span> hogy a <span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>Jankó, Tuna</em></span>) mondatot megkapjuk<span class="emphasis"><em>, </em></span>amely megint rezolválható ezzel: ¬<span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>w</em></span>,<span class="emphasis"><em> Tuna</em></span>),<span class="emphasis"><em> </em></span>és így kapjuk meg az üres klózt. Figyeljük meg, hogy ebben a bizonyításban a <span class="emphasis"><em>w</em></span>-nek két különböző lekötése van. A rezolúció megmutatja azt, hogy igen, valaki megölte Tunát – vagy Jankó, vagy a Kíváncsiság. Ez nem túl meglepő! Egy lehetséges megoldás korlátozni a rezolúciós lépéseket úgy, hogy a kérdés változóinak csak egy lekötésük lehessen egy adott bizonyításban, majd képesnek kell lennünk arra, hogy visszakövessük a lehetséges lekötéseket. Egy másik megoldás egy speciális <span class="strong"><strong>válasz literál</strong></span> (<span class="strong"><strong>answer literal</strong></span>) hozzáadása a negált célhoz, amelyből ez lesz: ¬<span class="emphasis"><em>Megöli</em></span>(<span class="emphasis"><em>w, Tuna</em></span>)  ∨ <span class="emphasis"><em>Válasz</em></span>(<span class="emphasis"><em>w</em></span>)<span class="emphasis"><em>. </em></span>Ilyenkor a rezolúciós folyamat mindig generál egy pontosan egy literált tartalmazó választ, amikor egy ilyan klóz generálódik. A 9.12. ábrán látható bizonyításra ez a <span class="emphasis"><em>Válasz</em></span>(<span class="emphasis"><em>Kíváncsiság</em></span>)<span class="emphasis"><em>.</em></span>A nem konstruktív bizonyítás ezt a klózt generálná: <span class="emphasis"><em>Válasz</em></span>(<span class="emphasis"><em>Kíváncsiság</em></span>)  ∨ <span class="emphasis"><em>Válasz</em></span>(<span class="emphasis"><em>Jankó</em></span>)<span class="emphasis"><em>, </em></span>amely nem ad számunkra választ.</p><div class="figure"><a id="id613441"/><p class="title"><strong>9.12. ábra - Egy rezolúciós bizonyítása annak, hogy a Kíváncsiság ölte meg a macskát. Figyeljük meg a faktorálás használatát a <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>Jankó</em></span>),<span class="emphasis"><em> Jankó</em></span>) klóz származtatásánál.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-12.png" alt="Egy rezolúciós bizonyítása annak, hogy a Kíváncsiság ölte meg a macskát. Figyeljük meg a faktorálás használatát a Szereti(G(Jankó), Jankó) klóz származtatásánál."/></div></div></div></div><div class="section" title="A rezolúció teljessége"><div class="titlepage"><div><div><h2 class="title"><a id="id613466"/>A rezolúció teljessége</h2></div></div></div><p>Ebben a részben bebizonyítjuk a rezolúció teljességét. A fejezet elolvasását nyugodtan kihagyhatja bárki, aki megelégszik azzal, hogy elhiszi ezt az állítást.</p><p>Be fogjuk mutatni, hogy a rezolúció <span class="strong"><strong>cáfolásteljes</strong></span> (<span class="strong"><strong>refutation-complete</strong></span>)<span class="emphasis"><em>,</em></span> ami azt jelenti, hogy <span class="emphasis"><em>ha</em></span> egy mondathalmaz kielégíthetetlen, akkor a rezolúció mindig képes levezetni egy ellentmondást. A rezolúció nem alkalmazható arra, hogy mondatok egy halmazának összes logikai következményét generálja, de használható arra, hogy megmondjuk, hogy egy adott mondat következménye-e a mondathalmaznak. Így alkalmazható egy adott kérdésre adható összes válasz megtalálására, felhasználva a korábban a fejezetben már bemutatott célnegálás módszert.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Tényként tekintjük, hogy minden (egyenlőséget nem tartalmazó) elsőrendű logikai mondat átírható CNF-klózok halmazára. Ez a mondat alakján végzett indukciós bizonyítással igazolható, az atomi mondatból, mint alapesetből kiindulva (Davis és Putnam, 1960). Célunk tehát bizonyítani a következőt: <span class="emphasis"><em>ha S egy kielégíthetetlen</em></span> <span class="emphasis"><em>klózhalmaz</em></span>,<span class="emphasis"><em> akkor az S-en elvégzett véges számú rezolúciós lépés alkalmazása ellentmondáshoz vezet.</em></span></p></div><p>Bizonyításunk váza követi Robinson eredeti bizonyítását, néhány Geneserethtől és Nilssontól származó egyszerűsítés hozzáadásával (Genesereth és Nilsson, 1987). A 9.13. ábra mutatja be a bizonyítás alapvető struktúráját, ami a következő:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Először megvizsgáljuk, hogy ha <span class="emphasis"><em>S</em></span> kielégíthetetlen, akkor létezik <span class="emphasis"><em>S </em></span>klózai között bizonyos <span class="emphasis"><em>alappéldányoknak</em></span> egy olyan halmaza, ami szintén kielégíthetetlen. (Herbrand-tétel).</p></li><li class="listitem"><p class="List Paragraph">Ekkor az <span class="strong"><strong>alap rezolúciós tétel</strong></span>hez (<span class="strong"><strong>ground resolution theorem</strong></span>) fordulunk, amelyet a 7. fejezetben adtunk meg, és amely kijelenti, hogy a propozíciós rezolúció teljes az alapmondatokra.</p></li><li class="listitem"><p class="List Paragraph">Ezután alkalmazzuk a <span class="strong"><strong>kiterjesztéslemmá</strong></span>t (<span class="strong"><strong>lifting lemma</strong></span>) annak megmutatására, hogy bármely propozíciós rezolúciós bizonyításhoz, amely alapmondatok halmazát használja, található olyan elsőrendű rezolúciós bizonyítás, amely azokat az elsőrendű logikai mondatokat használja, amelyekből az alapmondatokat megkaptuk.</p></li></ol></div><p>Az első lépés elvégzéséhez szükségünk lesz három új fogalomra:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Herbrand-univerzum</strong></span>: Ha <span class="emphasis"><em>S</em></span> a klózok egy halmaza, akkor a <span class="emphasis"><em>H<sub>S</sub></em></span> a Herbrand-univerzuma <span class="emphasis"><em>S</em></span>-nek, vagyis az összes alaptermből álló halmaz, amelyet létrehozhatunk a következőkből:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Az <span class="emphasis"><em>S</em></span> függvény szimbólumai, ha vannak ilyenek.</p></li><li class="listitem"><p>Az <span class="emphasis"><em>S</em></span> konstansszimbólumai, ha vannak ilyenek. Ha nincs ilyen, akkor az <span class="emphasis"><em>A</em></span> konstans szimbólum.</p></li></ol></div></li></ul></div><div class="figure"><a id="id613604"/><p class="title"><strong>9.13. ábra - A rezolúcióteljesség bizonyításának a szerkezete</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-13.png" alt="A rezolúcióteljesség bizonyításának a szerkezete"/></div></div></div><p>Például, ha az <span class="emphasis"><em>S</em></span> csak a ¬<span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>A</em></span>)) ∧ ¬<span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>A</em></span>) ∨ <span class="emphasis"><em>R</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>B</em></span>) klózt tartalmazza, akkor a <span class="emphasis"><em>H<sub>S</sub></em></span> az alapmondatok következő végtelen halmaza:</p><p><code class="code">	{<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>, <em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>)), …}</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Telítődés</strong></span>: Ha <span class="emphasis"><em>S </em></span>a klózok egy halmaza, és <span class="emphasis"><em>P</em></span> az alaptermek egy halmaza, és <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>S</em></span>) az <span class="emphasis"><em>S</em></span> telített halmaza <span class="emphasis"><em>P</em></span>-re vonatkoztatva, akkor <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>S</em></span>) az összes alapklóz halmaza, amelyet úgy kapunk meg, hogy alkalmazzuk az összes lehetséges konzisztens helyettesítését a <span class="emphasis"><em>P</em></span>-beli alaptermeknek az <span class="emphasis"><em>S</em></span>-beli változókkal.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Herbrand-bázis</strong></span>: Egy <span class="emphasis"><em>S</em></span> klózhalmaznak a hozzá tartozó Herbrand-univerzumra vonatkozó telítődését <span class="emphasis"><em>S </em></span>Herbrand-bázisának nevezzük, és <span class="emphasis"><em>H<sub>S</sub></em></span>(<span class="emphasis"><em>S</em></span>)-sel jelöljük. Például, ha <span class="emphasis"><em>S</em></span> csak a korábban példaként használt klózt tartalmazza, akkor a <span class="emphasis"><em>H<sub>S</sub></em></span>(<span class="emphasis"><em>S</em></span>) a következő végtelen klózhalmaz :</p></li></ul></div><p><code class="code">     {¬<em><span class="remark">P</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>)) ∨ ¬<em><span class="remark">Q</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>),</code></p><p><code class="code"><em><span class="remark">      </span></em>¬<em><span class="remark">P</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">F</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">A</span></em>)) ∨ ¬<em><span class="remark">Q</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">B</span></em>, <em><span class="remark">B</span></em>),</code></p><p><code class="code"><em><span class="remark">      </span></em>¬<em><span class="remark">P</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">A</span></em>)) ∨ ¬<em><span class="remark">Q</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">A</span></em>), <em><span class="remark">B</span></em>)</code></p><p><code class="code"><em><span class="remark">      </span></em>¬<em><span class="remark">P</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>)) ∨ ¬<em><span class="remark">Q</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">F</span></em>(<em><span class="remark">A</span></em>, <em><span class="remark">B</span></em>), <em><span class="remark">B</span></em>), …}</code></p><p>Ezek a definíciók lehetővé teszik, hogy a <span class="strong"><strong>Herbrand-tétel</strong></span> (<span class="strong"><strong>Herbrand’s theorem</strong></span>) egyik formáját állítsuk:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p>Ha a<span class="emphasis"><em> </em></span>klózok egy <span class="emphasis"><em>S</em></span> halmaza nem kielégíthető, akkor létezik egy véges <span class="emphasis"><em>H<sub>S</sub></em></span>(<span class="emphasis"><em>S</em></span>) részhalmaz, amely szintén nem kielégíthető.</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">(Herbrand, 1930)</span></td></tr></table></div><p>Legyen <span class="emphasis"><em>S′ </em></span>ez a véges részhalmaza az alapmondatoknak. Mármost, alkalmazhatjuk az alap rezolúciós tételt (<a class="xref" href="ch07s04.md#ID_272_oldal">„A rezolúció teljessége”</a> részben), hogy kimutassuk, hogy a <span class="strong"><strong>rezolúciós! lezárt</strong></span> (<span class="strong"><strong>resolution! closure</strong></span>) <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S′</em></span>)<span class="emphasis"><em> </em></span>tartalmazza az üres klózt. Ez azt jelenti, hogy a propozíciós rezolúció futtatása a teljességig az <span class="emphasis"><em>S</em></span>′-en egy ellentmondást fog eredményezni.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p><span class="strong"><strong>Gödel nemteljesség tétele</strong></span></p><p>A <span class="strong"><strong>matematikai indukciós sémá</strong></span>kkal (<span class="strong"><strong>mathematical induction schema</strong></span>) kibővítve az elsőrendű logikát, Gödel <span class="strong"><strong>nemteljesség tétel</strong></span>e (<span class="strong"><strong>incompleteness theorem</strong></span>) megmutatta, hogy léteznek olyan igaz aritmetikai mondatok, amelyek nem bizonyíthatók.</p><p>A nemteljesség elmélet igazolása mintegy 30 oldalt kívánna, így túlmutat ennek a könyvnek a keretein, de a bizonyítás lényegét felvázoljuk a következőkben. Először a számok logikai elméletét vezetjük be. Ebben az elméletben egyetlen konstans létezik, a 0, és egyetlen függvény, az <span class="emphasis"><em>S </em></span>(az utód-függvény). Az így létrehozott modellben <span class="emphasis"><em>S</em></span>(0) fejezi ki az 1-et, <span class="emphasis"><em>S</em></span>(<span class="emphasis"><em>S</em></span>(0)) jelöli a 2-t és így tovább. A nyelv tehát alkalmas az összes természetes szám kifejezésére. A nyelv szótára tartalmazza ezenkívül a +, a × és az <span class="emphasis"><em>exp</em></span> (exponenciális) függvényszimbólumokat és a logikai összekötőjelek és a kvantorok szokásos halmazát. Először figyeljük meg, hogy a nyelv mondatai megszámozhatók. (Definiáljunk alfabetikus sorrendet a szimbólumok között, és rendezzük alfabetikus sorrendbe a nyelv 1, 2, …, <span class="emphasis"><em>n</em></span>, … hosszúságú mondatait.) Így minden <span class="emphasis"><em>α</em></span> mondathoz hozzárendelhetünk egy egyedi #<span class="emphasis"><em>α </em></span>természetes számot, a <span class="strong"><strong>Gödel-szám</strong></span>ot (<span class="strong"><strong>Gödel number</strong></span>). Fontos tehát, hogy a számelmélet minden saját mondatához tartalmaz egy nevet. Hasonlóan megszámozhatunk minden egyes <span class="emphasis"><em>P</em></span> bizonyítást egy <span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>P</em></span>) Gödel-számmal, mivel egy bizonyítás nem más, mint mondatok véges sorozata.</p><p>Most tegyük fel, hogy adott egy <span class="emphasis"><em>A</em></span> halmaz, amely a természetes számokról igaz állításokat megfogalmazó mondatokat tartalmaz. Mivel az <span class="emphasis"><em>A</em></span> halmaz megadható egész számoknak egy adott halmazával (az <span class="emphasis"><em>A</em></span> halmazban található mondatok Gödel-számaival), ezért létre tudunk hozni a definiált nyelvben egy <span class="emphasis"><em>α</em></span>(<span class="emphasis"><em>j</em></span>, <span class="emphasis"><em>A</em></span>) mondatot, amely a következő állítás:</p><p>∀<span class="emphasis"><em>i</em></span> <span class="emphasis"><em>i </em></span>nem a Gödel-száma a <span class="emphasis"><em>j </em></span>Gödel-számú mondat olyan bizonyításának, amely bizonyítás csak <span class="emphasis"><em>A</em></span>-beli<span class="emphasis"><em> </em></span>premisszákat használ.</p><p>Legyen a <span class="emphasis"><em>σ</em></span> az <span class="emphasis"><em>α</em></span>(#<span class="emphasis"><em>σ</em></span>, <span class="emphasis"><em>A</em></span>) mondat, vagyis egy olyan mondat, amely kifejezi önmagának a bizonyíthatatlanságát <span class="emphasis"><em>A</em></span>-ból. (Igazolható, hogy ilyen mondat mindig létezik, de nem egyszerű ezt belátni.)</p><p>Kövessük végig a következő ügyes érvelést. Tegyük fel, hogy <span class="emphasis"><em>σ</em></span> bizonyítható <span class="emphasis"><em>A</em></span>-ból, de akkor <span class="emphasis"><em>σ</em></span> hamis, mivel <span class="emphasis"><em>σ</em></span> épp azt mondja ki, hogy nem igazolható. Ebben az esetben viszont létezik egy hamis mondat, ami bizonyítható <span class="emphasis"><em>A</em></span>-ból, így <span class="emphasis"><em>A</em></span> nem tartalmazhatna csak igaz mondatokat – ez az előzetes feltételezésünkkel ellentétes. Tehát <span class="emphasis"><em>σ</em></span> nem bizonyítható <span class="emphasis"><em>A</em></span>-ból. Ez viszont éppen az, amit <span class="emphasis"><em>σ</em></span> állít saját magáról, tehát <span class="emphasis"><em>σ</em></span> egy igaz mondat.</p><p>Tehát megmutattuk (29 és fél oldalnyi levezetést átugorva), hogy bármely, a számelméletben definiálható igaz mondatokat tartalmazó halmaz esetében, bizonyos alapaxiómák feltételezése mellett, léteznek olyan igaz mondatok, amelyek <span class="emphasis"><em>nem </em></span>bizonyíthatók az axiómákból. Ez az eredmény, más következmények mellett azt jelenti, hogy a matematika <span class="emphasis"><em>bármely axiómarendszerében</em></span> megfogalmazható olyan tétel, amely nem bizonyítható az adott rendszer axiómáiból. Ez a matematikának egy igen fontos eredménye. A Gödel-tétel hatását a mesterséges intelligencia területére sokan vitatták, köztük maga Gödel is. A 26. fejezetben visszatérünk erre a kérdésre.</p></div><p>Most, hogy megállapítottuk, hogy mindig van egy rezolúciós bizonyítás, amely magában foglal néhány véges részhalmazt a Herbrand <span class="emphasis"><em>S </em></span>bázisból, a következő lépés annak megmutatása, hogy létezik egy rezolúciós bizonyítás, amely magának az <span class="emphasis"><em>S</em></span>-nek a klózait tartalmazza, amelyek nem szükségszerűen alapklózok. Azzal kezdjük, hogy megvizsgáljuk a rezolúciós szabály egy egyszerű alkalmazását. Robinson alaplemmája magába foglalja a következő tényt:</p><p>Legyen <span class="emphasis"><em>C</em></span><sub>1</sub> és <span class="emphasis"><em>C</em></span><sub>2</sub> két klóz, amelyeknek nincsenek közös változói. Legyenek <span class="emphasis"><em>C</em></span><sub>1</sub>′ és <span class="emphasis"><em>C</em></span><sub>2</sub>′ az alappéldányai <span class="emphasis"><em>C</em></span><sub>1</sub>-nek és <span class="emphasis"><em>C</em></span><sub>2</sub>-nek. Ha <span class="emphasis"><em>C</em></span>′ rezolvense <span class="emphasis"><em>C</em></span><sub>1</sub>′-nek és<span class="emphasis"><em> C</em></span><sub>2</sub>′-nek, akkor létezik egy olyan <span class="emphasis"><em>C</em></span> klóz, amelyik (1) rezolvense <span class="emphasis"><em>C</em></span><sub>1</sub>-nek és<span class="emphasis"><em> C</em></span><sub>2</sub>-nek és (2) <span class="emphasis"><em>C</em></span>′<span class="emphasis"><em> </em></span>alappéldánya <span class="emphasis"><em>C</em></span>-nek.</p><p>Ezt <span class="strong"><strong>kiterjesztéslemmá</strong></span>nak (<span class="strong"><strong>lifting lemma</strong></span>) nevezik, mivel kiterjeszti a bizonyítási lépést az alap klózokról az általános elsőrendű klózokra. A kiterjesztési lemma bizonyításához Robinsonnak szüksége volt az egyesítés módszerének megalkotására és a legáltalánosabb egyesítő tulajdonságainak levezetésére is. A bizonyítás áttekintése helyett a következőkben illusztráljuk a lemmát:</p><p><code class="code"><em><span class="remark">C</span></em><sub>1 </sub>= ¬<em><span class="remark">P</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">F</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">A</span></em>)) ∨  ¬<em><span class="remark">Q</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">B</span></em>)</code></p><p><code class="code"><em><span class="remark">C</span></em><sub>2 </sub>= ¬<em><span class="remark">N</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">z</span></em>)) ∨ <em><span class="remark">P</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">z</span></em>)</code></p><p><code class="code"><em><span class="remark">C</span></em>'<sub>1 </sub>= ¬<em><span class="remark">P</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>)) ∨  ¬<em><span class="remark">Q</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">B</span></em>)</code></p><p><code class="code"><em><span class="remark">C'</span></em><sub>2</sub> = ¬<em><span class="remark">N</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>)) ∨ <em><span class="remark">P</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>))</code></p><p><code class="code"><em><span class="remark">C</span></em>' = ¬<em><span class="remark">N</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>)) ∨  ¬<em><span class="remark">Q</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">B</span></em>), <em><span class="remark">B</span></em>)</code></p><p><code class="code"><em><span class="remark">C</span></em> = ¬<em><span class="remark">N</span></em>(<em><span class="remark">G</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">F</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">A</span></em>)) ∨ ¬<em><span class="remark">Q</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">A</span></em>) ∨ <em><span class="remark">R</span></em>(<em><span class="remark">H</span></em>(<em><span class="remark">y</span></em>), <em><span class="remark">B</span></em>)</code></p><p>Látható, hogy <span class="emphasis"><em>C</em></span>′ valóban <span class="emphasis"><em>C</em></span> alaptermje. Általánosságban ahhoz, hogy <span class="emphasis"><em>C</em></span><sub>1</sub>′-nek és<span class="emphasis"><em> C</em></span><sub>2</sub>′-nek legyen rezolvense, úgy kell létrehozni őket, hogy először a <span class="emphasis"><em>C</em></span><sub>1</sub>-beli és a <span class="emphasis"><em>C</em></span><sub>2</sub>-beli komplemens literálok legáltalánosabb egyesítőjét alkalmazzuk <span class="emphasis"><em>C</em></span><sub>1</sub>-re és <span class="emphasis"><em>C</em></span><sub>2</sub>-re. A kiterjesztési lemma felhasználásával könnyű hasonló állításokat levezetni a rezolúciós szabály alkalmazásának bármely sorozatára:</p><p>Bármely az<span class="emphasis"><em> S</em></span>′<span class="emphasis"><em>  </em></span>lezárásához tartozó <span class="emphasis"><em>C</em></span>′<span class="emphasis"><em> </em></span>klózhoz létezik egy <span class="emphasis"><em>S</em></span> lezárásában levő <span class="emphasis"><em>C </em></span>klóz, amelyre a <span class="emphasis"><em>C</em></span>′ klóz a <span class="emphasis"><em>C</em></span> klóz alappéldánya, és a <span class="emphasis"><em>C</em></span> levezetése azonos hosszúságú a <span class="emphasis"><em>C</em></span>′ levezetésével.</p><p>Ebből a tényből következik, hogy ha <span class="emphasis"><em>S</em></span>′<span class="emphasis"><em> </em></span>lezárásában megjelenik az üres klóz, akkor ez szintén megtalálható az <span class="emphasis"><em>S</em></span> rezolúciós lezárásában. Ez azért van, mivel az üres<span class="emphasis"><em> </em></span>klóz semmilyen más klóznak sem alappéldánya. Összefoglalva: megmutattuk, hogyha <span class="emphasis"><em>S</em></span> nem kielégíthető, akkor létezik az üres<span class="emphasis"><em> </em></span>klóznak egy véges méretű rezolúciós szabályt alkalmazó levezetése.</p><p>Az elmélet bizonyításában az alapklózokról az elsőrendű klózokra történő kiterjesztés az állítás erejének igen jelentős növelése. Ez abból következik, hogy az elsőrendű bizonyításban már csak annyiszor kell a változókat helyettesíteni, amennyiszer ez a bizonyításhoz szükséges, míg az alapklózmódszereknél szükséges volt nagyszámú önkényes példányosítást megvizsgálni.</p></div><div class="section" title="Az egyenlőség kezelése"><div class="titlepage"><div><div><h2 class="title"><a id="id614870"/>Az egyenlőség kezelése</h2></div></div></div><p>Az ebben a fejezetben az eddig leírt következtetési módszerek közül egyik sem foglalkozott az egyenlőséggel. Három jól elkülöníthető megközelítést alkalmazhatunk. Az első az, hogy axiómákkal látjuk el az egyenlőséget – vagyis leírunk mondatokat az egyenlőségi relációról a tudásbázisban. El kell mondanunk, hogy az egyenlőség reflexív, szimmetrikus, tranzitív, és hogy az egyenlők helyettesíthetők egyenlőkkel bármely predikátumban vagy függvényben. Ezért van szükségünk három alapaxiómára, majd ezután egy továbbira minden egyes predikátumhoz vagy függvényhez:</p><p><code class="code">∀<em><span class="remark">x</span></em>   <em><span class="remark">x</span></em> = <em><span class="remark">x</span></em></code></p><p><code class="code">    ∀<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>   <em><span class="remark">x</span></em> = <em><span class="remark">y</span></em> ⇒ <em><span class="remark">y</span></em> = <em><span class="remark">x</span></em></code></p><p><code class="code">    ∀<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>, <em><span class="remark">z</span></em>   <em><span class="remark">x</span></em> = <em><span class="remark">y</span></em> ∧ <em><span class="remark">y</span></em> = <em><span class="remark">z</span></em> ⇒ <em><span class="remark">x</span></em> = <em><span class="remark">z</span></em></code></p><p><code class="code">    ∀<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>   <em><span class="remark">x</span></em> = <em><span class="remark">y</span></em> ⇒ (<em><span class="remark">P</span></em><sub>1</sub>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">P</span></em><sub>1</sub>(<em><span class="remark">y</span></em>))</code></p><p><code class="code">    ∀<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>   <em><span class="remark">x</span></em> = <em><span class="remark">y</span></em> ⇒ (<em><span class="remark">P</span></em><sub>2</sub>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">P</span></em><sub>2</sub>(<em><span class="remark">y</span></em>))</code></p><p><code class="code">	.           </code></p><p><code class="code">	.</code></p><p><code class="code">	.</code></p><p><code class="code">∀<em><span class="remark">w</span></em>, <em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>,<em><span class="remark"> z</span></em>   <em><span class="remark">w</span></em> = <em><span class="remark">y</span></em> ∧ <em><span class="remark">x</span></em> = <em><span class="remark">z </span></em>⇒ (<em><span class="remark">F</span></em><sub>1</sub>(<em><span class="remark">w</span></em>, <em><span class="remark">x</span></em>) = <em><span class="remark">F</span></em><sub>1</sub>(<em><span class="remark">y</span></em>,<em><span class="remark"> z</span></em>))</code></p><p><code class="code">∀<em><span class="remark">w</span></em>, <em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>,<em><span class="remark"> z</span></em>   <em><span class="remark">w</span></em> = <em><span class="remark">y</span></em> ∧ <em><span class="remark">x</span></em> = <em><span class="remark">z</span></em> ⇒ (<em><span class="remark">F</span></em><sub>2</sub>(<em><span class="remark">w</span></em>, <em><span class="remark">x</span></em>) = <em><span class="remark">F</span></em><sub>2</sub>(<em><span class="remark">y</span></em>,<em><span class="remark"> z</span></em>))</code></p><p><code class="code">	.           </code></p><p><code class="code">	.</code></p><p><code class="code">	.</code></p><p>Mikor ezek a mondatok adottak, egy standard következtetési eljárás, mint amilyen a rezolúció elvégezhet olyan feladatokat, amelyek egyenlőségi következtetést igényelnek, mint például a matematikai egyenletek megoldása.</p><p>Az egyenlőség kezelésének másik módja egy további következtetési szabály alkalmazása. A legegyszerűbb szabály, a <span class="strong"><strong>demoduláció</strong></span> (<span class="strong"><strong>demodulation</strong></span>) vesz egy egységklózt, <span class="emphasis"><em>x </em></span>=<span class="emphasis"><em> y</em></span> és helyettesíti az <span class="emphasis"><em>y</em></span>-t bármely termmel, ami <span class="emphasis"><em>x</em></span>-szel egyesíthető egy másik klózban. Formálisabban kifejezve ezt kapjuk:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Demoduláció</strong></span>. Bármely <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> és <span class="emphasis"><em>z</em></span> termekre, ahol <code class="code">EGYESÍT</code> (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>z</em></span>) = <span class="emphasis"><em>θ</em></span>, és az <span class="emphasis"><em>m<sub>n</sub></em></span>[<span class="emphasis"><em>z</em></span>] egy literál, ami tartalmazza a <span class="emphasis"><em>z</em></span>-t.<span class="emphasis"><em> </em></span></p></li></ul></div><p><span class="inlinemediaobject"><img src="math/mi-09-0005.gif" alt="Az egyenlőség kezelése"/></span></p><p>	A demodulációt jellemzően arra használják, hogy leegyszerűsítsen állítások kollekcióit használó kifejezéseket, mint például <span class="emphasis"><em>x </em></span>+ 0<span class="emphasis"><em> </em></span>=<span class="emphasis"><em> x</em></span>,<span class="emphasis"><em> x</em></span><sup>1</sup> =<span class="emphasis"><em> x </em></span>és így tovább. A szabályt ki lehet terjeszteni, hogy olyan nem egység klózokkal is tudjon foglalkozni, amelyekben egy egyenlőségi literál megjelenik.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Paramoduláció</strong></span> (<span class="strong"><strong>paramodulation</strong></span>). Bármely <span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> y </em></span>és <span class="emphasis"><em>z </em></span>termre, ahol az <code class="code">EGYESÍT</code> (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> z</em></span>)<span class="emphasis"><em> </em></span>=<span class="emphasis"><em> θ</em></span></p></li></ul></div><p><span class="inlinemediaobject"><img src="math/mi-09-0006.gif" alt="Az egyenlőség kezelése"/></span></p><p>	</p><p>A demodulációval ellentétben a paramoduláció egy teljes következtetési eljárást eredményez az egyenlőséggel rendelkező elsőrendű logikában.</p><p>Egy harmadik megközelítés az egyenlőségi következtetést teljes mértékben egy kiterjesztett egyesítési algoritmuson belül kezeli. Ez azt jelenti, hogy a termek egyesíthetők, ha <span class="emphasis"><em>bizonyíthatóan </em></span>egyenlők egy bizonyos helyettesítés alatt, ahol a „bizonyíthatóan” lehetővé tesz egy bizonyos mennyiségű egyenlőségi következtetést. Például, azok a termek, hogy 1 + 2 és 2 + 1 normális esetben nem egyesíthetők, de egy egyesítési algoritmus, amely ismeri, hogy <span class="emphasis"><em>x </em></span>+<span class="emphasis"><em> y </em></span>=<span class="emphasis"><em> y </em></span>+ <span class="emphasis"><em>x</em></span>, tudná őket egyesíteni az üres helyettesítéssel. Az ilyen fajta <span class="strong"><strong>egyenleti egyesítés</strong></span> (<span class="strong"><strong>equational unification</strong></span>) elvégezhető hatékony algoritmusokkal, amelyeket arra terveztek, hogy a felhasznált bizonyos axiómákat használja (kommutativitás, asszociativitás és így tovább), ahelyett hogy explicit következtetéseket tenne ugyanazokkal az axiómákkal. A tételbizonyítások, amelyek ezt a technikát használják, szoros kapcsolatban állnak a korlátozott logikai programozási rendszerekkel, amelyeket a 9.4. alfejezetben írtunk le.</p></div><div class="section" title="Rezolúciós stratégiák"><div class="titlepage"><div><div><h2 class="title"><a id="id617070"/>Rezolúciós stratégiák</h2></div></div></div><p>Tudjuk, hogy a rezolúció ismételt alkalmazása megtalálja a bizonyítást, ha létezik. Ebben a részben olyan stratégiákat tekintünk át, amelyek <span class="emphasis"><em>hatékonyan</em></span> segítenek megtalálni a bizonyításokat.</p><div class="section" title="Egységpreferencia"><div class="titlepage"><div><div><h3 class="title"><a id="id617079"/>Egységpreferencia</h3></div></div></div><p>Ez a stratégia előnybe helyezi azoknak a mondatoknak az alkalmazását, amelyek egyetlen literált tartalmaznak (szokták ezeket <span class="strong"><strong>egységklóz</strong></span>nak (<span class="strong"><strong>unit clause</strong></span>) is nevezni). A stratégia alapötlete az, hogy próbáljunk meg létrehozni egy üres klózt, így tehát jó ötlet lehet előnyben részesíteni az olyan következtetéseket, amelyek rövidebb klózokat hoznak létre. Egy egységmondat feloldása (mint amilyen a <span class="emphasis"><em>P</em></span>) egy bármely más mondattal (mint amilyen a ¬<span class="emphasis"><em>P</em></span> ∨ ¬<span class="emphasis"><em>Q</em></span> ∨ <span class="emphasis"><em>R</em></span>), mindig egy olyan klózt eredményez (ebben az esetben:  ¬<span class="emphasis"><em>Q </em></span>∨ <span class="emphasis"><em>R</em></span> ), amely rövidebb lesz, mint a másik klóz. Amikor az egységpreferencia-stratégiát először alkalmazták az ítéletkalkulusban, akkor ez drámai gyorsulást eredményezett, megvalósíthatóvá téve olyan bizonyítások elvégzését, amelyek a preferenciák meghatározása nélkül nem voltak kivitelezhetők. Az egységpreferencia azonban önmagában nem csökkenti le eléggé az elágazások számát a közepes méretű problémákban ahhoz, hogy ezek kezelhetők legyenek rezolúcióval. Mindenesetre a módszer egy hasznos heurisztika, amit jól lehet kombinálni más stratégiákkal.</p><p>Az <span class="strong"><strong>egységrezolúció</strong></span> (<span class="strong"><strong>unit resolution</strong></span>) a rezolúció egy korlátozott formája, amelyben minden rezolúciós lépésnek tartalmaznia kell egy egységklózt. Az egységrezolúció általában nem teljes, de a Horn-tudásbázisokban teljes. Az egységrezolúciós bizonyítások a Horn-tudásbázisokon emlékeztetnek az előrefelé láncolásra.</p></div><div class="section" title="Támogató halmaz"><div class="titlepage"><div><div><h3 class="title"><a id="id617129"/>Támogató halmaz</h3></div></div></div><p>Hasznosak azok a módszerek, amelyek megpróbálják meghatározni, hogy melyik rezolúciót érdemes először elvégezni, de még hatékonyabbak, ha megpróbáljuk kizárni a lehetséges rezolúciók egy csoportját is. A <span class="strong"><strong>támogató halmaz</strong></span> (<span class="strong"><strong>set of support</strong></span>) stratégia pontosan ezt teszi. Az eljárás mondatok egy halmazának kiválasztásával kezdődik, amelyet támogató halmaznak nevezünk. Minden rezolúció egy támogató halmazbeli elemet és egy másik, nem halmazbeli elemet kombinál össze, és hozzáadja a rezolvenst a támogató halmazhoz. Ha a támogató halmaz viszonylag kicsi a tudásbázishoz képest, akkor a módszer alkalmazása jelentős mértékben lecsökkenti a keresési teret.</p><p>Óvatosan kell alkalmaznunk a megközelítést, mivel az algoritmus nem lesz teljes, ha a támogató halmazt rosszul választjuk meg. Ha az <span class="emphasis"><em>S</em></span> támogató halmazt úgy választjuk meg, hogy a maradék mondatok együttesen kielégíthetők, akkor a támogató halmaz stratégiáját alkalmazó rezolúció teljes. Elterjedt módszer, hogy a negált lekérdezés mondatot használjuk támogató halmazként, azt feltételezve, hogy az eredeti tudásbázis konzisztens. (Végül is, ha a tudásbázis nem konzisztens, akkor a lekérdezésből következtethető tény is jelentés nélküli.) A támogató halmaz stratégiának további előnye, hogy a létrehozott bizonyítási fák célorientáltak, így az olvasók számára könnyen érthetők.</p></div><div class="section" title="Bemeneti rezolúció"><div class="titlepage"><div><div><h3 class="title"><a id="id617150"/>Bemeneti rezolúció</h3></div></div></div><p>A <span class="strong"><strong>bemeneti rezolúció</strong></span> (<span class="strong"><strong>input resolution</strong></span>) stratégiában minden rezolúció egy (tudásbázisbeli vagy lekérdező-) mondatot kombinál más mondatokkal. A 9.11. ábrán<span class="emphasis"><em> </em></span>látható bizonyítás csak bemeneti rezolúciót használ. Ezt az ábrákon sok oldalkapcsolattal rendelkező vonal jellemzi, ahol a kapcsolódásokon egyedi mondatok találhatók. Egyértelmű, hogy az ilyen alakú bizonyítási fák mérete kisebb, mint bármely más bizonyítási fáé. Horn formájú tudásbázisok esetében a Modus Ponens egyfajta bemeneti rezolúciós stratégia, mivel mindig az eredeti <span class="emphasis"><em>TB</em></span> egy mondatát kombinálja egy másik mondattal. Így nem meglepő, hogy a bemeneti rezolúció teljes a Horn formájú tudásbázisok esetében, de nem teljes általános esetben. A <span class="strong"><strong>lineáris rezolúció</strong></span> (<span class="strong"><strong>linear resolution</strong></span>) stratégia egy olyan általánosítás, amely megengedi, hogy <span class="emphasis"><em>P</em></span> és <span class="emphasis"><em>Q</em></span> együtt szerepeljenek a rezolúcióban, ha <span class="emphasis"><em>P</em></span> eredeti eleme a <span class="emphasis"><em>TB</em></span>-nek, vagy ha <span class="emphasis"><em>P</em></span> leszármazottja <span class="emphasis"><em>Q</em></span>-nak a bizonyítási fában. A lineáris rezolúció teljes eljárás.</p></div><div class="section" title="Bennfoglalás"><div class="titlepage"><div><div><h3 class="title"><a id="id617204"/>Bennfoglalás</h3></div></div></div><p>A <span class="strong"><strong>bennfoglalás</strong></span> (<span class="strong"><strong>subsumption</strong></span>) módszere kizárja a keresésből azokat a mondatokat, amelyek benne foglaltatnak (például mert specifikusabbak) más tudásbázisbeli mondatokban. Például ha <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>) megtalálható a tudásbázisban, akkor nincs értelme hozzáadni <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>)-t, még kevesebb értelme van hozzáadni <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>) ∨ <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>B</em></span>)-t. A bennfoglalás segít kis méreten tartani a <span class="emphasis"><em>TB</em></span>-t, amely a keresési tér méretének csökkentését eredményezi.</p></div></div><div class="section" title="Tételbizonyítók"><div class="titlepage"><div><div><h2 class="title"><a id="id617252"/>Tételbizonyítók</h2></div></div></div><p>A tételbizonyítók (amelyeket automatizált következtetőknek is szoktunk nevezni) két szempontból különböznek a logikai programozási nyelvektől. Először is a legtöbb logikai programozási nyelv csak Horn klózokkal dolgozik, ezzel szemben a tételbizonyítások elfogadják a teljes elsőrendű logikát. Másodszor, a Prolog programok egymásba fűzik a logikát és a kontrollt. Ha a programozó választása az A:-B, C-re esik az A:-C, B helyett, ez a program végrehajtására van hatással. A legtöbb tételbizonyításban a mondatok választott szintaktikai formája nincs hatással a kapott eredményekre. A tételbizonyításoknak is szükségük van az információ kontrolljára, hogy hatékonyan működhessenek, de ezt az információt általában külön tárolják a tudásbázistól, ahelyett, hogy magának a tudásreprezentációnak a részeként jelenne meg. A legtöbb kutatás a tételbizonyítások tárgyában magában foglalja az általában hasznos kontrollstratégiákat, amelyek a sebességet is növelhetik.</p><div class="section" title="Egy tételbizonyítás szerkesztése"><div class="titlepage"><div><div><h3 class="title"><a id="id617258"/>Egy tételbizonyítás szerkesztése</h3></div></div></div><p>Ebben a részben leírjuk az <code class="code">OTTER</code> (Organized Techniques for Theoremproving and Effective Research) nevű tételbizonyítót (McCune, 1992), különös figyelmet fordítva a vezérlési stratégiájára. Ahhoz, hogy egy problémát készítsen elő az <code class="code">OTTER</code> számára, a felhasználónak négy részre kell osztania a tudásbázist:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Egy klózhalmazra, melyet <span class="strong"><strong>támogató halmaz</strong></span>nak (<span class="strong"><strong>set of support</strong></span>) (vagy <span class="emphasis"><em>sos-</em></span>nek) nevezünk, és amely definiálja a problémáról szóló legfontosabb tényeket. Minden rezolúciós lépés a támogató halmaz egy tagját rezolválja egy másik axiómához képest, tehát a keresést a támogató halmazra koncentráljuk.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>használható axiómá</strong></span>kra (<span class="strong"><strong>usable axioms</strong></span>), amely egy halmaz a támogató halmazon kívül. Ez háttértudást biztosít a problématerületről. A határ megválasztása a probléma részei (tehát ami az <span class="emphasis"><em>sos</em></span>-en belül van) és a háttér (tehát a használható axiómák) között a felhasználó megítélésén múlik.</p></li><li class="listitem"><p class="List Paragraph">Az egyenletek egy halmazára, amelyeket <span class="strong"><strong>átírás</strong></span>oknak (<span class="strong"><strong>rewrite</strong></span>s) vagy <span class="strong"><strong>demodulátor</strong></span>oknak<span class="strong"><strong> </strong></span>(<span class="strong"><strong>demodulator</strong></span>s) nevezünk. Habár a demodulátorok egyenletek, mindig balról jobbra irányban alkalmazzák őket. Így tehát egy kanonikus formát határoznak meg, amelyben az összes term leegyszerűsödik. Például az <span class="emphasis"><em>x </em></span>+ 0 =<span class="emphasis"><em> x </em></span>demodulátor kimondja, hogy minden termet az <span class="emphasis"><em>x</em></span> + 0 formában az <span class="emphasis"><em>x </em></span>termmel kell helyettesíteni.</p></li><li class="listitem"><p class="List Paragraph">Paraméterek és klózok egy halmazára, amelyek meghatározzák a vezérlési stratégiát. A felhasználónak egy heurisztikus funkciót szükséges specifikálni, hogy kontrollálja a keresést, és egy szűrő funkciót, hogy kitöröljön néhány lényegtelen részcélt.</p></li></ul></div><p>Az <code class="code">OTTER</code> úgy működik, hogy folyamatosan rezolválja a támogatóhalmaz egy elemét az egyik használható axiómával szemben. A Prologgal ellentétben, ez egy „a legjobbat-először” keresést használ. A heurisztikus funkciója megméri minden egyes klóz „súlyát”, ahol a könnyebb klózokat részesíti előnyben. A heurisztika egzakt kiválasztása a felhasználón múlik, de általában a klóz súlyának korrelálnia kell a méretével vagy a nehézségével. </p><div class="figure"><a id="id617367"/><p class="title"><strong>9.14. ábra - Az <code class="code">OTTER</code> tételbizonyítás vázlata. A heurisztikus kontrollt alkalmazzák a „legkönnyebb” klóz kiválasztására és a <code class="code">FILTER</code> funkcióban, amely kitörli a jelentéktelen klózokat a további vizsgálatból.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-14.png" alt="Az OTTER tételbizonyítás vázlata. A heurisztikus kontrollt alkalmazzák a „legkönnyebb” klóz kiválasztására és a FILTER funkcióban, amely kitörli a jelentéktelen klózokat a további vizsgálatból."/></div></div></div><p>Az egységklózokat könnyűként kezeljük; így tehát a keresést az egységpreferencia-stratégia általánosításának tekinthetjük. Minden egyes lépésnél az <code class="code">OTTER</code> átteszi a „legkönynyebb” klózt a támogatóhalmazból a használható listára, és hozzáadja a használható listához a legkönnyebb klóz és a használható lista elemeinek rezolválásakor keletkezett néhány közvetlen következményt. Az <code class="code">OTTER</code> leáll, amikor talál egy cáfolatot, vagy amikor nincs több klóz a támogatóhalmazban. Az algoritmus a 9.14. ábrán látható részletesebben.</p></div><div class="section" title="A Prolog kiterjesztése"><div class="titlepage"><div><div><h3 class="title"><a id="id617394"/>A Prolog kiterjesztése</h3></div></div></div><p>Egy tételbizonyító létrehozásának alternatív módja, ha a Prolog fordítóból indulunk ki, és ezt kiterjesztjük úgy, hogy egy helyes és teljes következtetőgépet kapjunk a teljes elsőrendű logikához. Ezt a megközelítést alkalmazták a Prolog Technológia Tételbizonyítóban (Prolog Technology Theorem Prover, PTTP) (Stickel, 1988). A PTTP négy jelentős változtatást tartalmaz a Prologhoz képest, hogy helyreállítsa a teljességet és a kifejezőképességet:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az előfordulási próba visszakerül az egyesítési folyamatba, hogy azt biztosabbá tegye.</p></li><li class="listitem"><p class="List Paragraph">A mélységi keresést felváltja egy iteratívan mélyülő keresés. Ez a keresési stratégiát teljessé teszi, és csak egy konstans értékkel vesz több időt igénybe.</p></li><li class="listitem"><p class="List Paragraph">A negált literálok (mint a ¬<span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>))<span class="emphasis"><em> </em></span>engedélyezettek. A megvalósításban két különálló folyamat van, az egyik a <span class="emphasis"><em>P</em></span>-t akarja bebizonyítani, a másik a ¬<span class="emphasis"><em>P</em></span>-t.</p></li><li class="listitem"><p class="List Paragraph">Egy <span class="emphasis"><em>n </em></span>atommal rendelkező klóz <span class="emphasis"><em>n </em></span>különböző szabályként kerül tárolásra. Például az <span class="emphasis"><em>A </em></span>⇐ <span class="emphasis"><em>B </em></span>∧ <span class="emphasis"><em>C</em></span>-t úgy is tárolnánk, mint ¬<span class="emphasis"><em>B </em></span>⇐ <span class="emphasis"><em>C </em></span>∧ <span class="emphasis"><em>A </em></span>és úgy is, mint ¬<span class="emphasis"><em>C</em></span> ⇐ <span class="emphasis"><em>B </em></span>∧ ¬<span class="emphasis"><em>A. </em></span>Ez a technika, amelyet <span class="strong"><strong>zárás</strong></span>nak (<span class="strong"><strong>locking</strong></span>) nevezünk, azt eredményezi, hogy az aktuális célt csak minden egyes klóz fejével kell egyesíteni, de még így is lehetővé teszi a negálás helyes kezelését.</p></li><li class="listitem"><p class="List Paragraph">A következtetést teljessé teszik (még a nem Horn-klózokra is) a lineáris bemeneti szabály hozzáadásával: ha a <span class="emphasis"><em>z</em></span> aktuális cél egyesül a veremben lévő egyik cél negáltjával, akkor azt a célt rezolváltnak kell tekinteni. Ez egy módja az ellentmondásokkal való következtetésnek. Tételezzük fel, hogy az eredeti cél a <span class="emphasis"><em>P</em></span>,<span class="emphasis"><em> </em></span>és ezt redukáltuk következtetések sorozatával a ¬<span class="emphasis"><em>P </em></span>célra. Ez a ¬<span class="emphasis"><em>P </em></span>⇒ <span class="emphasis"><em>P </em></span>mondatra vezet,<span class="emphasis"><em> </em></span>amely logikailag egyenértékű a <span class="emphasis"><em>P</em></span>-vel.</p></li></ul></div><p>A felsorolt változtatások ellenére a PTTP megőrzi azokat a tulajdonságokat, amelyek a Prologot gyorssá teszik. Az egyesítések még így is a változók közvetlen változtatásával történnek úgy, hogy a lekötések feloldása a visszalépés során az útvonal lezárásával együtt történik. A keresési stratégia itt is a bemeneti rezolúción alapszik, ami azt jeleneti, hogy minden rezolúció a probléma egyik eredeti kijelentésében megadott klózzal szemben történik (és nem egy származtatott klózzal). Ez lehetővé teszi a probléma eredeti kijelentésében adott összes klóz lefordítását.</p><p>A PTTP fő hátránya az, hogy a felhasználó elveszít minden vezérlési lehetőséget a megoldások keresése során. Minden következtetési szabályt a rendszer mind az eredeti, mind a kontrapozitív formájában felhasznál. Ez nehezen értelmezhető kereséseket eredményez. Például figyeljük meg ezt a szabályt:</p><p><code class="code">(<em><span class="remark">f</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>)<em><span class="remark"> </span></em>=<em><span class="remark"> f</span></em>(<em><span class="remark">a</span></em>,<em><span class="remark"> b</span></em>))<em><span class="remark"> </span></em>⇐ (<em><span class="remark">x </span></em>=<em><span class="remark"> a</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> </span></em>(<em><span class="remark">y </span></em>=<em><span class="remark"> b</span></em>)</code></p><p>Prolog szabályként tekintve, ez is egy következetes módja annak a bizonyításának, hogy két <span class="emphasis"><em>f </em></span>term megegyezik. De a PTTP még a kontrapozitív állítást is generálhatja:</p><p><code class="code">(<em><span class="remark">x</span></em> ≠ <em><span class="remark">a</span></em>)<em><span class="remark"> </span></em>⇐ (<em><span class="remark">f</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>) ≠ <em><span class="remark">f</span></em>(<em><span class="remark">a</span></em>,<em><span class="remark"> b</span></em>))<em><span class="remark"> </span></em>∧ (<em><span class="remark">y </span></em>=<em><span class="remark"> b</span></em>)</code></p><p>Úgy tűnik, hogy ez igen fáradságos módja annak, hogy bizonyítsuk két term, <span class="emphasis"><em>x </em></span>és <span class="emphasis"><em>a</em></span> különbözőségét.</p></div><div class="section" title="Tételbizonyítások mint segédeszközök"><div class="titlepage"><div><div><h3 class="title"><a id="id617647"/>Tételbizonyítások mint segédeszközök</h3></div></div></div><p>Eddig úgy tekintettünk a következtető rendszerekre, mint független ágensre, amelynek önállóan kell döntéseket hoznia és cselekednie. A tételbizonyítások másik felhasználása, amikor segítőként használjuk, és tanácsokkal lát el, mondjuk egy matematikust. Ebben a használati módban a matematikus felügyelőként viselkedik, feltérképezi a következő lépés meghatározásának stratégiáját, hogy mi legyen, és megkéri a tételbizonyítót, hogy töltse ki a részleteket. Egy bizonyos fokig mellékessé teszi a félig eldönthetőség problémáját, mivel a felügyelő megszüntethet egy lekérdezést, és próbálhat egy másik megközelítést, ha a lekérdezés túl sok időt vesz igénybe. A tételbizonyítás <span class="strong"><strong>bizonyítás-ellenőrző</strong></span>ként (<span class="strong"><strong>proof checker</strong></span>) is működhet, ahol a bizonyítást mi adjuk meg vázlatosan, nagyobb lépések sorozataként, és a rendszer tölti ki az egyedi következtetések részleteit, amelyek igazolják lépéseink helyességét.</p><p>A <span class="strong"><strong>Socratic következtető</strong></span> (<span class="strong"><strong>Socratic reasoner</strong></span>) egy tételbizonyító, amelynek a <code class="code">KÉRDEZ</code> függvénye nem teljes, de amely mindig elérkezhet egy megoldáshoz, ha a megfelelő kérdéssorozatot tesszük fel. Így tehát a Socratic következtetők jó segítők, feltéve, ha van egy felügyelő, aki a megfelelő <code class="code">KÉRDEZ</code> hívásokat összeállítja. Az <code class="code">ONTIC</code> (McAllester, 1989) egy Socratic következtető rendszer matematikai tételbizonyításhoz.</p></div><div class="section" title="A tételbizonyítások gyakorlati felhasználása"><div class="titlepage"><div><div><h3 class="title"><a id="id617685"/>A tételbizonyítások gyakorlati felhasználása</h3></div></div></div><p>A tételbizonyítók újszerű matematikai eredményeket produkáltak. A <code class="code">SAM</code> (Semi-Automated Mathematics) program volt az első, amely bebizonyított egy lemmát a rácselméletben (Guard és társai, 1969). Az <code class="code">AURA</code> program szintén nyitott kérdéseket válaszolt meg a matematika különféle területein (Wos és Winker, 1983). A Boyer–Moore-tételbizonyítót (Boyer és Moore, 1979) sok éven keresztül használták és bővítették. Natarajan Shankar ezt használta fel, hogy megadja az első teljes, precíz formális bizonyítását Gödel nemteljesség tételének (Shankar, 1986). Az <code class="code">OTTER</code> program az egyik legerősebb tételbizonyító. Használták a kombinatorikus logika néhány nyitott kérdésének megoldására. A legismertebb ezek közül a <span class="strong"><strong>Robbins-algebra</strong></span>. 1933-ban Herbert Robbins egy egyszerű axiómasorozatot javasolt, amely a Boole-algebra definiálására látszott alkalmasnak, de nem találtak hozzá bizonyítást (több matematikus, köztük Alfred Tarski, jelentős munkája ellenére). 1996. október 10-én, nyolc nap számítás után az EQP (az <code class="code">OTTER</code> egyik változata) megtalálta a bizonyítást (McCune, 1997).</p><p>A tételbizonyításokat alkalmazhatjuk a hardver- és szoftvertervezésben a <span class="strong"><strong>verifikáció</strong></span> (<span class="strong"><strong>verification</strong></span>) és a <span class="strong"><strong>szintézis</strong></span> (<span class="strong"><strong>synthesis</strong></span>) során felmerülő problémákra, mivel mindkét tárgyterülethez lehetséges megfelelő axiómarendszert definiálni. Így tehát a tételbizonyítási kutatást megtalálhatjuk a hardvertervezés, a programozási nyelvek és a szoftverfejlesztés területein is – nem csupán az MI-ben. A szoftver esetében az axiómák meghatározzák a programozási nyelv minden egyes szintaktikus elemének tulajdonságait. (A programokról történő következtetés eléggé hasonló az akciókról történő következtetéshez a szituációkalkulusban.) Egy algoritmus akkor tekinthető igazoltnak, ha a kimenetei megfelelnek a specifikációnak minden bemenet mellett. Az RSA nyilvános kulcskódolási algoritmust és a Boyer–Moore-féle húrillesztési algoritmust is ilyen módon igazolták (Boyer és Moore, 1984). A hardver esetében az axiómák leírják a jelek és az áramkör elemei közötti interakciókat (lásd a 8. fejezetbeli példát). Egy 16 bites összeadó tervét az <code class="code">AURA</code> igazolta (Wojcik, 1983). A logikai következtetők, amelyeket speciálisan igazolásokra terveztek, egész CPU-kat voltak képesek verifikálni, beleértve ezek időzítési tulajdonságait is (Srivas és Bickford, 1990).</p><p>Az algoritmusok formális szintézise volt a tételbizonyítások egyik első felhasználása, amint azt Cordell Green (Green, 1969a) felvázolta, aki Simon korábbi ötleteire támaszkodott (Simon, 1963). Az alapötlet az volt, hogy egyféle módon bizonyítsák azt a tételt, hogy „létezik egy <span class="emphasis"><em>p </em></span>program, amely eleget tesz egy bizonyos specifikációnak”. Ha a bizonyítást úgy korlátozzuk, hogy konstruktív legyen, a program maga is kinyerhető lesz a bizonyításból. Habár ez egy teljesen automatizált <span class="strong"><strong>deduktív szintézis</strong></span> (<span class="strong"><strong>deductive synthesis</strong></span>), legalábbis így nevezzük, még nemigen használható általános célú programok készítésére, ám a kézzel irányított deduktív szintézis már sikeresen tervezett néhány újszerű és bonyolult algoritmust. A speciális célú programok szintézise szintén aktív kutatási terület. Az <code class="code">AURA</code> tételbizonyítót sikerrel alkalmazták a hardverszintézis területén olyan áramkörök tervezésére, amelyek kompaktabbak, mint minden azt megelőző terv (Wojciechowski és Wojcik, 1983). Sok áramkör tervezésénél az ítéletlogika elegendő, mivel a legfontosabb ítéletállítások halmaza rögzített, ugyanis ezek az áramkör elemeit írják le. Az ítéletlogikai következtetés alkalmazása a hardverszintézisben ma már egy standard technika, amelynek sok nagyméretű hálózati alkalmazása létezik (lásd például Nowick és társai, 1993).</p><p>Ugyanezeket a technikákat mostanában kezdik el alkalmazni a szoftverek verifikációjához is, például a <code class="code">SPIN</code> modell ellenőrző programmal (Holzmann, 1997). A Remote Agent űrhajó vezérlési programot például sikerült verifikálni a repülés előtt és után (Havelund és társai, 2000).</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id610556" href="#id610556" class="para">92</a>] </sup> Egy klózt implikációként is reprezentálhatunk a bal oldali atomok konjunkciójával és a jobb oldali atomok diszjunkciójával, mint azt a 7.12. feladatban láthatjuk. Ezt a formát, amelyet <span class="strong"><strong>Kowalski-formá</strong></span>nak (<span class="strong"><strong>Kowalski form</strong></span>) szoktak nevezni, gyakran sokkal könnyebb kiolvasni, ha az implikációk írása jobbról balra történik (Kowalski, 1979b).</p></div></div></div></body></html>
