<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Dinamikus Bayes-hálók"><div class="titlepage"><div><div><h1 class="title"><a id="id696617"/>Dinamikus Bayes-hálók</h1></div></div></div><p>Egy <span class="strong"><strong>dinamikus Bayes-háló</strong></span> vagy <span class="strong"><strong>DBH</strong></span> (<span class="strong"><strong>dynamic Bayesian network</strong></span>, <span class="strong"><strong>DBN</strong></span>) egy olyan Bayes-háló, ami egy a 15.1. alfejezetben leírt típusú időbeli valószínűségi modellt reprezentál. (Ahogy korábban is említettük az index időbeli értelmezése helyett bármely szekvenciális értelmezés lehetséges, gyakori például az indexnek mint egy egydimenziós helyzeti pozíciónak az értelmezése is – <span class="emphasis"><em>a ford.</em></span>) A DBH-kra már láttunk példákat, a 15.2. ábrán az esernyős hálót és a 15.7. ábrán a Kalman-szűrő hálót. Általában egy DBH minden egyes szeletének tetszőleges számú állapotváltozója (<span class="strong"><strong>X</strong></span><sub>t</sub>) és bizonyítékváltozója (<span class="strong"><strong>E</strong></span><sub>t</sub>) lehet. Az egyszerűség kedvéért fel fogjuk tenni, hogy a változók és kapcsolataik szeletről szeletre pontosan ismétlődnek, és hogy a DBH egy elsőrendű Markov-folyamatot reprezentál, így minden változónak csak a saját szeletében vagy a közvetlenül megelőző szeletben lehetnek szülei.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Nyilvánvaló, hogy minden rejtett Markov-modell reprezentálható mint egy DBH, egyetlen állapotváltozóval és egyetlen bizonyítékváltozóval. Az is fennáll, hogy minden diszkrét változós DBH reprezentálható mint egy RMM; ahogyan a 15.3. alfejezetben megmutattuk, a DBH összes állapotváltozója összekombinálható egyetlen állapotváltozóvá, aminek az értékei az egyes állapotváltozók értékeinek az összes lehetséges együttese. Azonban ha minden RMM egy DBH, és minden DBH átfordítható egy RMM-be, akkor mi a különbség? A különbség abban rejlik, hogy <span class="emphasis"><em>egy komplex rendszer állapotának az őt alkotó változókra történő dekomponálásával a DBH képes kihasználni az időbeli valószínűségi modell ritkaságát</em></span>. Tegyük fel például, hogy egy DBH-nak 20 bináris állapotváltozója van, amelyek mindegyikének három szülője van az előző szeletben. Ekkor a DBH állapotátmenet-modellje 20 × 2<sup>3 </sup> =160 valószínűségi értéket tartalmaz, míg a hozzátartozó RMM-nek 2<sup>20</sup> állapota és ezért 2<sup>40</sup>, azaz durván egybillió átmenet-valószínűség értéke van az állapotátmenet-mátrixban. Ez legalább három ok miatt is rossz: először, hogy az RMM maga sokkal több tárat igényel, másodszor, hogy a hatalmas állapotátmenet-mátrix az RMM-következtetést sokkal költségesebbé teszi, harmadszor, hogy ilyen hatalmas számú paraméter megtanulásának problémája a tiszta RMM-modelleket alkalmazhatatlanná teszi nagy problémák esetén. A DBH-k és az RMM-ek közötti kapcsolat nagyjából analóg a hagyományos Bayes-hálók és a teljes táblázatos együttes eloszlások közötti kapcsolathoz.</p></div><p>Már megmutattuk, hogy minden Kalman-szűrő reprezentálható egy DBH-ban folytonos változókkal és lineáris Gauss feltételes eloszlásokkal (lásd 15.7. ábra). Az előző fejezet végén tárgyaltak miatt azzal is tisztában kell lenni, hogy <span class="emphasis"><em>nem</em></span> minden DBH reprezentálható egyetlen Kalman-szűrő modellel. Egy Kalman-szűrőnél az aktuális állapoteloszlás mindig egy egyedülálló többváltozós Gauss-eloszlás – azaz egyetlen „dudor” egy konkrét helyen. A DBH-k ezzel szemben tetszőleges eloszlást képesek modellezni. Számos valós alkalmazásnál ez a rugalmasság elengedhetetlen. Gondoljuk meg például a kulcsaim jelenlegi helyét. Lehetnek a zsebeimben, az éjjeli szekrényen, a konyhapulton vagy a bejárati ajtóban himbálódzva. Egyetlen Gauss-dudornak, ami ezt az összes helyet magában foglalja, jelentős valószínűséget kell rendelni ahhoz, hogy a kulcsok az előszobában a levegőben vannak. A valós világ olyan aspektusai, mint céltudatos ágensek, akadályok és zsebek „nemlinearitásokat” vezetnek be, amelyek diszkrét és folytonos változók kombinációját igénylik, hogy egy elfogadható modellhez jussunk.</p><div class="section" title="DBH-k létrehozása"><div class="titlepage"><div><div><h2 class="title"><a id="id696686"/>DBH-k létrehozása</h2></div></div></div><p>Egy DBH létrehozásához háromfajta információt kell megadni: a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>0</sub>) a priori eloszlást az állapotváltozók felett; a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>|<span class="strong"><strong>X</strong></span><sub>t</sub>) állapotátmenet-modellt; és a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>E</strong></span><sub>t</sub>|<span class="strong"><strong>X</strong></span><sub>t</sub>) érzékelő modellt. Az állapotátmenet- és érzékelő modell megadásához, meg kell adni az egymást követő szeletek közötti és az állapot- és bizonyítékváltozók közötti kapcsolatok topológiáját. Mivel az állapotátmenet- és érzékelő modelleket stacionáriusnak – minden <span class="emphasis"><em>t</em></span>-re azonosnak – tételezzük fel, a legkényelmesebb egyszerűen az első szeletre megadni őket. Például az esernyős világ teljes DBH-specifikációját megadja az a három csomópontos háló, ami a 15.11. (a) ábrán látható. Ebből a specifikációból a teljes (egyik irányban végtelen) DBH megkonstruálható az első szelet megfelelő másolásával.</p><p>Gondoljunk most át egy érdekesebb példát: egy akkumulátorhajtású, az <span class="emphasis"><em>X</em></span>–<span class="emphasis"><em>Y</em></span> síkon mozgó robot követesét, ahogyan azt a 15.1. alfejezetben bevezettük. Elsőként szükségünk van állapotváltozókra, amelyek mind az <span class="strong"><strong>X</strong></span><sub>t </sub>= (<span class="emphasis"><em>X<sub>t</sub></em></span>, <span class="emphasis"><em>Y<sub>t</sub></em></span>) pozíció-, mind az <span class="inlinemediaobject"><img src="math/mi-15-0048.gif" alt="DBH-k létrehozása"/></span> sebességkomponenseket magukban foglalják. Feltételezünk valamilyen pozíciómérő módszert – akár egy rögzített kamerát vagy egy felszíni GPS-t (Global Positioning System) –, ami a <span class="strong"><strong>Z</strong></span><sub>t</sub> méréseket eredményezi. A pozíció a következő időpontban a jelenlegi pozíciótól és sebességtől függ, ugyanúgy, mint a standard Kalman-szűrő modellben. A sebesség a következő időpontban a jelen sebességtől és az akkumulátor állapotától függ. Felveszünk még egy <span class="emphasis"><em>Akkumulátor<sub>t </sub></em></span>változót az aktuális akkumulátor töltési szintjének reprezentálására, aminek szülői az előző akkumulátorszint és a sebesség, és felveszünk még egy <span class="emphasis"><em>AMérő<sub>t</sub></em></span> változót, ami az akkumulátor töltési szintjét méri. Ez szolgáltatja a 15.11. (b) ábrán látható alapmodellt.</p><p>Érdemes részletesebben megvizsgálni az <span class="emphasis"><em>AMérő<sub>t</sub></em></span>-hez tartozó érzékelőmodell tulajdonságait. Tegyük fel az egyszerűség kedvéért, hogy mind az <span class="emphasis"><em>Akkumulátor<sub>t</sub></em></span>, mind az <span class="emphasis"><em>AMérő<sub>t</sub></em></span> diszkrét értékeket vehetnek fel 0-tól 5-ig – igen hasonlóan egy tipikus laptop számítógép akkumulátormérőjéhez. Ha a mérő mindig pontos akkor a <span class="strong"><strong>P</strong></span>(<span class="emphasis"><em>AMérő<sub>t</sub></em></span>|<span class="emphasis"><em>Akkumulátor<sub>t</sub></em></span>) FVT-nek végig 1,0 valószínűségeket kell tartalmaznia az „átlójában” és 0,0 valószínűségeket máshol. A valóságban a mérésekben a zaj mindig felbukkan. Folytonos mérésekre, egy kis szórású Gauss-eloszlást lehetne ehelyett használni.<sup>[<a id="id698679" href="#ftn.id698679" class="footnote">160</a>]</sup> A diszkrét változóinknál a Gauss-eloszlást egy olyan eloszlással közelíthetjük, amelyben a hiba valószínűsége a megfelelő módon csökken, így nagy hiba valószínűsége igen kicsi. A <span class="strong"><strong>Gauss-hibamodell</strong></span> (<span class="strong"><strong>Gaussian error model</strong></span>) kifejezést fogjuk használni mind a folytonos, mind a diszkrét változatokra.</p><div class="figure"><a id="id698700"/><p class="title"><strong>15.11. ábra - (a) Az esernyős DBH-hoz tartozó a priori eloszlás, az állapotátmenet-modell és az érzékelő modell megadása. Az összes következő szelet feltevésünk szerint az 1. szelet másolata. (b) Egy <span class="emphasis"><em>X</em></span>–<span class="emphasis"><em>Y</em></span> síkon való robotmozgáshoz tartozó egyszerű DBH.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-11.png" alt="(a) Az esernyős DBH-hoz tartozó a priori eloszlás, az állapotátmenet-modell és az érzékelő modell megadása. Az összes következő szelet feltevésünk szerint az 1. szelet másolata. (b) Egy X–Y síkon való robotmozgáshoz tartozó egyszerű DBH."/></div></div></div><p>A robotikában bárki, aki egy kevés gyakorlattal rendelkezik a számítógépes folyamatvezérlésben vagy az automatikus érzékelés más eseteiben, rögtön tanúskodik arról a tényről, hogy a kis mennyiségű mérési hiba gyakran a legkevésbé fontos a problémák között. Ugyanis a valódi érzékelők elromlanak, és amikor egy érzékelő elromlik, akkor nem küld szükségszerűen egy jelet azzal, hogy „Ó, egyébiránt az adat, amit küldök, egy halom zagyvaság.” Ehelyett egyszerűen küldi a zagyvaságot. A meghibásodás legegyszerűbb formáját <span class="strong"><strong>átmeneti hibá</strong></span>nak (<span class="strong"><strong>transient failure</strong></span>) nevezik, amikor az érzékelő alkalmanként elhatározza, hogy valami zagyvaságot küld. Például az akkumulátor szintérzékelőjének lehet olyan szokása, hogy nullát küld, amikor valaki meglöki a robotot, még akkor is, ha az akkumulátor teljesen fel van töltve.</p><p>Lássuk, mi történik, amikor egy átmeneti hiba bekövetkezik egy Gauss-hibamodellnél, ami nem tudja kezelni az ilyen hibákat. Tételezzük fel például, hogy a robot csendesen üldögél, és 20 egymást követő mérés az akkumulátoron 5-öt ad. Ezután az akkumulátormérő időleges kiesése miatt a következő mérés eredménye <span class="emphasis"><em>AMérő</em></span><sub>21 </sub>= 0. Mire kell következtetnünk egy egyszerű Gauss-hibamodellből az <span class="emphasis"><em>Akkumulátor</em></span><sub>21</sub>-gyel kapcsolatban. A Bayes-szabály szerint a válasz függ mind a <span class="strong"><strong>P</strong></span>(<span class="emphasis"><em>AMérő</em></span><sub>21 </sub>= 0|<span class="emphasis"><em>Akkumulátor</em></span><sub>21</sub>) érzékelő modelltől, mind a <span class="strong"><strong>P</strong></span>(<span class="emphasis"><em>Akkumulátor</em></span><sub>21</sub>|<span class="emphasis"><em>AMérő</em></span><sub>1:20</sub>) előrejelzéstől. Ha egy nagy érzékelési hiba valószínűsége szignifikánsan kisebb, mint az <span class="emphasis"><em>Akkumulátor</em></span><sub>21 </sub>= 0-ba való<sub> </sub>átmenet valószínűsége, még ha ez utóbbi nagyon valószínűtlen is, akkor az a posteriori eloszlás nagy valószínűséget fog rendelni a lemerült akkumulátorhoz. Egy második nulla értékű mérési eredmény <span class="emphasis"><em>t </em></span>= 22-nél ezt a konklúziót majdnem biztossá teszi. Ha az átmeneti hiba aztán eltűnik, és a jelzett érték visszaáll 5-re <span class="emphasis"><em>t </em></span>= 23-tól, akkor az akkumulátorszint becslése gyorsan vissza fog állni 5-re, szinte varázsütésre. Ezt az eseménysort mutatja be a 15.12. (a) ábra felső görbéje, ami az <span class="emphasis"><em>Akkumulátor<sub>t</sub></em></span> várható értékét mutatja idő szerint egy diszkrét Gauss-hibamodellt használva. </p><div class="figure"><a id="id698799"/><p class="title"><strong>15.12. ábra - (a) Felső görbe: az Akkumulátort várható értékének a pályagörbéje egy olyan megfigyelési sorozatnál, ami csak 5-ösöket tartalmaz, kivéve a 0-kat a t = 21 és a t = 22 időpontokban, egy egyszerű Gauss-hibamodell felhasználásával. Alsó görbe: a pályagörbe, amikor a megfigyelések 0-val folytatódnak t = 21-től. (b) Ugyanez a kísérlet az átmenetihiba-modellel elvégezve. Vegyük észre, hogy az átmeneti hibát jól kezeli, de a végleges hiba túlzott pesszimizmust eredményez.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-12.png" alt="(a) Felső görbe: az Akkumulátort várható értékének a pályagörbéje egy olyan megfigyelési sorozatnál, ami csak 5-ösöket tartalmaz, kivéve a 0-kat a t = 21 és a t = 22 időpontokban, egy egyszerű Gauss-hibamodell felhasználásával. Alsó görbe: a pályagörbe, amikor a megfigyelések 0-val folytatódnak t = 21-től. (b) Ugyanez a kísérlet az átmenetihiba-modellel elvégezve. Vegyük észre, hogy az átmeneti hibát jól kezeli, de a végleges hiba túlzott pesszimizmust eredményez."/></div></div></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A helyreállás ellenére előfordul (<span class="emphasis"><em>t</em></span> = 22-nél), hogy a robot meg van győződve, hogy az akkumulátora lemerült; feltehetően ekkor ki kell küldenie egy segítség jelet, és le kell kapcsolnia. Sajnos a túlegyszerűsített érzékelő modellje tévútra vezette. Hogyan lehet ezt kijavítani? Gondoljunk egy ismerős példára az emberek mindennapos vezetési gyakorlatából: éles kanyarokban vagy meredek hegyeken néha felvillan az „üzemanyagtartály üres” figyelmeztető lámpa. A segélykérő telefon keresése helyett inkább az szokott az ember eszébe jutni, hogy az üzemanyagmérő gyakran igen nagy hibákat ad, amikor az üzemanyag lötyög a tartályban. A történet tanulsága a következő: <span class="emphasis"><em>az érzékelő hibájának helyes kezeléséhez a rendszer érzékelő modelljének tartalmaznia kell a meghibásodás lehetőségét</em></span>.</p></div><p>Egy érzékelő legegyszerűbb hibamodellje egy bizonyos valószínűséggel megengedi, hogy az érzékelő teljesen helytelen értéket adjon vissza, függetlenül a világ valódi állapotától. Például ha az akkumulátormérő 0-t visszaadva hibázik, azt mondhatjuk, hogy</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">AMérő<sub>t </sub></span></em>= 0|<em><span class="remark">Akkumulátor<sub>t </sub></span></em>= 5) = 0,03</code></p><p>ami feltételezhetően sokkal nagyobb, mint az a valószínűség, amit az egyszerű Gauss-hibamodell rendelne hozzá. Hívjuk ezt az <span class="strong"><strong>átmenetihiba-modell</strong></span>nek (<span class="strong"><strong>transient failure model</strong></span>). Hogyan segít ez, amikor a 0 jelzéssel kerülünk szembe? Feltételezve, hogy az az <span class="emphasis"><em>előre jelzett</em></span> valószínűség, hogy az akkumulátor lemerült, az eddigi jelzések alapján sokkal kisebb, mint 0,03, akkor az <span class="emphasis"><em>AMérő</em></span><sub>21 </sub>= 0 megfigyelés legjobb magyarázata az, hogy az érzékelő időlegesen meghibásodott. Szemléletesen úgy képzelhetjük el a bizonyosságot az akkumulátor feltöltöttségéről, mint aminek van egy bizonyos mennyiségű „tehetetlensége”, ami segít úrrá lenni a mérőjelzés időleges zavarain. A 15.12. (b) ábra felső görbéjén látható, hogy az átmenetihiba-modell képes átmeneti hibákat kezelni a bizonyosság katasztrofális változásai nélkül. </p><p>Ennyit hát az időleges zavarokról. Mi a helyzet az érzékelő állandó meghibásodásával? Sajnos, az ilyenfajta meghibásodások túlságosan is gyakoriak. Ha az érzékelő húsz 5-ös jelzést ad, amit húsz 0-s jelzés követ, akkor az előző bekezdésben leírt átmenetihiba-modell azt fogja eredményezni, hogy a robot fokozatosan azt kezdi hinni, hogy az akkumulátora lemerült, amikor valójában az is lehet, hogy az érzékelő hibásodott meg. A 15.12. (b) ábrán látható alsó görbe mutatja a bizonyosság „pályagörbét” erre az esetre. A <span class="emphasis"><em>t</em></span> = 25 időpontra – 5 darab 0 jelzésre – a robot meg van győződve, hogy az akkumulátora üres. Nyilvánvaló, hogy jobban szeretnénk, ha a robot azt hinné, hogy az akkumulátor mérője romlott el – ha valóban ez a valószínűbb esemény.</p><p>Nem meglepő, hogy egy tartós hiba kezeléséhez szükségünk lesz egy <span class="strong"><strong>tartóshiba-modell</strong></span>re (<span class="strong"><strong>persistent failure model</strong></span>), ami leírja, hogyan működik az érzékelő normális körülmények között és meghibásodás után. Ennek eléréséhez ki kell egészítenünk a rendszer rejtett állapotát egy további változóval, mondjuk egy <span class="emphasis"><em>AMHibás-</em></span>sal,<span class="emphasis"><em> </em></span>ami megadja az akkumulátormérő állapotát. A hiba tartós megmaradását egy nyíllal kell modellezni, ami az <span class="emphasis"><em>AMHibás</em></span><sub>0</sub>-t az <span class="emphasis"><em>AMHibás</em></span><sub>1</sub>-hez kapcsolja. Ennek a <span class="strong"><strong>megmaradási nyíl</strong></span>nak (<span class="strong"><strong>persistence arc</strong></span>) olyan FVT-je van, ami minden időlépésben megengedi a meghibásodást egy kis valószínűséggel, mondjuk 0,001-gyel, de leírja, hogy ha egy érzékelő elromlott, akkor az rossz is marad. Amikor az érzékelő rendben van, akkor az <span class="emphasis"><em>AMérő</em></span> érzékelő modellje megegyezik az átmenetihiba-modellel; amikor az érzékelő rossz, az <span class="emphasis"><em>AMérő</em></span> mindig 0, függetlenül az akkumulátor aktuális töltöttségétől.</p><p>Az akkumulátor érzékelőjének tartóshiba-modellje a 15.13. (a) ábrán látható. A teljesítménye két adatsoron (az időleges zavarjelnél és a tartós meghibásodáson) a 15.13. (b) ábrán látható. Számos dolgot érdemes megfigyelni ezeken a görbéken. Először is, hogy az időleges zavarjelnél az érzékelő hibájának a valószínűsége jelentősen megemelkedik a második 0 jelzés után, de azonnal visszaesik, ahogy egy 5-öst megfigyelt. Másodszor, hogy tartós hibánál az érzékelő hibájának a valószínűsége gyorsan megemelkedik 1 közelébe, és ott marad. Végül, hogy amikortól az érzékelőt hibásnak hiszi, a robot csak azt tételezheti fel, hogy az akkumulátor „normális” sebességgel veszti el töltését, ahogy az <span class="emphasis"><em>E</em></span>(<span class="emphasis"><em>Akkumulátor<sub>t</sub></em></span>|<span class="emphasis"><em>...</em></span>) fokozatosan csökkenő szintje ezt mutatja.</p><div class="figure"><a id="id698931"/><p class="title"><strong>15.13. ábra - (a) Az érzékelő állapotváltozóját bemutató DBH-részlet. Ez a változó szükséges az akkumulátormérő végleges hibájának a modellezésére. (b) Felső görbék: az Akkumulátort várható értékének a pályagörbéje az „átmeneti hibájú” és a „tartós hibájú” megfigyelési sorozatoknál. Alsó görbék: az AMHibás valószínűségének pályagörbéi a két megfigyelési sorozatnál.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-13.png" alt="(a) Az érzékelő állapotváltozóját bemutató DBH-részlet. Ez a változó szükséges az akkumulátormérő végleges hibájának a modellezésére. (b) Felső görbék: az Akkumulátort várható értékének a pályagörbéje az „átmeneti hibájú” és a „tartós hibájú” megfigyelési sorozatoknál. Alsó görbék: az AMHibás valószínűségének pályagörbéi a két megfigyelési sorozatnál."/></div></div></div><p>Eddig csupán felületesen érintettük a komplex folyamatok reprezentálásának problémáját. Az állapotátmenet-modellek változatossága óriási, magában foglalva egymástól olyan távol eső témákat, mint például az emberi endokrin rendszer (hormonális működés) és az autópályákon közlekedő járművek modellezését. Az érzékelő modellezés egymagában is hatalmas terület, de még az olyan nehezen megfogható jelenségek, mint például az érzékelő elállítódása, hirtelen dekalibrálása és a külső körülményeknek (mint az időjárásnak) a hatásai az érzékelő jelzésein is kezelhetők explicit reprezentációkkal a dinamikus Bayes-hálóknál.</p></div><div class="section" title="Egzakt következtetés DBH-kban"><div class="titlepage"><div><div><h2 class="title"><a id="id698943"/>Egzakt következtetés DBH-kban</h2></div></div></div><p>Miután felvázoltunk néhány ötletet  komplex folyamatok DBH-kkal történő reprezentálásáról, most a következtetés kérdését vizsgáljuk meg. Bizonyos értelemben ezt a kérdést már megválaszoltuk: a dinamikus Bayes-hálók Bayes-hálók, és nekünk már vannak algoritmusaink Bayes-hálóban történő következtetésre. Adott megfigyeléssorozat esetén a teljes Bayes-hálós reprezentáció felépíthető a szeletek megismétlésével, ameddig a háló elég nagy nem lesz a megfigyelések befogadásához, ahogy a 15.14. ábrán látható. Ezt a technikát <span class="strong"><strong>kibontás</strong></span>nak (<span class="strong"><strong>unrolling</strong></span>) nevezik. (Technikailag a DBH ekvivalens egy egy irányban végtelen hálóval, amit végtelen számú kibontással kapunk. Az utolsó megfigyelés után hozzáadott szeleteknek nincs hatása a következtetésre a megfigyelési periódusban, ezért elhagyhatók.) Ha a DBH-t már kibontottuk, alkalmazhatók a következtető algoritmusok: változó eliminálás, egyesítési fa módszere stb. (lásd 14. fejezet).</p><p>Sajnos a kibontás naiv alkalmazása nem volna valami hatékony. Ha szűrést vagy simítást szeretnénk elvégezni megfigyelések <span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub> hosszú sorozatán, akkor a kibontott háló tárigénye <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>t</em></span>) lenne, és korlát nélkül nőne, amint még több megfigyelést adnánk hozzá. Ráadásul ha egyszerűen újra lefuttatjuk a következtető algoritmust minden időpontban, amikor megfigyelés érkezik, a következtetési ideje frissítésenként szintén <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>t</em></span>) szerint fog növekedni.</p><div class="figure"><a id="id698986"/><p class="title"><strong>15.14. ábra - Egy dinamikus Bayes-háló kibontása: a szeletek ismétlődnek befogadva a megfigyelési sorozatot (a halvány csomópontok). További szeleteknek már nincs hatása a megfigyelési perióduson belüli következtetésre. Ha a DBH-t kibontottuk, bármely következtetési algoritmus használható – változó eliminálás, egyesítési fa módszerek és így tovább –, ami a 14. fejezetben szerepel.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-14.png" alt="Egy dinamikus Bayes-háló kibontása: a szeletek ismétlődnek befogadva a megfigyelési sorozatot (a halvány csomópontok). További szeleteknek már nincs hatása a megfigyelési perióduson belüli következtetésre. Ha a DBH-t kibontottuk, bármely következtetési algoritmus használható – változó eliminálás, egyesítési fa módszerek és így tovább –, ami a 14. fejezetben szerepel."/></div></div></div><p class="Tartalom3">A 15.2. alfejezetre visszatekintve látjuk, hogy állandó idő- és tárigény elérhető a szűrési frissítésnél, ha a számítások rekurzív módon végezhetők. Lényegében a szűrési frissítés (15.3) egyenlete az előző időponthoz tartozó állapotváltozók <span class="emphasis"><em>kiösszegzését</em></span> <span class="emphasis"><em>(summing out) </em></span>végzi el, hogy megkapja az új időponthoz tartozó eloszlást. Változók kiösszegzése pedig pontosan az, amit a <span class="strong"><strong>változóeliminálás</strong></span> (<span class="strong"><strong>variable elimination</strong></span>) algoritmusa elvégez (lásd 14.10. ábra), és megmutatható, hogy a változó eliminálás időrendi változókon futva pontosan a szűrés rekurzív frissítésének (15.3) egyenlet szerinti működését utánozza. A módosított algoritmus egyszerre legfeljebb két szeletet tart a memóriában: kezdve a 0. szelettel, hozzáadjuk az 1. szeletet, kiösszegezzük a 0. szeletet, aztán hozzáadjuk a 2. szeletet, aztán kiösszegezzük az 1. szeletet és így tovább. Ezzel a módszerrel elérhető az állandó idő- és tárigény a szűrési frissítésnél. (Ugyanez a teljesítmény elérhető az egyesítési fa algoritmusának megfelelő módosításaival.) A 15.10. feladat kéri ennek a ténynek az ellenőrzését az esernyős hálóra.</p><p class="Tartalom3">Eddig tartottak a jó hírek, most következnek a rosszak: megmutatható, hogy egy frissítés idő- és tárkomplexitásának az „állandója” majdnem minden esetben exponenciális az állapotváltozók számában. Az történik ugyanis, hogy amint a változó eliminálás halad, a tényezők megnőnek, magukban foglalva az összes állapotváltozót (vagy pontosabban azokat az állapotváltozókat, amelyeknek van szülőjük az előző időszeletben). A maximális tényezőméret <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d<sup>n</sup></em></span><sup>+1</sup>),<span class="emphasis"><em> </em></span>a frissítés költsége pedig<span class="emphasis"><em> O</em></span>(<span class="emphasis"><em>d<sup>n</sup></em></span><sup>+2</sup>)<span class="emphasis"><em>.</em></span></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p class="Tartalom3">Természetesen ez sokkal kevesebb, mint az RMM frissítésének költsége, ami <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>d</em></span><sup>2<span class="emphasis"><em>n</em></span></sup>)<span class="emphasis"><em>, </em></span>de nagyszámú változónál még mindig kivitelezhetetlenül nagy. Ezt a súlyos tényt nehéz elfogadni. Ugyanis a következőt jelenti: <span class="emphasis"><em>annak ellenére, hogy a DBH-k felhasználhatók olyan nagyon komplex időbeli folyamatok reprezentálására, amelyek számos, ritkán összekapcsolt változóval rendelkeznek, nem vagyunk képesek hatékonyan és pontosan következtetni ezekről a folyamatokról</em></span>. A DBH-modell, ami az összes változó feletti<span class="emphasis"><em> </em></span>a priori együttes eloszlást reprezentálja, faktorizálható az őt alkotó FVT-kre, de az a posteriori együttes eloszlás a megfigyelési szekvencián vett feltétellel – azaz az előre üzenet – általában már <span class="emphasis"><em>nem</em></span> faktorizálható. Eddig senki sem talált megoldást erre a problémára, annak ellenére, hogy megoldást a tudomány és mérnöki tervezés fontos területei tudnák nagyon jól hasznosítani. Így közelítő módszerekre kell szorítkoznunk. </p></div></div><div class="section" title="Közelítő következtetés DBH-kban"><div class="titlepage"><div><div><h2 class="title"><a id="id699082"/>Közelítő következtetés DBH-kban</h2></div></div></div><p class="Tartalom3">A 14. fejezet két következtető módszert írt le: a valószínűségi súlyozást (lásd 14.14. ábra) és a Markov lánc Monte Carlo módszert (MCMC, lásd 14.15. ábra). A kettő közül az első igazítható legkönnyebben a DBH-keretbe. Látni fogjuk azonban, hogy egy gyakorlati módszer kialakulásához a standard valószínűségi súlyozó algoritmuson számos javításra van szükség.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Emlékezzünk vissza, hogy a valószínűségi súlyozás a működése során a nem bizonyítékváltozókat mintavételezi azok topológiai sorrendjében, minden mintát azzal a valószínűséggel súlyozva, amennyire egyezik a megfigyelt bizonyítékváltozókkal. Ahogyan az egzakt közelítő algoritmusok esetében is, a valószínűségi súlyozást közvetlenül alkalmazhatnánk egy kibontott DBH-ra, de ugyanazok a problémák jelentkeznének, nevezetesen, hogy a megfigyeléssorozat növekedésével a frissítésenkénti idő- és tárigény növekedne. A probléma az, hogy az alapalgoritmus az egyes mintákat egymás után sorban végigfuttatja a háló teljes hosszában. Ehelyett egyszerűen az összes <span class="emphasis"><em>N</em></span> mintát együtt futtathatnánk a DBH-n keresztül, szeletenként egyszerre haladva. (Azaz a mintavételeket az újragenerálás költségének elkerülése miatt nyilvántartanánk és fokozatosan frissítenénk – <span class="emphasis"><em>a ford</em></span>.) A módosított algoritmus illeszkedik a szűrési algoritmus általános mintájához, az<span class="emphasis"><em> N</em></span> mintával mint előrefelé üzenettel. Az első kulcsgondolat az, hogy ekkor <span class="emphasis"><em>a mintákat magukat használjuk az állapoteloszlás egy közelítő reprezentációjaként</em></span>. Ez eleget tesz a frissítésenkénti „állandó” időigénynek, bár az állandó értéke a minták számától függ, aminek elég nagynak kell lenni a valódi a posteriori eloszlás elfogadható közelítéséhez. Szintén nincs szükség a DBH kibontására, mivel csak az aktuális és a következő szeletet kell memóriában tartani.</p></div><p>A valószínűségi súlyozás tárgyalásakor a 14. fejezetben rámutattunk, hogy az algoritmus pontossága leromlik, ha a bizonyítékváltozók „lentebbiek” a mintavételezett változóknál, mivel ekkor a minták generálására nincsen hatással a bizonyíték. Egy DBH tipikus struktúráját megnézve – mondjuk az esernyős DBH-t a 15.14. ábrán – látjuk, hogy a korai állapotváltozók mintavételezésénél valóban nem hasznosulnak a későbbi bizonyítékok. Valójában, még tüzetesebben megnézve azt láthatjuk, hogy az <span class="emphasis"><em>állapotváltozók egyikének sincs egyetlen bizonyítékváltozó sem</em></span> az ősei között! Így, bár az egyes minták súlya függeni fog a bizonyítékoktól, a generált minták aktuális halmaza teljesen független lesz a bizonyítékoktól. Például még ha a főnök mindennap el is hozza az esernyőjét, a mintavételi folyamat ekkor is hallucinálhat véget nem érő kánikulát. A gyakorlatban ez azt jelenti, hogy a minták azon aránya, ami elfogadhatóan közel marad az események valódi sorához, exponenciálisan csökken <span class="emphasis"><em>t</em></span>-vel, a megfigyelés sorozat hoszszával; máshogy fogalmazva egy adott pontossági szint fenntartásához, a minták számát exponenciálisan növelni kell <span class="emphasis"><em>t</em></span> függvényében. Mivel egy valós időben működő szűrő algoritmus csak rögzített számú mintát tud használni, a gyakorlatban az történik, hogy igen kis számú frissítési lépés után a hiba határtalanul megnő.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Világos, hogy jobb megoldásra van szükségünk. A második kulcsgondolat az, hogy <span class="emphasis"><em>a minták halmazát az állapottér nagy valószínűségű részeire koncentráljuk</em></span>. Ez megtehető a megfigyelések szerint nagyon alacsony súlyú minták eldobásával, miközben megsokszorozzuk a nagy súlyúakat. Ezen a módon a minták populációja elfogadhatóan közel marad a valósághoz. Ha úgy gondolunk a mintákra, mint egy eszközre az a posteriori<span class="emphasis"><em> </em></span>eloszlás modellezéséhez, akkor van értelme több mintát használni az állapottér azon részeiben, ahol az a posteriori valószínűség nagyobb.</p></div><p>Az algoritmusok egy családját, a <span class="strong"><strong>részecskeszűrés</strong></span>t (<span class="strong"><strong>particle filtering</strong></span>) pontosan ennek elvégzésére tervezték. A részecskeszűrés a következőképpen működik: először egy <span class="emphasis"><em>N</em></span> mintájú populációt alkotunk a 0. időpontbeli <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>0</sub>) a priori eloszlás mintavételezéséből. Ezután minden időpontban egy frissítési ciklus ismétlődik:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Minden mintát előreterjesztünk mintavételezve az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t+</em></span>1</sub> következő állapot értéket feltéve, hogy a minta aktuális értéke <span class="strong"><strong>x</strong></span><sub>t</sub> adott, és felhasználva a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub><span class="emphasis"><em>t+</em></span>1</sub>|<span class="strong"><strong>x</strong></span><sub>t</sub>) állapotátmenet-modellt.</p></li><li class="listitem"><p>Minden mintát súlyozunk azzal a <span class="emphasis"><em>P</em></span>(<span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t+</em></span>1</sub>|<span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t+</em></span>1</sub>)<span class="emphasis"><em> </em></span>valószínűséggel, amit az új bizonyítékhoz rendel.</p></li><li class="listitem"><p>A populációt újra mintavételezzük, hogy egy <span class="emphasis"><em>N</em></span> mintájú új populációt generáljunk. Minden új mintát a jelenlegi populációból választunk ki; egy konkrét minta kiválasztásának a valószínűsége arányos a súlyával. Az új minták súlyozatlanok.</p></li></ul></div><p class="Tartalom3">Az algoritmus részletesen a 15.15. ábrán látható, és működését az esernyős DBH esetén a 15.16. ábra szemlélteti.</p><div class="figure"><a id="id699247"/><p class="title"><strong>15.15. ábra - A részecskeszűrés algoritmus megvalósítása egy rekurzív frissítési művelettel és állapottal (ami a minták halmaza). A mintavételező lépések mindegyike az aktuális szelet változóinak a mintavételezését jelenti egy topológiai sorrendben, hasonlóan, mint a <code class="code">PRIOR-MINTA</code>-ban. A <code class="code">SÚLYOZOTT-MINTA-VISSZATÉTELLEL</code> művelet megvalósítható <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>N</em></span>) várható futási idővel.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-15.png" alt="A részecskeszűrés algoritmus megvalósítása egy rekurzív frissítési művelettel és állapottal (ami a minták halmaza). A mintavételező lépések mindegyike az aktuális szelet változóinak a mintavételezését jelenti egy topológiai sorrendben, hasonlóan, mint a PRIOR-MINTA-ban. A SÚLYOZOTT-MINTA-VISSZATÉTELLEL művelet megvalósítható O(N) várható futási idővel."/></div></div></div><p>Megmutatjuk, hogy ez az algoritmus konzisztens – így helyes valószínűségeket ad, ahogy <span class="emphasis"><em>N</em></span> a végtelenbe tart – meggondolva, hogy mi történik egy frissítési ciklus alatt. Feltesszük, hogy a mintapopuláció a <span class="emphasis"><em>t</em></span> időpontbeli <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub> előre üzenet egy helyes reprezentációjaként indul. Az <span class="emphasis"><em>N</em></span>(<span class="strong"><strong>x</strong></span><sub>t</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) jelölést használva azon minták számára, amelyek az <span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub> megfigyelések feldolgozása után az <span class="strong"><strong>x</strong></span><sub>t</sub> állapotban vannak, azt kapjuk, hogy</p><p><code class="code"><em><span class="remark">N</span></em>(<em><span class="remark">x</span></em><sub>t</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>) /N = <em><span class="remark">P</span></em>(<em><span class="remark">x</span></em><sub>t</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>)						(15.21)</code></p><p>nagy <span class="emphasis"><em>N</em></span>-ekre. Most minden mintát előreterjesztünk mintavételezve az állapotváltozókat a <span class="emphasis"><em>t </em></span>+ 1 időponban az adott <span class="emphasis"><em>t</em></span> időponthoz tartozó mintabeli értékek mellett. Az egyes <span class="strong"><strong>x</strong></span><sub>t</sub> állapotokból az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> állapotot elérő minták száma az átmenet-valószínűség és az <span class="strong"><strong>x</strong></span><sub>t </sub>populáció számának a szorzata; így az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> állapotot elérő minták teljes száma</p><p><span class="inlinemediaobject"><img src="math/mi-15-0049.gif" alt="A részecskeszűrés algoritmus megvalósítása egy rekurzív frissítési művelettel és állapottal (ami a minták halmaza). A mintavételező lépések mindegyike az aktuális szelet változóinak a mintavételezését jelenti egy topológiai sorrendben, hasonlóan, mint a PRIOR-MINTA-ban. A SÚLYOZOTT-MINTA-VISSZATÉTELLEL művelet megvalósítható O(N) várható futási idővel."/></span></p><div class="figure"><a id="id699423"/><p class="title"><strong>15.16. ábra - A részecskeszűrés frissítési ciklusa az esernyő DBH-nál <span class="emphasis"><em>N </em></span>= 10 esetén, bemutatva minden egyes állapot mintapopulációját. (a) A <span class="emphasis"><em>t</em></span> időpontban 8 minta jelez <span class="emphasis"><em>Eső</em></span>-t és 2 ¬<span class="emphasis"><em>Eső</em></span>-t. Mindegyiket továbbterjesztjük a következő állapotátmenet-modell szerinti mintavételezésével. A <span class="emphasis"><em>t </em></span>+ 1 időpontban 6 minta jelez <span class="emphasis"><em>Eső</em></span>-t és 4 ¬<span class="emphasis"><em>Eső</em></span>-t. (b) A <span class="emphasis"><em>t </em></span>+ 1 időpontban ¬<span class="emphasis"><em>Esernyő</em></span> a megfigyelés értéke. Mindegyik mintát súlyozzuk a mintának a megfigyelésre vett feltételes valószínűségével, amit a körök nagysága jelez. (c) Egy új 10-es mintahalmaz generálódott az aktuális halmazból történő súlyozott sorsolással, 2 olyan mintát eredményezve, ami <span class="emphasis"><em>Eső</em></span>-t jelez, és 8 olyat, ami ¬<span class="emphasis"><em>Eső</em></span>-t.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-16.png" alt="A részecskeszűrés frissítési ciklusa az esernyő DBH-nál N = 10 esetén, bemutatva minden egyes állapot mintapopulációját. (a) A t időpontban 8 minta jelez Eső-t és 2 ¬Eső-t. Mindegyiket továbbterjesztjük a következő állapotátmenet-modell szerinti mintavételezésével. A t + 1 időpontban 6 minta jelez Eső-t és 4 ¬Eső-t. (b) A t + 1 időpontban ¬Esernyő a megfigyelés értéke. Mindegyik mintát súlyozzuk a mintának a megfigyelésre vett feltételes valószínűségével, amit a körök nagysága jelez. (c) Egy új 10-es mintahalmaz generálódott az aktuális halmazból történő súlyozott sorsolással, 2 olyan mintát eredményezve, ami Eső-t jelez, és 8 olyat, ami ¬Eső-t."/></div></div></div><p>Most minden egyes mintát súlyozunk a <span class="emphasis"><em>t </em></span>+ 1 időpontbeli bizonyíték valószínűségével. Egy <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1 </sub>állapotban lévő minta <span class="emphasis"><em>P</em></span>(<span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>|<span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>)<span class="emphasis"><em> </em></span>súlyt kap. Az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> állapotban lévő minták teljes súlya az <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> megfigyelése után ezért</p><p><code class="code"><em><span class="remark">W</span></em>(<em><span class="remark">x</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em>+1</sub>) = <em><span class="remark">P</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">x</span></em><sub><em><span class="remark">t</span></em>+1</sub><em><span class="remark">)N</span></em>(<em><span class="remark">x</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>)</code></p><p>Most a mintavételi lépés jön. Mivel minden egyes minta a súlyával arányos valószínűséggel ismétlődik, az újramintavételezés után az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> állapotban lévő minták száma arányos az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> állapotban lévő minták teljes súlyával az újramintavételezés előtt:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0050.gif" alt="A részecskeszűrés frissítési ciklusa az esernyő DBH-nál N = 10 esetén, bemutatva minden egyes állapot mintapopulációját. (a) A t időpontban 8 minta jelez Eső-t és 2 ¬Eső-t. Mindegyiket továbbterjesztjük a következő állapotátmenet-modell szerinti mintavételezésével. A t + 1 időpontban 6 minta jelez Eső-t és 4 ¬Eső-t. (b) A t + 1 időpontban ¬Esernyő a megfigyelés értéke. Mindegyik mintát súlyozzuk a mintának a megfigyelésre vett feltételes valószínűségével, amit a körök nagysága jelez. (c) Egy új 10-es mintahalmaz generálódott az aktuális halmazból történő súlyozott sorsolással, 2 olyan mintát eredményezve, ami Eső-t jelez, és 8 olyat, ami ¬Eső-t."/></span></p><p>Azaz a mintapopuláció egy frissítési ciklus után helyesen reprezentálja a <span class="emphasis"><em>t</em></span> + 1 időpontbeli előrefelé üzenetet.</p><p>A részecskeszűrés így <span class="emphasis"><em>konzisztens,</em></span> de <span class="emphasis"><em>hatékony-e?</em></span> A gyakorlat azt mutatja, hogy a válasz igen: a részecskeszűrés, úgy tűnik, az igazi a posteriori eloszlás egy jó közelítését tartja fenn állandó számú mintát használva. Azonban jelenleg nincs elméleti garancia; a részecskeszűrés jelenleg aktívan kutatott terület. Számos javítást és változatot javasoltak, és az alkalmazások köre is egyre bővül. Mivel ez egy mintavételező algoritmus, a részecskeszűrés könnyen felhasználható hibrid és folytonos DBH-kban, lehetővé téve az alkalmazását akár olyan területeken is, mint komplex mintázatok követése videofelvételben (Isard és Blake, 1996) és tőzsdei előrejelzés (de Freitas és társai, 2000).</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id698679" href="#id698679" class="para">160</a>] </sup> Szigorúan véve egy Gauss-eloszlás problematikus, mivel pozitív valószínűséget rendel nagy negatív töltési szintekhez. A <span class="strong"><strong>béta-eloszlás</strong></span> gyakran jobb választás az olyan változókra, amelyeknek tartománya korlátos.</p></div></div></div></body></html>
