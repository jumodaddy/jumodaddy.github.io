<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id575030"/>Összefoglalás</h1></div></div></div><p>A játékok sokaságát néztük meg, hogy megértsük, mit is jelent optimálisan és a gyakorlatban is jól játszani. A legfontosabb gondolatokat az alábbiakban foglalhatjuk össze:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Egy játékot a <span class="strong"><strong>kiinduló állapot</strong></span>tal (<span class="strong"><strong>initial state</strong></span>) (a táblaállással), mindegyik állapotban a <span class="strong"><strong>legális cselekvés</strong></span>ekkel (<span class="strong"><strong>action</strong></span>s), egy <span class="strong"><strong>végteszt</strong></span>tel (<span class="strong"><strong>terminal test</strong></span>) (ami megmondja, hogy mikor ért véget a játék) és egy <span class="strong"><strong>hasznossági függvénny</strong></span>el (<span class="strong"><strong>utility function</strong></span>) (ami megmondja, hogy ki és mennyivel nyert) lehet megadni.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Tökéletes információ</strong></span>val (<span class="strong"><strong>perfect information</strong></span>) rendelkező kétszemélyes zérusösszegű játékoknál a <span class="strong"><strong>minimax algoritmus</strong></span> a teljes játékfa mélységi felsorolásával meg tudja határozni a játékos legjobb lépését.</p></li><li class="listitem"><p class="List Paragraph">Az <span class="strong"><strong>alfa-béta algoritmus</strong></span> ugyanazt a számítást végzi el, mint a minimax algoritmus, azonban jóval hatékonyabb, mivel lenyesi a keresési fa azon ágait, amiről be tudja bizonyítani, hogy a végső eredmény szempontjából irrelevánsak.</p></li><li class="listitem"><p class="List Paragraph">A teljes játékfa általában nem kezelhető (még az alfa-béta algoritmussal sem), ezért a keresést valahol abba kell hagynunk, és egy <span class="strong"><strong>kiértékelő függvény</strong></span>t (<span class="strong"><strong>evaluation function</strong></span>) kell alkalmaznunk, ami az adott állapot hasznosságának becslőjét adja.</p></li><li class="listitem"><p class="List Paragraph">A véletlen elemet is tartalmazó játékokat a minimax algoritmus olyan kiterjesztésével lehet kezelni, amely a <span class="strong"><strong>véletlen csomópont</strong></span>okat (<span class="strong"><strong>chance node</strong></span>) úgy értékeli ki, hogy az egyes hasznosságokat a gyermekcsomópontok valószínűségével súlyozva veszi az összes gyermekcsomópontjának az átlagos hasznosságát.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>nem tökéletes információjú játék</strong></span>ok (<span class="strong"><strong>imperfect information</strong></span>), mint például a bridzs, optimális lejátszása mindegyik játékostól az aktuális és a jövőbeli <span class="strong"><strong>hiedelmi állapot</strong></span>aira (<span class="strong"><strong>belief state</strong></span>s) vonatkozó következtetést igényli. Egy egyszerű közelítés kapható, ha átlagoljuk egy cselekvés értékét a hiányos információ minden lehetséges konfigurációjára.</p></li><li class="listitem"><p class="List Paragraph">A programok egyenlő ellenfelek, vagy akár meg is verik a legjobb emberi játékosokat dámajátékban, Othellóban és ostáblajátékban, és igen közel állnak ehhez a bridzsben. Egy program legyőzte egy kirakatmérkőzésen az emberi sakkvilágbajnokot. A góban a programok még amatőr szinten játszanak.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id575168"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>A mechanikus játékok korai történetére számos csalás rányomta a bélyegét. Ezek közül a legnevezetesebb Kempelen Farkas báró 1769-ben kiállított „Törökje”, egy feltételezett sakkautomata, amely Napóleont is megverte, mielőtt kiderült, hogy a szekrénye  valójában egy törpe növésű emberi sakkmestert rejtett (Levitt, 2000). A Török 1769-től 1854-ig játszott. Úgy tűnik, Charles Babbage (aki a Török hatása alatt állt) volt az első, aki 1846-ban számítógépes sakk és dámajáték megvalósíthatóságának első komoly elemzését adta (Morrison és Morrison, 1961). Tervezett egy 3 × 3-as amőbát játszó célgépet is, amit soha sem épített meg. Az első igazi játékgépet 1890 táján egy spanyol mérnök, Leonardo Torres y Quevedo tervezte és építette meg. A „KRK” a sakkvégjátékra specializált gép volt (király és bástya a király ellen) és képes volt bármilyen kiinduló állásból mattot adni. </p><p>A minimax algoritmust sokszor Ernst Zermelo, a modern halmazelmélet atyja 1912-es cikkéhez vezetik vissza. A cikk sajnálatos módon tartalmaz hibákat, és a minimaxot nem írja le helyesen. A játékelmélet komoly alapjait a nagy hatású <span class="emphasis"><em>Theory of Games and Economic Behavior </em></span>c. munkában Neumann és Morgenstern (Neumann és Morgenstern, 1944) fektették le, kimutatva azt is, hogy egyes játékokban <span class="emphasis"><em>szükség</em></span> van randomizált (avagy nem megjósolható) stratégiákra. (További információért lásd 17. fejezet.)</p><p>A korai számítógépes korszak számos prominens személyét kíváncsivá tette a számítógépes sakk lehetősége. Konrad Zuse – aki elsőként tervezett programozható számítógépet – igen részletes ötleteket dolgozott ki arra, hogy ezt hogyan lehetne megvalósítani (Zuse, 1945). Norbert Wiener nagy befolyású <span class="emphasis"><em>Cybernetics </em></span>c. könyve (Wiener, 1948) tartalmazta egy számítógépes sakkprogram működésének egy lehetséges vázlatát, a minimax keresést, a mélységi levágást és a kiértékelő függvényt is beleértve. Claude Shannon a modern számítógépes játékok elvi alapjait sokkal részletesebben fejtette ki, mint Wiener (Shannon, 1950). Shannon bevezette az egyensúlyi állás fogalmát, és néhány ötletet vázolt fel a szelektív (nem kimerítő) játékfakeresésre vonatkozólag. Slater és az ugyanabban a kötetben a cikkére reflektáló szerzők szintén megvizsgálták a számítógépes sakkozás lehetőségeit (Slater, 1950). I. J. Good Shannontól függetlenül kidolgozta az egyensúlyi állás fogalmát (Good, 1950).</p><p>1951-ben Alan Turing írta meg az első valódi számítógépes programot, ami képes volt egy teljes sakkjátszmát lejátszani (Turing és társai, 1953). Valójában azonban Turing programja sohasem futott számítógépen, kézi szimulációval tesztelték egy nagyon gyenge emberi sakkjátékos ellen, aki legyőzte a programot. Időközben D. G. Prinz megírt és valóban futtatott is egy programot (Prinz, 1952), ami sakkfeladványokat oldott meg, bár nem játszott teljes játszmát. Alex Bernstein írta az első olyan sakkprogramot, amely egy teljes standard sakkjátszmát játszott (Bernstein és Roberts, 1958; Bernstein és társai, 1958).<sup>[<a id="id575192" href="#ftn.id575192" class="footnote">58</a>]</sup></p><p>Az alfa-béta keresés alapötletét John McCarthy dolgozta ki 1956-ban, habár nem publikálta. Az NSS-sakkprogram az alfa-béta algoritmus egy leegyszerűsített változatát használta, ez volt az első sakkprogram, ami ezt alkalmazta (Newell és társai, 1958). Nilsson szerint Arthur Samuel dámaprogramja (Samuel, 1959; 1967) szintén alfa-béta algoritmust használt, habár maga Samuel ezt nem említi a rendszerről publikált beszámolóiban (Nilsson, 1971). Az 1960-as évek elején jelentek meg az alfa-béta algoritmust ismertető cikkek (Hart és Edwards, 1961; Brudno, 1963; Slagle, 1963b). Az alfa-béta algoritmus egy teljes implementációját Slagle írta le egy cikkben (Slagle és Dixon, 1969), ami a kalah<sup>[<a id="id575199" href="#ftn.id575199" class="footnote">59</a>]</sup> játékot játszó játékprogram működését ismertette. A John McCarthy egyik diákja által írt „Kotok–McCarthy” sakkprogram (Kotok, 1962) is az alfa-béta algoritmust használta. Knuth ismerteti az alfa-béta algoritmus történetét (Knuth és Moore, 1975), megadja az algoritmus teljességének a bizonyítását és elvégzi az időigény elemzését. Knuth és Moore elemzése az alfa-béta keresésnek a követők véletlen sorba rendezésével O((<span class="emphasis"><em>b</em></span>/log<span class="emphasis"><em>b</em></span>)<sup>d</sup>) aszimptotikus komplexitást mutatott ki, ami lehangoló eredmény, mert a <span class="emphasis"><em>b</em></span>/log<span class="emphasis"><em>b</em></span> effektív elágazási tényező magánál a <span class="emphasis"><em>b</em></span>-nél nem sokkal jobb. Később jöttek rá, hogy az aszimptotikus képlet csak a <span class="emphasis"><em>b</em></span> &gt; 1000 igaz, és az aktuális játékokra található elágazási tényezőkre a gyakran idézett O(<span class="emphasis"><em>b</em></span><sup>3<span class="emphasis"><em>d</em></span>/4</sup>) érvényes. Pearl megmutatta (Pearl, 1982b), hogy az alfa-béta algoritmus aszimptotikusan optimális az összes rögzített mélységű játékfa-keresési algoritmus között.</p><p>Az első két sakkprogram, ami egymás ellen játszott, a Kotok–McCarthy-program és a Moszkvai Elméleti és Kísérleti Fizika Intézet által megírt „ITEP” program (Adelson-Velsky és társai, 1970) volt az 1960-as évek közepén. Ezt az interkontinentális mérkőzést távírón játszották le. A küzdelem 1967-ben az ITEP-program 3:1 arányú győzelmével ért véget. A MacHack 6 volt az első olyan sakkprogram, ami sikeresen játszott emberek ellen (Greenblatt és társai, 1967). 1400-as Élő-pontszáma jóval több volt, mint a kezdők 1000-es Élő-pontja, azonban így is igen messze volt a 2800 vagy több Élő-ponttól, ami szükséges lett volna, hogy Herb Simon 1957-es jóslata teljesüljön, miszerint 10 éven belül a számítógépes sakkprogramok lesznek a sakkvilágbajnokok (Simon és Newell, 1958).</p><p>Az 1970-es első ACM Észak-Amerikai Számítógépes Sakkbajnoksággal a sakkprogramok versengése komollyá vált. A korai 1970-es évek programjai igen bonyolultak voltak, számos trükköt vetettek be, hogy a keresés bizonyos ágait levágják, elfogadható lépéseket generáljanak stb. Az első Számítógépes Sakkvilágbajnokságot 1974-ben Stockholmban rendezték. Ezt az első világbajnokságot a Kaissa (Adelson-Velsky és társai, 1975), egy másik ITEP-program nyerte meg. Kaissa egy egyszerűbb megközelítésen alapult és kimerítő alfa-béta keresést használt egyensúlyi kereséssel vegyítve. A megközelítés felsőbbrendűségét igazolta a <code class="code">CHESS</code> 4.6 győzelme az 1977-es Számítógépes Sakkvilágbajnokságon. A <code class="code">CHESS</code> 4.6 lépésenként 400 000 állást elemzett és 1900 Élő-pontot ért el.</p><p>Greenblatt MacHack 6-osának egy későbbi változata volt az első olyan sakkprogram, amely már kifejezetten a sakkra tervezett célhardveren futott (Moussouris és társai, 1979), de a Belle (Condon és Thompson, 1982) volt az első olyan program, ami a célhardvernek köszönhetően jelentős sikereket ért el. A Belle lépésgeneráló és állásértékelő hardvere lehetővé tette, hogy lépésenként néhány millió állást is elemezzen. A Belle 2250 Élő-pontot ért el, és az első mesteri fokozat szintű program lett. A <code class="code">HITECH</code> rendszer egy speciális rendeltetésű számítógép volt, amit Hans Berliner, a korábbi levelező sakkvilágbajnok és egy CMU-beli diákja, Carl Ebeling tervezett, hogy a kiértékelő függvények gyors számítását tegyék lehetővé (Ebeling, 1987; Berliner és Ebeling, 1989). A <code class="code">HITECH</code> észak-amerikai sakkbajnok lett 1985-ben, és 1987-ben az első olyan program volt, amely egy emberi nagymestert is legyőzött. A CMU-n szintén kifejlesztett Deep Thought (Hsu és társai, 1990) a tiszta keresés sebességét tovább fokozta. 2551 Élő-pontot ért el és a Deep Blue előfutára lett. Az 1980-ban alapított Fredkin-díj 5000 dollárt ajánlott fel annak a sakkprogramnak, amelyik elsőként éri el a mesterfokozatot, és 10 000 dollárt ajánlott fel annak a sakkprogramnak, amely elsőként éri el a USCF (Amerikai Egyesült Államok Sakkszövetsége) 2500-as Élő-pontot (ez a nagymesteri szinthez közeli érték), és 100 000 dollárt ajánlott fel azon sakkprogramnak, amelyik elsőként legyőz egy emberi sakkvilágbajnokot. Az 5000 dolláros díjat 1993-ban a Belle, a 10 000 dolláros díjat 1989-ban a Deep Thought, majd a 100 000 dolláros díjat 1997-ben a Deep Blue nyerte el a Kaszparov felett aratott győzelemért. Fontos emlékezni, hogy a Deep Blue sikerét mind az algoritmikus javítások, mind a hardver biztosította (Hsu, 1999; Campbell és társai, 2002). Az olyan technikák, mint a nulla lépés heurisztika (Beal, 1990) a keresésben igen szelektív programokhoz vezettek. Az utolsó három Számítógépes Sakkvilágbajnokságot 1992-ben, 1995-ben és 1999-ben a standard PC-n futó programok nyerték meg. Egy korszerű sakkprogramnak talán a legrészletesebb leírását Ernst Heinz adja meg (Heinz, 2000), amelynek <code class="code">DARKTHOUGHT</code> programja volt a legmagasabb pontszámú nem kereskedelmi program az 1999-es világbajnokságon.</p><p>Kísérletek történtek arra, hogy a „standard megközelítés” 6.7. alfejezetben leírt problémáit leküzdjék. Az első szelektív kereső algoritmus, elméleti igénnyel, valószínűleg a B<sup>*</sup> algoritmus (Berliner, 1979) volt, ami megkísérli, hogy a játékfa csomópontjainak az értékeire egyetlen becsült érték helyett intervallumkorlátokat adjon. A levélcsomópontok kifejtése annak érdekében történik, hogy a legfelső szintű korlátokat finomítsuk, amíg egy „nyilván legjobb” lépést nem találunk. Palay az alfa-béta algoritmus becsült értékei, illetve a B<sup>*</sup> algoritmus intervallumai helyett valószínűség-eloszlásokat használ (Palay, 1985). David McAllester konspirációs szám keresési algoritmusa azokat a levélcsomópontokat fejti ki, amelyek, ha megváltoznának az értékeik, előidéznék, hogy az algoritmus a gyökérnél új lépést válasszon (David McAllester, 1988). Az MGSS<sup>*</sup> (Russell és Wefald, 1989) a 16. fejezet fejlett döntéselméleti technikáit használja minden levélcsomópont kifejtésének értékbecslésére a gyökérszintű döntés minőségében tapasztalt várható javulás függvényében. Ez a program az Othellóban képes volt jobb eredményeket elérni, mint az alfa-béta algoritmus, annak ellenére, hogy egy nagyságrenddel kevesebb csomópontot vizsgált meg. Az MGSS<sup>* </sup>megközelítés elvben alkalmas a következtetés bármilyen formájának vezérlésére.</p><p>Az alfa-béta keresés több szempontból a mélységi áglenyeső megfelelője két játékos esetén, amit az egyedi ágens esetében az A<sup>*</sup> dominál. Az SSS<sup>*</sup> algoritmus (Stockman, 1979) egy kétszemélyes A<sup>*</sup>-nak tekinthető, és azonos döntés eléréséhez soha nem fejt ki több csomópontot, mint az alfa-béta algoritmus. Eredeti formájában az SSS<sup>*</sup> memóriaigénye és a sorba állítás számítási overheadje miatt nem praktikus, azonban az RLEK algoritmusból kifejlesztettek egy lineáris tárkomplexitású változatot (Korf és Chickering, 1996). Plat az SSS<sup>*</sup>-ja egy új megközelítést dolgozott ki (Plat és társai, 1996) az alfa-béta keresés és a transzpozíciós táblák együtteseként, és megmutatta, hogy az eredeti algoritmus problémáit hogyan kell elkerülni, végül MTD(<span class="emphasis"><em>f</em></span>) néven egy új változatot fejlesztett ki, amit sok kiemelkedő teljesítményű programba építettek be.</p><p>D. F. Beal és Dana Nau a minimax közelítő kiértékelésekre történő alkalmazásoknál jelentkező gyengeségeit tanulmányozták (Beal, 1980; Dana Nau, 1980; 1983). Kimutatták, hogy a levélértékeknek a fában való eloszlására bizonyos függetlenségi feltételezésekkel élve, a minimax algoritmus <span class="emphasis"><em>kevésbé</em></span> megbízható becsléseket ad a gyökérre, mintha a kiértékelő függvényeket közvetlenül, mindenféle keresés nélkül alkalmaznánk. Pearl <span class="emphasis"><em>Heuristics </em></span>c. könyve (Pearl, 1984) ezt a látszólagos paradoxont részben megmagyarázza és számos játékalgoritmust elemez. Baum és Smith (Baum és Smith, 1997) a minimax egy valószínűség-alapú helyettesítését javasolja, és azt mutatja ki, hogy ez bizonyos játékokban jobb döntésekhez vezet. A keresés különféle szinteken való levágásából és a kiértékelő függvény alkalmazásából adódó hatások elmélete még mindig szegényes. </p><p>A várhatóminimax algoritmust Donald Michie vetette fel (Michie, 1966), habár az közvetlenül következik Neumann és Morgenstern játékfa-kiértékelési elméletéből. Bruce Ballard az alfa-béta nyesést kiterjesztette a véletlen csomópontokat is tartalmazó fákra (Bruce Ballard, 1983). Az első sikeres ostáblaprogram a BKG volt (Berliner, 1977; 1980b). Csak 1 mélységig keresett és bonyolult, manuálisan összeállított kiértékelő függvényt használt. Ez volt az első számítógépes program, ami képes volt legyőzni egy emberi világbajnokot az ismert klasszikus táblajátékok egyikében (Berliner, 1980a), habár Berliner elsőként ismerte el, hogy ez csak egy rövid, bemutató mérkőzés volt (nem egy világbajnoki mérkőzés), és hogy a BKG nagyon szerencsés „kézzel” dobott a kockával. Gerry Tesauro kutatásai, először a <code class="code">NEUROGAMMON</code> (Tesauro, 1989), majd a TD-<code class="code">GAMMON</code> (Tesauro, 1995) programokkal, azt mutatták, hogy sokkal jobb eredmény érhető el a megerősítéses tanulással (amely területtel a 21. fejezetben foglalkozunk).</p><p>A dáma, és nem a sakk volt az első olyan klasszikus játék, amire egy valóban számítógépen futó program képes volt végigjátszani egy teljes játszmát. Christopher Strachey írta az első működőképes dámajátékprogramot (Strachey, 1952). Schaeffer (Schaeffer, 1997) nagyon olvasmányosan leírja a Chinook – a világbajnok dámajátékprogram – fejlesztéstörténetét az összes műhelytitkával együtt.</p><p>Az első góprogramokat valamivel a dáma- és a sakkprogramok után fejlesztették ki (Lefkovitz, 1960, Remus, 1962), és lassabban fejlődtek a dáma- és a sakkprogramoknál. Ryder tiszta keresésalapú megközelítést használt (Ryder, 1971) a szelektív nyesési módszerek egész palettájával, hogy le tudja győzni a hatalmas elágazási tényezőből adódó problémát. Zobrist feltétel-cselekvés szabályokat használt elfogadható lépések generálására, ha a játékban ismert alakzatok jelentek meg (Zobrist, 1970). Reitman és Wilcox jó eredménnyel kombinálta a szabályokat és a keresést (Reitman és Wilcox, 1979), a legtöbb modern program követte ezt a hibrid megközelítést. A számítógépes gó jelenlegi állását Müller (Müller, 2002) foglalja össze, és tömérdek hivatkozást is közöl. Anshelevich (Anshelevich, 2000) hasonló módszereket a <code class="code">HEX</code> játékra alkalmaz. A friss fejleményekről a Számítógépes Go Szövetség által kiadott <span class="emphasis"><em>Computer Go Newsletter</em></span> számol be.</p><p>A számítógépes játékokról több fórumon jelennek meg cikkek. A felettébb félrevezető nevű konferenciakiadvány, a <span class="emphasis"><em>Heuristic Programming in Artificial Intelligence </em></span>számol be a Számítógépes Sakkolimpiákról, amely rendezvények a játékok egész sorára terjednek ki. A játékprogramok kutatásáról fontos cikkeket publikáltak számos szerkesztett cikkgyűjteményben (Levy, 1988a; Levy, 1988a; Marsland és Schaeffer, 1990). Az 1977-ben alapított Nemzetközi Számítógépes Sakkszövetség (International Computer Chess Association, ICCA) negyedévenként adja ki az <span class="emphasis"><em>ICGA</em></span> <span class="emphasis"><em>Journal</em></span>t (korábban <span class="emphasis"><em>ICCA Journal</em></span>). (Clarke, 1977) óta fontos cikkek jelentek meg az <span class="emphasis"><em>Advances in Computer Chess </em></span>antológiasorozatban. Az <span class="emphasis"><em>Artificial Intelligence</em></span> folyóirat 134. kötete (<span class="emphasis"><em>Artificial Intelligence</em></span>, 2002) leírásokat tartalmaz a legfejlettebb sakk, Othello, Hex, shogi, gó, ostábla, póker, Scrabble™ és más játékprogramokról. </p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id575376"/>Feladatok</h2></div></div></div><a id="ID_241_oldal"/><p><span class="strong"><strong>6.1.</strong></span></p><p>Ez a feladat a játékok alapvető elveit a 3 × 3-as amőbán (körök és ikszek) keresztül gyakoroltatja be. <span class="emphasis"><em>X<sub>n</sub></em></span> azon sorok, oszlopok vagy átlók számát jelöli, ahol pontosan <span class="emphasis"><em>n</em></span> db <span class="emphasis"><em>X</em></span>, míg egyetlen <span class="emphasis"><em>O</em></span> sem található. Hasonlóan, <span class="emphasis"><em>O<sub>n </sub></em></span>azon sorok, oszlopok vagy átlók számát jelöli, ahol pontosan <span class="emphasis"><em>n</em></span> db <span class="emphasis"><em>O</em></span>, míg egyetlen <span class="emphasis"><em>X</em></span> sem található. A hasznosságfüggvény +1-et rendel minden olyan álláshoz, ahol <span class="emphasis"><em>X</em></span><sub>3 </sub>= 1, és –1-et rendel minden olyan álláshoz, ahol <span class="emphasis"><em>O</em></span><sub>3 </sub>= 1. Az összes többi végállás hasznossága 0. A nem végállapotok esetén az alábbi módon definiált lineáris kiértékelő függvényt fogjuk használni:</p><p><code class="code"><em><span class="remark">	Kiértékel</span></em>(<em><span class="remark">s</span></em>) = 3<em><span class="remark">X</span></em><sub>2</sub>(<em><span class="remark">s</span></em>)<sub> </sub>+ <em><span class="remark">X</span></em><sub>1</sub>(<em><span class="remark">s</span></em>)<sub> </sub>– (3<em><span class="remark">O</span></em><sub>2</sub>(<em><span class="remark">s</span></em>)<sub> </sub>+ <em><span class="remark">O</span></em><sub>1</sub>(<em><span class="remark">s</span></em>))</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Körülbelül hány különböző 3 × 3-as amőbajátszmát lehet lejátszani?</p></li><li class="listitem"><p>Üres táblából kiindulva, a szimmetriát is figyelembe véve, 2-es mélységig (vagyis egy <span class="emphasis"><em>X</em></span> és egy <span class="emphasis"><em>O</em></span> a táblán) mutassa meg a teljes játékfát. </p></li><li class="listitem"><p>A fában 2-es mélységben tüntesse fel az összes álláskiértékelést.</p></li><li class="listitem"><p>A fában az 1-es és a 0-s mélységben levő állásokhoz a minimax algoritmust felhasználva tüntesse fel a felfelé terjesztett értékeket, és használja fel azokat a legjobb kezdő lépés meghatározásához.</p></li><li class="listitem"><p>Karikázza be a 2-es szinten levő azon csomópontokat, amelyeket az alfa-béta nyesés alkalmazása esetén az algoritmus <span class="emphasis"><em>nem</em></span> értékelne ki, feltételezve, hogy a csomópontokat az algoritmus <span class="emphasis"><em>az alfa-béta nyeséshez optimális sorrendben generálja.</em></span></p></li></ol></div><p><span class="strong"><strong>6.2.</strong></span></p><p>Bizonyítsa be az alábbi állítást: minden játékfa esetén a <code class="code">MAX</code> által kapott hasznosság, amikor <code class="code">MAX</code> a minimax döntést használva játszik egy szuboptimális <code class="code">MIN</code>-nel szemben, sohasem lesz alacsonyabb, mint az a hasznosság, ami akkor ér el, ha egy optimális <code class="code">MIN</code>-nel szemben játszana. Ki tud találni egy olyan játékfát, ahol <code class="code">MAX</code> egy szuboptimális stratégiával egy <span class="emphasis"><em>szuboptimális</em></span> <code class="code">MIN</code>-nel szemben még jobban teljesítene?</p><p><span class="strong"><strong>6.3.</strong></span></p><p>Tekintse a 6.14. ábrán látott kétszemélyes játékot.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Rajzolja fel a teljes játékfát az alábbi konvenciót alkalmazva:</p></li></ol></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>minden állapotot (<span class="emphasis"><em>S<sub>A</sub></em></span>, <span class="emphasis"><em>S<sub>B</sub></em></span>) formában írja fel, ahol <span class="emphasis"><em>S<sub>A</sub></em></span> és <span class="emphasis"><em>S<sub>B</sub></em></span> a zsetonok helyzete.</p></li><li class="listitem"><p>minden végállapotot egy négyzetbe, a játékértékét pedig egy körbe írja be.</p></li><li class="listitem"><p>a <span class="emphasis"><em>hurokállapotokat</em></span> (azon állapotok, amelyek már megjelentek a gyökérig vezető út mentén) dupla négyzetekbe írja be. Mivel nem világos, hogy az ilyen állapotok értéke mennyi, jelölje be mindegyiket egy körbe írt „?”-lel.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Most mindegyik csomóponthoz írja be a visszaterjesztett minimax értékét (szintén egy körbe írva). Magyarázza meg, hogy a „?” értékeket hogyan kezelte, és miért?</p></li><li class="listitem"><p>Magyarázza meg, hogy a standard minimax ebben a játékfában miért fulladna kudarcba, és röviden vázolja fel, hogy a (b) kérdésre adott válaszra támaszkodva hogyan lenne képes az algoritmust megjavítani. Képes-e a módosított algoritmus megadni az optimális döntéseket az összes hurkokat tartalmazó játékban?</p></li><li class="listitem"><p>Ez a 4-négyzetes játék <span class="emphasis"><em>n</em></span> négyzet esetére általánosítható, minden <span class="emphasis"><em>n</em></span> &gt; 2-re. Bizonyítsa be, hogy <span class="emphasis"><em>A</em></span> győz, ha <span class="emphasis"><em>n</em></span> páros, és veszít, ha <span class="emphasis"><em>n</em></span> páratlan.</p></li></ol></div></li></ul></div><div class="figure"><a id="id575653"/><p class="title"><strong>6.14. ábra - Egy egyszerű játék kiinduló állása. Az <span class="emphasis"><em>A</em></span> játékos indul elsőnek. Mindkét játékos felváltva lép és a zsetonját a szomszédos szabad helyre helyezheti, mindkét irányban. Ha a szomszédos mező foglalt, akkor a játékos az ellenfél felett átugorhat a következő szabad helyre, ha van ilyen. (Például ha <span class="emphasis"><em>A</em></span> a 3-n és <span class="emphasis"><em>B</em></span> a 2-n van, akkor <span class="emphasis"><em>A</em></span> visszaléphet 1-re.) A játéknak vége, ha az egyik játékos eléri a tábla ellentétes végét. Ha az <span class="emphasis"><em>A</em></span> játékos elsőnek éri el a 4-et, a játék értéke +1, ha <span class="emphasis"><em>B</em></span> játékos éri el elsőnek az 1-et, a játék értéke az <span class="emphasis"><em>A</em></span> számára –1.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/06-14.png" alt="Egy egyszerű játék kiinduló állása. Az A játékos indul elsőnek. Mindkét játékos felváltva lép és a zsetonját a szomszédos szabad helyre helyezheti, mindkét irányban. Ha a szomszédos mező foglalt, akkor a játékos az ellenfél felett átugorhat a következő szabad helyre, ha van ilyen. (Például ha A a 3-n és B a 2-n van, akkor A visszaléphet 1-re.) A játéknak vége, ha az egyik játékos eléri a tábla ellentétes végét. Ha az A játékos elsőnek éri el a 4-et, a játék értéke +1, ha B játékos éri el elsőnek az 1-et, a játék értéke az A számára –1."/></div></div></div><p><span class="strong"><strong>6.4.</strong></span></p><div class="informalexample"><p>Implementáljon lépésgenerátort és kiértékelő függvényt az alábbi játékok közül néhányat: kalah, Othello, dáma, sakk. Az implementációt használva tervezzen egy általános alfa-béta játékágenst. Hasonlítsa össze a keresési mélység növelésének, a lépéssorrendezés tökéletesítésének és a kiértékelő függvény tökéletesítésének a hatását. Milyen közel esik az Ön effektív elágazási tényezője a tökéletes lépéssorrendezés ideális esetéhez? </p></div><p><span class="strong"><strong>6.5.</strong></span></p><p>Állítsa elő az alfa-béta nyesés helyességének formális bizonyítását. Ehhez tekintse a 6.15. ábrán bemutatott<span class="emphasis"><em> </em></span>helyzetet. A kérdés az, hogy az algoritmus lenyesse-e az <span class="emphasis"><em>n<sub>j </sub></em></span>csomópontot, ami egy max-csomópont és az <span class="emphasis"><em>n</em></span><sub>1</sub> leszármazottja. Az alapötlet, hogy akkor és csak akkor nyessük le, ha <span class="emphasis"><em>n</em></span><sub>1</sub> minimax értéke igazolhatóan független <span class="emphasis"><em>n<sub>j</sub></em></span> értékétől.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="emphasis"><em>n</em></span><sub>1 </sub>értékét az alábbi képlet adja meg:</p></li></ol></div><p><code class="code">		<em><span class="remark">n</span></em><sub>1</sub> = min(<em><span class="remark">n</span></em><sub>2</sub>, <em><span class="remark">n</span></em><sub>21</sub>, …, <em><span class="remark">n</span></em><sub>2<em><span class="remark">b</span></em>2</sub>)</code></p><p>Adjon egy hasonló kifejezést <span class="emphasis"><em>n</em></span><sub>2</sub>-re, és <span class="emphasis"><em>n</em></span><sub>1</sub>-re, <span class="emphasis"><em>n<sub>j</sub></em></span>-t felhasználva.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Legyen <span class="emphasis"><em>l<sub>i</sub></em></span> az <span class="emphasis"><em>n<sub>i</sub> </em></span>csomóponttól balra levő, ismert minimax értékű, <span class="emphasis"><em>i</em></span> mélységben található csomópontok minimális (maximális) csomópontértéke. Hasonlóan, legyen <span class="emphasis"><em>r<sub>i</sub></em></span> az <span class="emphasis"><em>n<sub>i</sub> </em></span>csomóponttól jobbra levő, még ki nem fejtett, <span class="emphasis"><em>i</em></span> mélységben található csomópontok minimális (maximális) csomópontértéke. Az <span class="emphasis"><em>n</em></span><sub>1</sub>-re előbb meghatározott kifejezést írja át <span class="emphasis"><em>l<sub>i</sub> </em></span>és <span class="emphasis"><em>r<sub>i</sub> </em></span>értékekkel kifejezve.</p></li><li class="listitem"><p>Most fogalmazza át a kifejezést, hogy megmutassa, ahhoz, hogy <span class="emphasis"><em>n<sub>j</sub></em></span> befolyásolja <span class="emphasis"><em>n</em></span><sub>1</sub>-et, <span class="emphasis"><em>n<sub>j</sub>-</em></span>nek meg kell haladnia bizonyos, az <span class="emphasis"><em>l<sub>i</sub></em></span> értékekből meghatározott korlátot.</p></li></ol></div><div class="figure"><a id="id575887"/><p class="title"><strong>6.15. ábra - Az a helyzet, amikor az algoritmus eldönti, hogy lenyesheti-e az <span class="emphasis"><em>n<sub>j</sub></em></span> csomópontot</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/06-15.png" alt="Az a helyzet, amikor az algoritmus eldönti, hogy lenyesheti-e az nj csomópontot"/></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Az eljárást ismételje meg arra az esetre, amikor az <span class="emphasis"><em>n<sub>j</sub></em></span> egy min-csomópont.</p></li></ol></div><p><span class="strong"><strong>6.6.</strong></span></p><div class="informalexample"><p>Implementálja a véletlen csomópontokat tartalmazó játékfák lenyesésére alkalmas várhatóminimax és <sup>*</sup>-alfa-béta algoritmust, amit Ballard (Ballard, 1983) ír le. Próbálja ki azokat az algoritmusokat olyan játékokon, mint az ostábla, és mérje meg a <sup>*</sup>-alfa-béta nyesési hatékonyságát. </p></div><p><span class="strong"><strong>6.7.</strong></span></p><p>Bizonyítsa be, hogy a levélcsomóponti értékek pozitív lineáris transzformációja (azaz egy transzformáció <span class="emphasis"><em>x</em></span>-től <span class="emphasis"><em>ax </em></span>+ <span class="emphasis"><em>b</em></span>-ig, ahol <span class="emphasis"><em>a</em></span> &gt; 0), nincs befolyással a lépések választékára a játékfában, akkor sem, ha léteznek benne véletlen csomópontok.</p><p><span class="strong"><strong>6.8.</strong></span></p><p>Tekintse az alábbi eljárást a lépések megválasztására a véletlen csomópontot is tartalmazó játékokban:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Generáljon egy megfelelő számú (mondjuk 50) kockadobásból álló sorozatot egy megfelelő (mondjuk 8) mélységig.</p></li><li class="listitem"><p>Ismert kockadobások esetén a játékfa determinisztikussá válik. Minden egyes kockadobás-sorozatra oldja meg az eredményül kapott determinisztikus játékfát az alfa-béta algoritmussal.</p></li><li class="listitem"><p>Az eredményeket használja fel az egyes lépések értékének megbecslésére, és válassza ki a legjobb lépést.</p></li></ul></div><p>Helyesen fog működni ez az eljárás? Miért (nem)?</p><p><span class="strong"><strong>6.9.</strong></span></p><p>Írjon és implementáljon egy <span class="emphasis"><em>valós idejű,</em></span> <span class="emphasis"><em>többszemélyes</em></span> játszókörnyezetet, ahol az idő a környezeti állapot része, és a játékosok rögzített időszeleteket kapnak.</p><p><span class="strong"><strong>6.10.</strong></span></p><p>Adja meg és/vagy implementálja az alábbi játékok egyikére vagy akár többre is az állapotleírást, lépésgenerálást és a kiértékelő függvényt: Monopoly, Játék a betűkkel, bridzs (egy konkrét licitet feltételezve) és póker (válassza meg a kedvenc változatát).</p><p><span class="strong"><strong>6.11.</strong></span></p><p>Gondosan tekintse át a 6.10. feladat minden egyes játékában a véletlen események és a részleges információk összefüggéseit.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Melyikre lesz jó a standard várhatóminimax modell? Implementálja az algoritmust és futtassa le a játékágensében a játékkörnyezet szükséges módosításaival. </p></li><li class="listitem"><p>Melyekre lenne jó a 6.8. feladatban leírt séma?</p></li><li class="listitem"><p>Vitassa meg, hogyan kellene kezelni azt a tényt, hogy egyes játékokban a játékosok nem rendelkeznek ugyanazzal az információval az aktuális állapotról. </p></li></ol></div><p><span class="strong"><strong>6.12.</strong></span></p><p>A minimax algoritmus feltételezi, hogy a játékosak felváltva lépnek, az olyan kártyajátékokban azonban, mint a whist vagy a bridzs, mindig a leütés győztese indul a következőnek.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Módosítsa algoritmusát, hogy e játékokra is megfelelően működjön. Feltételezheti, hogy rendelkezésére áll a <code class="code">GYŐZTES</code> (<span class="emphasis"><em>leütés</em></span>) függvény, amely azt adja vissza, hogy az adott leütést mely kártya nyerte meg. </p></li><li class="listitem"><p>Rajzolja fel a <a class="xref" href="ch06s05.md#ID_228_oldal">„A várhatóminimax komplexitása”</a> részben látható első leosztásra a játékfát.</p></li></ol></div><p><span class="strong"><strong>6.13.</strong></span></p><p>A Chinook dámaprogram kiterjedten használja a végjáték adatbázisokat, amelyek pontos értéket adnak a játék utolsó hat lépésében előálló összes álláshoz. Hogyan lehet egy ilyen adatbázist hatékonyan legenerálni?</p><p><span class="strong"><strong>6.14.</strong></span></p><p>Vitassa meg, hogyan alkalmazható a játékok standard megközelítése az olyan játékokra, mint például a tenisz, a póló és a krikett, amelyeket folytonos, fizikai állapottérben játszanak.</p><p><span class="strong"><strong>6.15.</strong></span></p><p>Írja le, hogy a minimax és az alfa-béta hogyan változik kétszemélyes, nem zérusösszegű játékok esetén, ahol minden játékosnak külön kiértékelő függvénye van. Feltételezheti, hogy mindegyik játékos mások kiértékelő függvényeit ismeri. Ha a két véghasznosság értékére nincs korlát, lehetséges-e valamelyik csomópont számára, hogy az alfa-béta lenyesi?</p><p><span class="strong"><strong>6.16.</strong></span></p><p>Tegyük fel, hogy egy olyan sakkprogrammal rendelkezik, amely képes egymillió csomópontot kiértékelni másodpercenként. Válassza a játékállás egy tömör reprezentációját a transzpozíciós tábla számára. Kb. mennyi állást képes eltárolni memóriában, az 500 Mbájt nagyságú táblában? Elég lesz-e ez a lépésenként allokált 3 perces kereséshez? Hány táblakiolvasást képes megvalósítani egy álláskiértékelés ideje alatt? Most tételezze fel, hogy a transzpozíciós tábla nagyobb, és nem fér el a memóriában. Hány kiértékelést lehetne megvalósítani egy diszkhozzáférés ideje alatt, standard diszkhardver mellett?</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id575192" href="#id575192" class="para">58</a>] </sup> Newell (Newell és társai, 1958) egy orosz BESM programot említ, amely lehet, hogy Bernstein programját megelőzte.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id575199" href="#id575199" class="para">59</a>] </sup> A kalah egy afrikai eredetű kétszemélyes játék, amelyben kavicsokat (gyémántokat) kell átrakosgatni csészék között. Több számítógépes változata is létezik, l. például: <span class="emphasis"><em>http:</em></span>//<span class="emphasis"><em>ceman.ecn.purdue.edu/~ee373/kalah.md.</em></span> (<span class="emphasis"><em>A ford.</em></span>)</p></div></div></div></body></html>
