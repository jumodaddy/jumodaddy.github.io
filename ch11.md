<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="11. fejezet - Tervkészítés"><div class="titlepage"><div><div><h1 class="title"><a id="id637367"/>11. fejezet - Tervkészítés</h1></div></div></div><p><span class="emphasis"><em>Ebben a fejezetben láthatjuk, hogy hogyan használhatja ki egy ágens a probléma szerkezetét egy összetett cselekvési terv kialakításához.</em></span></p><p>Egy cél elérésére irányuló cselekvéssorozat kialakítását <span class="strong"><strong>tervkészítés</strong></span>nek (<span class="strong"><strong>planning</strong></span>) nevezzük. Tervkészítő ágensekre eddig két példát láttunk: a 3. fejezet keresésalapú problémamegoldó ágensét és a<span class="emphasis"><em> </em></span>10. fejezetben bemutatott logikai tervkészítő ágenst. Ez a fejezet elsősorban az olyan nagyobb bonyolultságú tervezési feladatokra való felskálázással foglalkozik, melyek meghaladják az eddig ismertetett megközelítések képességeit.</p><p>A 11.1. fejezet egy kifejező, de mégis megfelelően korlátozott nyelvet mutat be az állapotokat és cselekvéseket tartalmazó tervkészítési feladatok leírására. Ez a nyelv szoros kapcsolatban áll a 7. és 10. fejezetben szereplő ítéletlogikai, illetve elsőrendű leírásokkal. A 11.2. fejezet megmutatja, hogy az előre- és a hátrafelé kereső algoritmusok hogyan tudják előnyösen kihasználni ezt a reprezentációt, elsősorban a leírás szerkezetéből automatikusan levezethető heurisztikák segítségével. (Ez analóg az 5. fejezetben bemutatott, a kényszerkielégítési problémához kialakított heurisztika elkészítésével.) A 11.3–11.5. alfejezetben olyan tervkészítő algoritmusok kerülnek bemutatásra, amelyek felhasználva a probléma reprezentációját, képességeikben túlmutatnak az előre-, illetve hátrafelé keresésen. Nevezetesen olyan eljárásokat vizsgálunk meg, amelyek nem csak teljesen rendezett cselekvések sorozatát képesek figyelembe venni.</p><p>Ebben a fejezetben csak olyan környezetekre szorítkozunk, melyek teljesen megfigyelhetők, determinisztikusak, végesek, statikusak (azaz ahol változások csak akkor történnek, amikor az ágens cselekszik), diszkrétek (időben, cselekvésekben, objektumokban és hatásokban). Ezeket <span class="strong"><strong>klasszikus tervkészítés</strong></span>i (<span class="strong"><strong>classical planning</strong></span>) környezeteknek nevezzük. Ezzel ellentétben a nem klasszikus tervkészítés a részben megfigyelhető vagy a sztochasztikus környezetek kezelésére szolgál, és itt megjelennek eltérő, a 12. és 17. fejezetben bemutatott, algoritmusok és ágenstervek.</p><div class="section" title="A tervkészítési probléma"><div class="titlepage"><div><div><h1 class="title"><a id="id637405"/>A tervkészítési probléma</h1></div></div></div><p class="2">Fontoljuk meg, hogy mi történne, ha egy közönséges, a standard keresési algoritmusokat – mélységi keresés, A* stb.– használó problémamegoldó ágens valós nagyméretű problémákkal kerülne szembe. Ez segíthet abban, hogy jobb tervkészítő ágenseket tervezzünk.</p><p class="Tartalom3">A legkézenfekvőbb nehézség, hogy a problémamegoldó ágenst lebéníthatnák a szükségtelen cselekvések. Vegyük például a <span class="emphasis"><em>Mesterséges intelligencia modern megközelítésben</em></span> c. könyv internetes megvásárlásának a feladatát. Tegyük fel, hogy minden egyes 10 jegyű ISBN szám megvásárlása egy-egy cselekvés, ez összesen 10 milliárd cselekvést jelent. A keresési algoritmusnak mind a 10 milliárd cselekvés végállapotát meg kellene vizsgálnia, hogy megtalálja a célnak megfelelőt, nevezetesen, hogy birtokoljuk a 9635454112 ISBN számú könyvet. Másrészről egy értelmes tervkészítő ágensnek képesnek kell lenni arra, hogy a pontos cél <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>ISBN9635454112</em></span>) leírásából visszafelé dolgozva közvetlenül eljusson a <span class="emphasis"><em>Vásárol</em></span>(<span class="emphasis"><em>ISBN9635454112</em></span>) cselekvéshez. Hogy ezt megtehesse, az ágensnek arra az általános tudásra van szüksége, hogy a <span class="emphasis"><em>Vásárol</em></span>(<span class="emphasis"><em>x</em></span>) következménye a <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>x</em></span>). Ha adott ez a tudás, a tervező egy egyszerűsítési lépésben el tudja dönteni, hogy a <span class="emphasis"><em>Vásárol</em></span>(<span class="emphasis"><em>ISBN9635454112</em></span>) a helyes cselekvés.</p><p>A következő nehézség, egy jó <span class="strong"><strong>heurisztika</strong></span> (<span class="strong"><strong>heuristic function</strong></span>) meghatározása. Tegyük fel, hogy az ágens feladata négy különböző könyv megvásárlása. Ebből 10<sup>40</sup> négylépéses terv adódik, azaz nem kérdéses, hogy egy megfelelő heurisztika nélküli keresés értelmetlen. Az ember számára egy állapot költségének becslésére kézenfekvő heurisztika a továbbiakban még megvásárolandó könyvek száma. Sajnos ez nem nyilvánvaló egy problémamegoldó ágens számára, hisz az a céltesztet egy fekete dobozként látja, mely minden állapotra mindössze egy igaz-hamis értéket ad vissza. Ennek következményeképp a problémamegoldó ágens nem autonóm; azaz emberi beavatkozást igényel minden új problémánál az alkalmazható heurisztika megadására. Másrészről, ha az ágensnek rendelkezésére áll a cél leírása, mint részcélok konjunkciója, akkor használhat egy egyszerű feladatfüggetlen heurisztikát: a még nem teljesített részcélok számát. A könyvvásárlási feladat esetén a cél <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>A</em></span>) ∧ <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>B</em></span>) ∧ <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>C</em></span>) ∧ <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>D</em></span>) lenne, és a <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>A</em></span>) ∧ <span class="emphasis"><em>Birtokol</em></span>(<span class="emphasis"><em>C</em></span>) állapot költsége 2. Így az ágens számára automatikusan elérhető a helyes heurisztika erre és más problémákra is. A fejezet későbbi részében látni fogjuk, hogy hogyan lehet létrehozni olyan kifinomultabb heurisztikákat, ami a célstruktúráján túl számba veszi a végrehajtható cselekvéseket is.</p><p>Végül a problémamegoldó ágens nem hatékony, mert nem tudja kihasználni a <span class="strong"><strong>problémadekompozíció</strong></span> (<span class="strong"><strong>problem decomposition</strong></span>) lehetőségét. Vegyük például a következő feladatot: több csomagot kell kiszállítanunk a megfelelő címekre, melyek Ausztrália különböző pontjain találhatók. Jó megközelítés, ha megkeressük a célpontokhoz legközelebb eső reptereket, és felosztjuk a teljes problémát több részfeladatra; repterenként egyre. Az egy reptéren keresztül irányított csomagok esetén a további dekompozíció lehetősége a célvárostól függ. Az 5. fejezetben láttuk, hogy egy ilyen felbontás képessége hozzájárul a kényszerkielégítési feladatmegoldók hatékonyságához. A tervkészítőkre ugyanez igaz: a legrosszabb esetben <span class="emphasis"><em>n</em></span> csomag legjobb kiszállítási tervének elkészítése <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>!), míg ha a feladat <span class="emphasis"><em>k</em></span> egyenlő részre bontható ez mindössze <span class="emphasis"><em>O</em></span>((<span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>k</em></span>)! × <span class="emphasis"><em>k</em></span>) komplexitású feladat<span class="emphasis"><em>.</em></span></p><p>Ahogy az 5. fejezetben megjegyeztük, a teljesen dekomponálható problémák jók, de ritkák.<sup>[<a id="id637561" href="#ftn.id637561" class="footnote">111</a>]</sup> A legtöbb tervkészítő rendszer felépítése – különösen a 11.3. fejezetben bemutatásra kerülő részben rendezett tervkészítő felépítése – azon a feltételezésen alapul, mely szerint a legtöbb valós, életszerű probléma <span class="strong"><strong>majdnem dekomponálható</strong></span> (<span class="strong"><strong>nearly decomposable</strong></span>). Ez annyit jelent, hogy a tervkészítő dolgozhat független részcélokon, de a résztervek összekombinálása további feladatokat eredményezhet. Néhány feladat esetén ez a feltételezés nem helytálló, mert az egyik részcél kidolgozása gyakran megbontja a másik részcélt. Ezek a részcélok közötti kölcsönhatások azok, amelyek a fejtörőket (mint a nyolcas kirakó) valójában fejtörővé teszik.</p><div class="section" title="A tervkészítési problémák nyelve"><div class="titlepage"><div><div><h2 class="title"><a id="id637576"/>A tervkészítési problémák nyelve</h2></div></div></div><p class="3">A fent leírtak alapján a tervkészítési problémák reprezentációjának – ami az állapotokat, cselekvéseket és célokat jelenti – lehetőséget kellene biztosítania a tervkészítő algoritmus számára, hogy a feladat logikai struktúráját kihasználhassa. Ennek kulcsa, hogy olyan nyelvet találjunk, ami kellően kifejező ahhoz, hogy a problémák egy széles körét leírja, ugyanakkor kellően szigorú ahhoz, hogy a leírásokon hatékony algoritmusok működhessenek. Ebben a fejezetben először körvonalazzuk a klasszikus tervkészítők által használt alapnyelvet, ami <code class="code">STRIPS</code> néven ismert.<sup>[<a id="id637587" href="#ftn.id637587" class="footnote">112</a>]</sup> Később rámutatunk a számos módosítási lehetőségből néhányra a <code class="code">STRIPS</code>-szerű nyelvekben.</p><p><span class="strong"><strong>Az állapotok leírása. </strong></span>A tervkészítők a világot logikai feltételekre dekomponálják, és az állapotokat a pozitív literálok konjunkciójaként írják le. Tekintsük az ítéletlogikai literálokat; például a <span class="emphasis"><em>Szegény </em></span>∧ <span class="emphasis"><em>Ismeretlen</em></span> reprezentálhatja egy szerencsétlen ágens állapotát. Elsőrendű literálokat is felhasználunk; például <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>Repülő</em></span><sub>1</sub>, <span class="emphasis"><em>Melbourne</em></span>) ∧<span class="emphasis"><em> Ott</em></span>(<span class="emphasis"><em>Repülő</em></span><sub>2</sub>, <span class="emphasis"><em>Sydney</em></span>) a csomagszállítási feladat egy állapotát írhatja le. Az elsőrendű logikai állapotleírások literáljainak <span class="strong"><strong>alap</strong></span>- és <span class="strong"><strong>függvénymentes</strong></span> <span class="strong"><strong>literál</strong></span>nak (<span class="strong"><strong>ground and function-free</strong></span>) kell lenniük. Az olyan literálok, mint az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) vagy az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>Ferenc</em></span>), <span class="emphasis"><em>Sydney</em></span>) nem megengedettek. A <span class="strong"><strong>zárt világ feltételezés</strong></span>t (<span class="strong"><strong>closed-world assumption</strong></span>) használjuk, ami annyit tesz, hogy a nem felsorolt állításokat hamisnak vesszük.</p><p><span class="strong"><strong>A célok leírása.</strong></span> A cél egy részlegesen definiált állapot, melyet pozitív alapliterálok konjunkciója reprezentál, mint <span class="emphasis"><em>Gazdag</em></span> ∧<span class="emphasis"><em> Híres</em></span> vagy <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>P</em></span><sub>2</sub>, <span class="emphasis"><em>Tahiti</em></span>). Az <span class="emphasis"><em>s</em></span> ítéletlogikai állapot <span class="strong"><strong>kielégíti a</strong></span> <span class="emphasis"><em>c</em></span> <span class="strong"><strong>célt</strong></span> (<span class="strong"><strong>goal satisfiction</strong></span>), ha <span class="emphasis"><em>s</em></span> tartalmazza a <span class="emphasis"><em>c</em></span>-ben szereplő összes atomot (és esetleg még továbbiakat). Például a <span class="emphasis"><em>Gazdag</em></span> ∧ <span class="emphasis"><em>Híres </em></span>∧ <span class="emphasis"><em>Szomorú </em></span>állapot kielégíti a<span class="emphasis"><em> Gazdag </em></span>∧ <span class="emphasis"><em>Híres</em></span> célt.</p><p><span class="strong"><strong>A cselekvések leírása.</strong></span> A cselekvést a következő két állapot határozza meg: az előfeltétel, aminek teljesülni kell az akció végrehajtásához, és a következmény, ami a végrehajtás eredményeként lép fel. Például két állomás közötti repülés leírása az alábbi:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Repül</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">honnan</span></em>, <em><span class="remark">hova</span></em>),</code></p><p><code class="code">     Előfeltétel: <em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">honnan</span></em>) ∧ <em><span class="remark">Repülő</span></em>(<em><span class="remark">p</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">honnan</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">hova</span></em>)</code></p><p><code class="code">     Következmény: ¬<em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">honnan</span></em>) ∧<em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">hova</span></em>))</code></p><p>Ezt pontosabban <span class="strong"><strong>cselekvési sémá</strong></span>nak (<span class="strong"><strong>action schema</strong></span>) nevezzük, ami azt takarja, hogy ez számos különböző cselekvést reprezentál, ami a <span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>honnan</em></span> és a <span class="emphasis"><em>hova</em></span> változók különböző behelyettesítéseivel származtatható. Általánosságban a cselekvési séma három fő részből áll:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A cselekvés megnevezése és paraméterlistája – például a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>honnan</em></span>, <span class="emphasis"><em>hova</em></span>) – a cselekvés azonosítására szolgál.</p></li><li class="listitem"><p>Az <span class="strong"><strong>előfeltétel</strong></span> (<span class="strong"><strong>precondition</strong></span>), függvényektől mentes pozitív literálok konjunkciója, azt mutatva, hogy milyen feltételeknek kell előzetesen teljesülni a cselekvés végrehajtásához.</p></li><li class="listitem"><p>A <span class="strong"><strong>következmény</strong></span> (<span class="strong"><strong>effect</strong></span>), függvényektől mentes literálok konjunkciója, ami leírja, hogy az állapot hogyan változik, amikor a cselekvés végrehajtásra kerül. A cselekmény eredményeképp adódó következményrészben szereplő<span class="emphasis"><em> P</em></span> pozitív literál igaz értéket kap, míg a ¬<span class="emphasis"><em>P</em></span> hamis értéket vesz fel. A következményrészben szereplő változóknak a cselekvés előfeltételei között is szerepelni kell.</p></li></ul></div><p>Az olvashatóság javítása érdekében néhány tervkészítő következményrészt szétválasztja egy <span class="strong"><strong>hozzáadás listá</strong></span>ra (<span class="strong"><strong>add list</strong></span>) a pozitív és egy <span class="strong"><strong>törlés listá</strong></span>ra (<span class="strong"><strong>delete list</strong></span>) a negatív literáloknak.</p><p>Most hogy a tervkészítők reprezentációjának szintaxisát definiáltuk, adjuk meg a szemantikát is. Ennek legegyszerűbb módja, ha leírjuk, hogy a cselekvések hogyan módosítják az állapotot. (Egy másik lehetséges módszer, hogy egy direkt fordítást specifikálunk a következő állapot axiómákra, melyek szemantikája az elsőrendű logikából származik. Lásd 11.3. feladat.) Először is azt mondjuk, hogy egy cselekvés <span class="strong"><strong>alkalmazható</strong></span> (<span class="strong"><strong>applicable</strong></span>) minden állapotban, ami kielégíti az előfeltételeket; egyébként a cselekvés hatástalan. Egy elsőrendű séma esetében az alkalmazhatóság elérése az előfeltételek egy <span class="emphasis"><em>θ</em></span> behelyettesítését vonja maga után. Tegyük fel például, hogy a jelen állapot leírása:</p><p><code class="code"><em><span class="remark">Ott</span></em>(<em><span class="remark">P</span></em><sub>1</sub>, <em><span class="remark">JFK</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">P</span></em><sub>2</sub>, <em><span class="remark">SFO</span></em>) ∧ <em><span class="remark">Repülő</span></em>(<em><span class="remark">P</span></em><sub>1</sub>) ∧ <em><span class="remark">Repülő</span></em>(<em><span class="remark">P</span></em><sub>2</sub>)</code></p><p><code class="code">∧<em><span class="remark"> Repülőtér</span></em>(<em><span class="remark">JFK</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">SFO</span></em>)</code></p><p>Ez teljesíti az</p><p><code class="code"><em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">honnan</span></em>) ∧  <em><span class="remark">Repülő</span></em>(<em><span class="remark">p</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">honnan</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">hova</span></em>)</code></p><p>előfeltételt a {<span class="emphasis"><em>p</em></span>/<span class="emphasis"><em>P</em></span><sub>1</sub>,<span class="emphasis"><em> honnan</em></span>/<span class="emphasis"><em>JFK</em></span>,<span class="emphasis"><em> hova</em></span>/<span class="emphasis"><em>SFO</em></span>} behelyettesítésekkel (és másokkal is – lásd 11.2. feladat). Így a konkrét <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>P</em></span><sub>1</sub>, <span class="emphasis"><em>JFK</em></span>, <span class="emphasis"><em>SFO</em></span>) cselekvés alkalmazható.</p><p>Az <span class="emphasis"><em>s</em></span> állapotból kiindulva az alkalmazható <span class="emphasis"><em>a</em></span> cselekvés végrehajtásának <span class="emphasis"><em>eredménye</em></span> az <span class="emphasis"><em>s</em></span>' állapot, ami azonos<span class="emphasis"><em> s</em></span>-sel, kivéve, hogy az <span class="emphasis"><em>a</em></span> cselekvés következményrészében szereplő pozitív <span class="emphasis"><em>P</em></span> literálokat az <span class="emphasis"><em>s</em></span>’-höz adjuk, míg bármilyen ¬<span class="emphasis"><em>P</em></span> negatív literált eltávolítjuk <span class="emphasis"><em>s</em></span>’-ből. Így a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>P</em></span><sub>1</sub>, <span class="emphasis"><em>JFK</em></span>, <span class="emphasis"><em>SFO</em></span>) cselekvés után az állapot a következő:</p><p><code class="code"><em><span class="remark">Ott</span></em>(<em><span class="remark">P</span></em><sub>1</sub>, <em><span class="remark">SFO</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">P</span></em><sub>2</sub>, <em><span class="remark">SFO</span></em>) ∧ <em><span class="remark">Repülő</span></em>(<em><span class="remark">P</span></em><sub>1</sub>) ∧ <em><span class="remark">Repülő</span></em>(<em><span class="remark">P</span></em><sub>2</sub>)</code></p><p><code class="code">∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">JFK</span></em>) ∧ <em><span class="remark">Repülőtér</span></em>(<em><span class="remark">SFO</span></em>)</code></p><p>Vegyük észre, hogy a már szereplő pozitív következményeket nem szúrjuk be még egyszer, illetve ha egy negatív literál nem szerepel az állapotleírásban, akkor a következmény ezen része figyelmen kívül hagyható. Ez a definíció testesíti meg az úgynevezett <code class="code">STRIPS</code> <span class="strong"><strong>feltételezés</strong></span>t (<span class="strong"><strong>assumption</strong></span>): minden a következményben nem szereplő literál változatlan marad. Így a <code class="code">STRIPS</code> elkerüli a 10. fejezetben bemutatott <span class="strong"><strong>reprezentációs keret problémá</strong></span>t (<span class="strong"><strong>representional frame problem</strong></span>).</p><p>Végezetül definiálhatjuk a tervkészítési probléma <span class="strong"><strong>megoldás</strong></span>át (<span class="strong"><strong>solution</strong></span>). Legegyszerűbb formájában ez csak egy cselekvéssorozat, melyet a kiindulási állapotból végrehajtva a célállapotot eredményezi. A fejezet további részeiben a megoldások cselekvések részben rendezett sorozatai is lehetnek, amennyiben minden cselekvéssorozat, ami megfelel ennek a részben rendezésnek, megoldás.</p></div><div class="section" title="Kifejezőképesség és kiterjesztések"><div class="titlepage"><div><div><h2 class="title"><a id="id640011"/>Kifejezőképesség és kiterjesztések</h2></div></div></div><p class="3">A sokféle megkötés, korlátozás amit a <code class="code">STRIPS</code> nyelv tartalmaz, abban a reményben került beépítésre, hogy a tervkészítő algoritmusok egyszerűbbek és hatékonyabbak lehessenek, anélkül hogy a valós problémák leírását megnehezítenék. Egyike a legfontosabb megkötéseknek, hogy a literáloknak <span class="emphasis"><em>függvénymenteseknek</em></span> kell lenniük. Ezzel a megkötéssel biztosíthatjuk, hogy egy adott problémához tartozó bármely akció séma ítéletkalkulus formára, azaz változómentes ítéletlogikai cselekvés reprezentációk véges halmazára hozható. (A téma bővebb leírását lásd a 9. fejezetben.) Például a légi szállítási problémakörben 10 repülő és 5 repülőtér esetén a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>honnan</em></span>, <span class="emphasis"><em>hova</em></span>) séma 10 × 5 × 5 = 250 ítéletlogikai cselekvésre fordítható. A 11.4. és 11.5. alfejezet tervkészítői közvetlenül az ítéletkalkulusra hozott leírással dolgoznak. Ha függvényszimbólumokat is megengedünk, akkor végtelen sok állapot és cselekvés határozható meg.</p><div class="figure"><a id="id640039"/><p class="title"><strong>11.1. ábra - A <span class="emphasis"><em>Strips</em></span> és az ADL nyelv összehasonlítása a tervkészítési feladatok reprezentációjának szempontjából. Mindkét esetben a célok úgy viselkednek, mint egy paraméterek nélküli cselekvés előfeltételei.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/11-01.png" alt="A Strips és az ADL nyelv összehasonlítása a tervkészítési feladatok reprezentációjának szempontjából. Mindkét esetben a célok úgy viselkednek, mint egy paraméterek nélküli cselekvés előfeltételei."/></div></div></div><p class="Képalá">Napjainkra, nyilvánvalóvá vált, hogy a <code class="code">STRIPS</code> nem eléggé kifejező néhány valós problémakörhöz. Ennek eredményeképpen számos nyelvváltozatot dolgoztak ki. A 11.1. ábra röviden összefoglalja az egyik legfontosabbat, a <span class="strong"><strong>cselekvésleíró nyelv</strong></span>et (<span class="strong"><strong>Action Description Language</strong></span> – <span class="strong"><strong>ADL</strong></span>) úgy, hogy összehasonlítja azt a <code class="code">STRIPS</code> alapverziójával. ADL nyelven a <span class="emphasis"><em>Repülés</em></span> leírása az alábbi:</p><p class="Tartalom3"><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Repül</span></em>(<em><span class="remark">p </span></em>:<em><span class="remark"> Repülő</span></em>,<em><span class="remark"> honnan </span></em>:<em><span class="remark"> Repülőtér</span></em>,<em><span class="remark"> hova </span></em>:<em><span class="remark"> Repülőtér</span></em>),</code></p><p><code class="code">		Előfeltétel: <em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>,<em><span class="remark"> honnan</span></em>) ∧ (<em><span class="remark">honnan</span></em> ≠ <em><span class="remark">hova</span></em>)</code></p><p><code class="code">		Következmény: ¬<em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">honnan</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">hova</span></em>))</code></p><p>A <span class="emphasis"><em>p</em></span> :<span class="emphasis"><em> Repülő</em></span> írásmód az előfeltételek a paraméterlistájában a <span class="emphasis"><em>Repülő</em></span>(<span class="emphasis"><em>p</em></span>) egy rövidítése, ami nem növeli a kifejezőképességet, de javítja az olvashatóságot. (Mindemellett redukálja a létrehozható ítéletlogikai cselekvések számát.) A (<span class="emphasis"><em>honnan</em></span> ≠ <span class="emphasis"><em>hova</em></span>) előfeltétel azt a tényt fejezi ki, hogy egy repülőút kiindulási és célállomása nem lehet azonos. Ezt a <code class="code">STRIPS</code> nyelvben nem lehetne tömören kifejezni.</p><p>A mesterséges intelligenciában használt változatos tervkészítő formalizmusokat egy szabványos szintaxisba rendszerezik, amit <span class="strong"><strong>tervkészítési terület definíciós nyelv</strong></span>nek (<span class="strong"><strong>Planning Domain Definition Language</strong></span> – <span class="strong"><strong>PDDL</strong></span>) neveznek. Ez a nyelv lehetővé teszi a kutatók számára, hogy benchmark problémákat cseréljenek ki egymás között, és összevessék az eredményeket. A PDDL résznyelveket tartalmaz az ADL és a 12. fejezetben bemutatásra kerülő hierarchikus feladathálózatok számára.</p><p>A <code class="code">STRIPS</code> és az ADL jelölésrendszere számos valós problémakörre megfelelő. A következő alfejezetek néhány egyszerű példát mutatnak be. Néhány számottevő megkötés azért még megmaradt. A legnyilvánvalóbb, hogy közvetlenül nem tartalmazzák a cselekvések <span class="strong"><strong>véghatás</strong></span>ait (<span class="strong"><strong>ramifications</strong></span>). Például ha vannak emberek, csomagok vagy porcicák egy repülőn, akkor mindannyian helyet változtatnak egy repülés során. Ezeket a változásokat leírhatjuk, mint a repülés egyenes következményeit, így természetesebbnek tűnik a repülőgép tartalmának helyét, mint a gép helyének logikai következményét ábrázolni. Az ilyen <span class="strong"><strong>állapotmegkötés</strong></span>ekre (<span class="strong"><strong>state constraint</strong></span>s) a 11.5. alfejezet tartalmaz példákat. A hagyományos tervkészítő rendszerek meg sem próbálják megoldani a <span class="strong"><strong>kvalifikációs problémá</strong></span>t (<span class="strong"><strong>qualification problem</strong></span>), azaz a nem reprezentált körülmények problémáját, melyek a cselekvés meghiúsulását okozhatják. A 12. fejezetben látni fogjuk, hogy a kvalifikációs probléma hogyan közelíthető meg.</p></div><div class="section" title="Példa: Légi teherszállítás"><div class="titlepage"><div><div><h2 class="title"><a id="id640240"/>Példa: Légi teherszállítás</h2></div></div></div><p class="3">A 11.2. ábra egy teherszállítási problémát mutat be, ami a teher be-, illetve kirakodását és állomások közötti légi szállítását tartalmazza. A probléma három cselekvéssel írható le: <span class="emphasis"><em>Berakodás</em></span>, <span class="emphasis"><em>Kirakodás</em></span> és <span class="emphasis"><em>Repülés</em></span>. A cselekvések két predikátumot érintenek: a <span class="emphasis"><em>Benne</em></span>(<span class="emphasis"><em>c</em></span>, <span class="emphasis"><em>p</em></span>) jelentése, hogy a <span class="emphasis"><em>c</em></span> teher a <span class="emphasis"><em>p</em></span> repülőgépben van, és az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>a</em></span>) jelentése, hogy az <span class="emphasis"><em>x</em></span> objektum (teher vagy repülőgép) az <span class="emphasis"><em>a</em></span> repülőtéren található. Vegyük észre, hogy a teher nincs <span class="emphasis"><em>Ott</em></span> sehol, ha <span class="emphasis"><em>Benne</em></span> van egy repülőgépben, azaz az <span class="emphasis"><em>Ott</em></span> valójában azt jelenti, hogy az objektum „elérhető a megadott helyen”. Tapasztalattal kell rendelkezni a cselekvésdefiníciók területén, ahhoz hogy az ilyen részleteket konzisztensen ábrázoljuk. A következő terv megoldása a feladatnak:</p><p class="Tartalom3"><code class="code">[<em><span class="remark">Berakodás</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">P</span></em><sub>1</sub>, <em><span class="remark">SFO</span></em>),<em><span class="remark"> Repülés</span></em>(<em><span class="remark">P</span></em><sub>1</sub>, <em><span class="remark">SFO</span></em>, <em><span class="remark">JFK</span></em>, <em><span class="remark">Kirakodás</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">P</span></em><sub>1</sub>, <em><span class="remark">JFK</span></em>)</code></p><p class="Tartalom3"><code class="code"><em><span class="remark">     Berakodás</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">P</span></em><sub>2</sub>, <em><span class="remark">JFK</span></em>),<em><span class="remark"> Repülés</span></em>(<em><span class="remark">P</span></em><sub>2</sub>, <em><span class="remark">JFK</span></em>, <em><span class="remark">SFO</span></em>, <em><span class="remark">Kirakodás</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">P</span></em><sub>2</sub>, <em><span class="remark">SFO</span></em>)]</code></p><div class="figure"><a id="id640426"/><p class="title"><strong>11.2. ábra - A <code class="code">STRIPS</code>-probléma repülőterek közötti légi teherszállítási feladathoz</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/11-02.png" alt="A STRIPS-probléma repülőterek közötti légi teherszállítási feladathoz"/></div></div></div><p>A mi reprezentációnk tisztán <code class="code">STRIPS</code> nyelvű. Nevezetesen ez engedélyezi, hogy egy repülő kiinduló és célállomása azonos repülőtér legyen. Az ADL egyenlőtlenség operátorai ezt kizárhatnák.</p></div><div class="section" title="Példa: A pótkerék probléma"><div class="titlepage"><div><div><h2 class="title"><a id="id640445"/>Példa: A pótkerék probléma</h2></div></div></div><p class="3">Vegyük a kerékcsere problémáját. Pontosabban a célunk az, hogy egy jó pótkerék legyen felszerelve az autó tengelyére, ahol a kiinduló állapotban egy lapos kerék van felszerelve, míg a jó pótkerék a csomagtartóban található. Az egyszerűség kedvéért a mi feladatunk elég absztrakt, azaz nincsenek beragadt csavarok vagy egyéb más nehézségek. Csak négy cselekvés van: a pótkerék kivétele a csomagtartóból, a lapos kerék eltávolítása a tengelyről, a pótkerék felszerelése és az autó magára hagyása reggelig. Feltételezzük, hogy az autó egy igen rossz környéken áll, ahol az autó magára hagyása azt eredményezi, hogy reggelre eltűnnek a kerekek.</p><p class="Képalá">A 11.3. ábra a feladat ADL leírását tartalmazza. Vegyük észre, hogy ez a megadás pusztán ítéletlogikai. A <code class="code">STRIPS</code> nyelven túlmutat, hogy a <span class="emphasis"><em>TeddFel</em></span>(<span class="emphasis"><em>Pótkerék</em></span>, <span class="emphasis"><em>Tengely</em></span>) cselekvéshez a ¬<span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>Pótkerék</em></span>, <span class="emphasis"><em>Tengely</em></span>) negált előfeltétel tartozik. Ezt elkerülhetnénk egy <span class="emphasis"><em>SzabaddáTesz</em></span>(<span class="emphasis"><em>Tengely</em></span>) használatával, amint azt a következő példában látni fogjuk.</p><div class="figure"><a id="id640489"/><p class="title"><strong>11.3. ábra - Az egyszerű pótkerék probléma</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/11-03.png" alt="Az egyszerű pótkerék probléma"/></div></div></div></div><div class="section" title="Példa: A kockavilág"><div class="titlepage"><div><div><h2 class="title"><a id="id640499"/>Példa: A kockavilág</h2></div></div></div><p class="3">Az egyik leghíresebb tervkészítési terület a <span class="strong"><strong>kockavilág</strong></span> (<span class="strong"><strong>blocks world</strong></span>) probléma. A terület asztallapon elhelyezett kockákból áll.<sup>[<a id="id640516" href="#ftn.id640516" class="footnote">113</a>]</sup> A kockákat egymásra rakhatjuk, de egy kockán közvetlenül mindig csak egyetlen másik helyezhető el. A kockákat egy robotkarral mozgathatjuk, amely fel tud venni egy kockát, majd azt vagy az asztalra, vagy egy másik kocka tetejére le tudja tenni. A robotkar egyszerre csak egy kockát tud felemelni, vagyis olyat nem, amelynek a tetején egy másik kocka van. A cél mindig egy vagy több kockaoszlop építése, amelyekben a kockák egymáshoz képesti elhelyezkedése meghatározott. A cél lehet például két oszlop építése, amelyek közül az egyikben az <span class="emphasis"><em>A</em></span> kocka a <span class="emphasis"><em>B</em></span> tetején van, a másikban pedig a <span class="emphasis"><em>C</em></span> kocka van a <span class="emphasis"><em>D</em></span> tetején.</p><p>A <span class="emphasis"><em>Rajta</em></span>(<span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>x</em></span>) jelölést használjuk annak leírására, hogy a <span class="emphasis"><em>b</em></span> kocka az <span class="emphasis"><em>x</em></span>-en van, ahol az <span class="emphasis"><em>x</em></span> egy másik kockát vagy az asztallapot jelenti. A <span class="emphasis"><em>Mozgat</em></span>(<span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>)<span class="emphasis"><em> </em></span>cselekvés a <span class="emphasis"><em>b</em></span> kockát a <span class="emphasis"><em>x</em></span> tetejéről az <span class="emphasis"><em>y</em></span> tetejére mozgatja. A <span class="emphasis"><em>b</em></span> kocka mozgatásának előfeltétele, hogy rajta semmi ne legyen. Ennek leírása az elsőrendű logikában a ¬∃<span class="emphasis"><em>x Rajta</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>b</em></span>) vagy ∀<span class="emphasis"><em>x </em></span>¬<span class="emphasis"><em>Rajta</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>b</em></span>). Az ADL nyelvben ezek előfeltételek lehetnének. A <code class="code">STRIPS</code> nyelv keretei között maradhatunk az <span class="emphasis"><em>Üres</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>predikátum bevezetésével, ami akkor igaz, ha semmi nincs <span class="emphasis"><em>x</em></span>-en. </p><p>A <span class="emphasis"><em>Mozgat</em></span> cselekvés a <span class="emphasis"><em>b</em></span> kockát az <span class="emphasis"><em>x</em></span>-ről az <span class="emphasis"><em>y</em></span>-ra mozgatja, ha mind a <span class="emphasis"><em>b</em></span>, mind pedig az <span class="emphasis"><em>y</em></span> üres. A mozgatás után az <span class="emphasis"><em>x</em></span> üres, de az <span class="emphasis"><em>y</em></span> már nem. A <span class="emphasis"><em>Mozgat</em></span> formális leírása <code class="code">STRIPS</code>-ben a következő:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Mozgat</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>),</code></p><p><code class="code">	Előfeltétel: <em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>) ∧ <em><span class="remark">Üres</span></em>(<em><span class="remark">b</span></em>) ∧ <em><span class="remark">Üres</span></em>(<em><span class="remark">y</span></em>)</code></p><p><code class="code">	Következmény: <em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">y</span></em>) ∧ <em><span class="remark">Üres</span></em>(<em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Üres</span></em>(<em><span class="remark">y</span></em>))</code></p><p>Sajnos ez a cselekvés nem kezeli jól az <span class="emphasis"><em>Üres</em></span> predikátumot, ha az <span class="emphasis"><em>x</em></span> vagy az <span class="emphasis"><em>y</em></span> az asztalon van. </p><p>Ha <span class="emphasis"><em>x</em></span> = <span class="emphasis"><em>Asztal</em></span>, a cselekvés következményei között szerepel az <span class="emphasis"><em>Üres</em></span>(<span class="emphasis"><em>Asztal</em></span>) is, de az asztalnak nem kell kiürülnie a mozgatás után, ha pedig <span class="emphasis"><em>y</em></span> = <span class="emphasis"><em>Asztal</em></span>, megjelenik az <span class="emphasis"><em>Üres</em></span>(<span class="emphasis"><em>Asztal</em></span>) előfeltétel, holott az asztalnak nem kell üresnek lenni ahhoz, hogy bármit is tehessünk rá. Ennek kiküszöbölésére két dolgot tehetünk. Először is bevezetünk egy új cselekvést, amellyel egy <span class="emphasis"><em>b</em></span> kockát az asztalra tehetünk:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">AsztalraTesz</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>),</code></p><p><code class="code">	Előfeltétel: <em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>) ∧ <em><span class="remark">Üres</span></em>(<em><span class="remark">b</span></em>)</code></p><p><code class="code">	Következmény: <em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">Asztal</span></em>) ∧ <em><span class="remark">Üres</span></em>(<em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Rajta</span></em>(<em><span class="remark">b</span></em>, <em><span class="remark">x</span></em>))</code></p><p>Másodszor az <span class="emphasis"><em>Üres</em></span>(<span class="emphasis"><em>b</em></span>) predikátumot úgy értelmezhetjük, hogy „<span class="emphasis"><em>b</em></span> tetején van elég szabad hely, ahová a kockát letehetjük”. Ezek szerint az <span class="emphasis"><em>Üres</em></span>(<span class="emphasis"><em>Asztal</em></span>) mindig igaz. Az egyetlen probléma, hogy semmi nem gátolja a tervkészítőt abban, hogy a <span class="emphasis"><em>Mozgat</em></span>(<span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Asztal</em></span>) cselekvést alkalmazza az <span class="emphasis"><em>AsztalraTesz</em></span>(<span class="emphasis"><em>b</em></span>, <span class="emphasis"><em>x</em></span>) helyett. Vagy együtt élünk ezzel a problémával (amely egyébként a szükségesnél nagyobb keresési teret eredményez, de nem vezet hibás válaszokhoz), vagy bevezethetjük a <span class="emphasis"><em>Kocka</em></span> predikátumot, és a <span class="emphasis"><em>Mozgat</em></span> cselekvés előfeltételeihez hozzátehetjük a <span class="emphasis"><em>Kocka</em></span>(<span class="emphasis"><em>x</em></span>) ∧ <span class="emphasis"><em>Kocka</em></span>(<span class="emphasis"><em>b</em></span>) részt.</p><div class="figure"><a id="id640963"/><p class="title"><strong>11.4. ábra - A kockavilág tervkészítési problémája: egy három kockából álló torony építése. A [<span class="emphasis"><em>Mozgat</em></span>(<span class="emphasis"><em>B, Asztal, C</em></span>),<span class="emphasis"><em> Mozgat</em></span>(<span class="emphasis"><em>A</em></span>,<span class="emphasis"><em> Asztal</em></span>,<span class="emphasis"><em> B</em></span>)] cselekvéssor egy lehetséges megoldás.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/11-04.png" alt="A kockavilág tervkészítési problémája: egy három kockából álló torony építése. A [Mozgat(B, Asztal, C), Mozgat(A, Asztal, B)] cselekvéssor egy lehetséges megoldás."/></div></div></div><p class="Képalá">Végül itt van még az olyan hibás műveletek esete, mint a <span class="emphasis"><em>Mozgat</em></span>(<span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>C</em></span>, <span class="emphasis"><em>C</em></span>), amely hatástalan kellene legyen, ehelyett azonban ellentmondó következményekhez vezet. Általában nem foglalkozunk az ilyen jellegű problémákkal, mert nemigen vannak hatással az előállított tervekre. A helyes megközelítés, hogy egyenlőtlenségi előfeltételeket vezetünk be, amint azt a 11.4. ábra mutatja.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id637561" href="#id637561" class="para">111</a>] </sup> Vegyük észre, hogy még a csomagkiszállítási feladat sem teljesen dekomponálható. Vannak esetek, amikor jobb a csomagokat mégis egy távolabbi reptérre irányítani, ha ezzel megspórolhatunk egy külön repülőjáratot a közelire. Mindemellett a legtöbb szállítócég inkább a már bejáratott dekomponált megoldásokhoz ragaszkodik, hogy csökkentse a számítási és szervezési nehézségeket.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id637587" href="#id637587" class="para">112</a>] </sup> A <code class="code">STRIPS</code> a STandford Research Institute Problem Solver rövidítése.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id640516" href="#id640516" class="para">113</a>] </sup> A tervkészítés kutatásában használt kockavilág sokkal egyszerűbb, mint az <code class="code">SHRDLU</code> verzió, amit az <a class="xref" href="ch01s03.md#ID_52_oldal">„Korai lelkesedés, nagy elvárások (1952–1969)”</a> részben mutattunk be.</p></div></div></div></body></html>
