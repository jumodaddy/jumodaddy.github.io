<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Mozgás"><div class="titlepage"><div><div><h1 class="title"><a id="id793770"/>Mozgás</h1></div></div></div><p>Beszéltünk már arról, hogyan <span class="emphasis"><em>tervezzük </em></span>meg a mozgást, de arról nem, hogy hogyan <span class="emphasis"><em>mozogjunk</em></span>. Az eddigi terveink – különösen azok, amelyeket determinisztikus pályatervezővel állítottunk elő – feltételezik, hogy a robot egyszerűen képes követni bármilyen megtervezett pályát. A valóságban természetesen nem ez a helyzet. A robotoknak van tehetetlenségük, ezért nem tudnak tetszőleges pályát követni, csak nagyon kis sebesség esetén. A legtöbbször erőt kell kifejtenie a robotnak, nem pedig meghatározott pozícióba eljutnia. Ez a fejezet azokról a módszerekről szól, amelyekkel ki lehet számítani ezeket az erőket.</p><div class="figure"><a id="id793783"/><p class="title"><strong>25.20. ábra - Robotkarvezérlés (a) egységnyi erősítésű arányos szabályozóval; (b) 0,1-es erősítési tényezőjű arányos szabályozóval; (c) PD szabályozóval, 0,3-as erősítésű arányos taggal és 0,8-as differenciáló komponenssel. Mindhárom esetben a robotkar a szürkével jelölt pályát próbálta követni.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/25-20.png" alt="Robotkarvezérlés (a) egységnyi erősítésű arányos szabályozóval; (b) 0,1-es erősítési tényezőjű arányos szabályozóval; (c) PD szabályozóval, 0,3-as erősítésű arányos taggal és 0,8-as differenciáló komponenssel. Mindhárom esetben a robotkar a szürkével jelölt pályát próbálta követni."/></div></div></div><div class="section" title="Dinamika és vezérlés"><div class="titlepage"><div><div><h2 class="title"><a id="id793792"/>Dinamika és vezérlés</h2></div></div></div><p>A 25.2. alfejezetben már megismerkedtünk a <span class="strong"><strong>dinamikus állapot</strong></span> (<span class="strong"><strong>dynamic state</strong></span>) fogalmával, amely a robot sebességmodelljével kiterjeszti a robot kinematikai állapotát. Például egy csukló szögének értéke mellett a dinamika magában foglalja a szög változási sebességet is. A dinamikai állapot reprezentálására szolgáló állapotátmenet-modell tartalmazza az erők erre a változási sebességre gyakorolt hatását. Ezek a modellek általában <span class="strong"><strong>differenciálegyenletek</strong></span>et (<span class="strong"><strong>differential equations</strong></span>) használnak, amelyek egy kinematikai mennyiséget (például egy kinematikai állapotot) viszonyítanak annak időbeli megváltozásához (például a sebességhez) is. Elvileg a mozgástervezéshez a kinematikai helyett dinamikai modellt is használhattunk volna. Ez a metodika magasabb szintű teljesítményt eredményezne a robotnál, ha egyáltalán meg tudnánk alkotni a terveket. Azonban a dinamikai állapot sokkal bonyolultabb a kinematikainál. A dimenziók magas száma miatt ezt a módszert csak a legegyszerűbb robotok esetében lehetne sikeresen alkalmazni. Éppen ezért a gyakorlatban leginkább az egyszerűbb kinematikai pályatervező algoritmusokra hagyatkoznak.</p><p>A kinematikai pályatervező algoritmusok hiányosságainak kompenzálására gyakran használnak különálló <span class="strong"><strong>szabályozó</strong></span>kat (<span class="strong"><strong>controller</strong></span>s), hogy pontosan a pályán tartsák a robotot. Szabályozók segítségével a környezetből vett visszacsatolással valós időben generálhatók a vezérlőjelek az irányítási célok eléréséhez. <span class="strong"><strong>Referenciaszabályozó</strong></span>ról (<span class="strong"><strong>reference controller</strong></span>) beszélünk, ha az a feladat, hogy a robot egy előre kitűzött pályán maradjon – ezt hívják <span class="strong"><strong>referenciapályá</strong></span>nak (<span class="strong"><strong>reference path</strong></span>). Azokat a szabályozókat, amelyek globális költségfüggvényeket optimalizálnak, <span class="strong"><strong>optimális szabályozó</strong></span>knak (<span class="strong"><strong>optimal controller</strong></span>s) hívjuk. Az optimális stratégiák az MDF-ek számára valójában optimális szabályozók.</p><p>Első ránézésre egyszerűnek tűnik az a feladat, hogy adott pályán tartsuk a robotot. A gyakorlatban azonban még ennek a látszólag könnyű feladatnak is vannak buktatói. A 25.20. (a) ábrán láthatjuk, hogy mik adódhatnak. A fekete vonal a robot által befutott út, ahogy próbálja a kinematikai pályát követni. Ha eltérés keletkezik – zaj vagy a robot mozgása során fellépő erőkre vonatkozó korlátozások miatt –, a robot ellenkező irányú, az eltéréssel arányos nagyságú erővel igyekszik azt kompenzálni. Elsőre ez a megoldás kézenfekvőnek tűnik, mivel az eltéréseket ellenerőkkel kompenzáljuk, így a robot a pályán marad. Ugyanakkor mindez azt eredményezi, hogy robotunk erőteljesen vibrálni kezd, ahogy az a 25.20. (a) ábrán is látszik. Ez a vibráció a robotkar természetes tehetetlenségéből következik: amikor a robot visszaér a referenciapálya adott pontjára, túllendül, ami a korábbihoz hasonló, de ellentétes előjelű hibát eredményez. Ahogy az ábrán is látható, ez a fajta túllendülés akár az egész trajektória mentén folytatódhat, és az eredményül kapott mozgás nem éppen ideális. Világos, hogy jobb szabályozásra van szükség.</p><p>Mielőtt rátérnénk a megfelelőbb szabályozásra, formálisan írjuk le a túllendülést okozó szabályozót. Azokat a szabályozókat, amelyek ellentétes irányú, arányos erővel reagálnak a megfigyelt hibára <span class="strong"><strong>P szabályozó</strong></span>nak (<span class="strong"><strong>P controller</strong></span>) hívjuk. A P betű <span class="emphasis"><em>arányosat</em></span> <span class="emphasis"><em>(proportional)</em></span> jelent: a pillanatnyi vezérlés mindig arányos a robotkar hibájával. Még formálisabban kifejezve: legyen <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>t</em></span>) a referenciapálya idő (<span class="emphasis"><em>t</em></span>) szerint paraméterezve. A P szabályozó által generált <span class="emphasis"><em>a<sub>t</sub> </em></span>vezérlőjel:</p><p><code class="code"><em><span class="remark">a<sub>t</sub></span></em> = <em><span class="remark">K<sub>P</sub></span></em>(<em><span class="remark">y</span></em>(<em><span class="remark">t</span></em>) – <em><span class="remark">x<sub>t</sub></span></em>)</code></p><p>ahol <span class="emphasis"><em>X<sub>t</sub></em></span> a robotkar <span class="emphasis"><em>t</em></span> időpontbeli állapota. <span class="emphasis"><em>K<sub>P</sub></em></span> a szabályozó úgynevezett <span class="strong"><strong>erősítési tényező</strong></span>je (<span class="strong"><strong>gain parameter</strong></span>), ami azt határozza meg, hogy milyen hevesen reagál a szabályozó az aktuális <span class="emphasis"><em>x<sub>t</sub></em></span> állapot és a kívánt <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>t</em></span>) között lévő eltérésre. A példánkban <span class="emphasis"><em>K<sub>P</sub> = </em></span>1. Első pillantásra azt gondolhatja valaki, hogy ha <span class="emphasis"><em>K<sub>P</sub></em></span>-t kis értékűre választjuk, akkor az megoldja a problémát. Sajnos nem így van. A 25.20. (b) ábrán látható <span class="emphasis"><em>K<sub>P</sub> = </em></span>0,1 esetben a trajektória, amely továbbra is oszcillál. A kisebb erősítési tényező csak lelassította az oszcillációt, de egyáltalán nem oldotta meg a problémát. Ha elhanyagoljuk a súrlódást, a P szabályozó tulajdonképpen egy rugó, és a végtelenségig oszcillál a rögzített egyensúlyi pont körül.</p><p>Hagyományosan az ilyen problémákat az <span class="strong"><strong>irányításelmélet</strong></span> (<span class="strong"><strong>control theory</strong></span>) tárgykörébe sorolják. Ennek a tudományágnak egyre nagyobb a jelentősége a mesterséges intelligenciával foglalkozó kutatók számára. Évtizedek kutatásai során számos olyan szabályozót alkottak meg, amelyek lényegesen bonyolultabbak a fent használt egyszerű szabályozónál. Egy referenciaszabályozó <span class="strong"><strong>stabil </strong></span>(<span class="strong"><strong>stable</strong></span>), ha kis megváltozások csak korlátos hibát eredményeznek a referenciajelhez képest. <span class="strong"><strong>Szigorúan stabil</strong></span> (<span class="strong"><strong>strictly stable</strong></span>), ha a robot a kis megváltozások ellenére is vissza tud térni a referenciapályára. Látható, hogy a P szabályozónk stabil, de nem szigorúan stabil, mivel képtelen visszatérni a referenciatrajektóriára.</p><p>A legegyszerűbb szabályozó, ami eleget tesz a szigorú stabilitás követelményeinek a mi esetünkben a <span class="strong"><strong>PD szabályozó</strong></span> (<span class="strong"><strong>PD controller</strong></span>). A P betű továbbra is az arányosat jelöli, míg a D a <span class="emphasis"><em>differenciálót</em></span>. A PD szabályozót az alábbi egyenlet írja le:</p><p><span class="inlinemediaobject"><img src="math/mi-25-0014.gif" alt="Dinamika és vezérlés"/></span></p><p>Ahogy az már a képletből is látszik, a PD szabályozó egy differenciális taggal egészíti ki a P szabályozót, ami az <span class="emphasis"><em>a<sub>t</sub></em></span>-t egy olyan taggal bővíti, ami arányos az <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>t</em></span>) <span class="emphasis"><em>–</em></span> <span class="emphasis"><em>x<sub>t</sub></em></span> hiba idő szerinti első deriváltjával. Mi a hatása egy ilyen új tagnak? Általában a derivátor csillapítja a szabályozott rendszert. Tegyük fel, hogy egy adott rendszerben időben gyorsan változik az (<span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>t</em></span>) <span class="emphasis"><em>–</em></span> <span class="emphasis"><em>x<sub>t</sub></em></span>) hiba, mint ahogyan a fentebb tárgyalt esetben is. A differenciális tag ilyenkor az arányos ellenében hat, és összességében csökkenteni fogja a változásra történő reakciót. Ugyanakkor, ha a hiba állandósul, a differenciális tag háttérbe szorul, és az arányos tag fogja meghatározni a szabályozást.</p><p>PD szabályozót használva <span class="emphasis"><em>K<sub>P</sub></em></span> = 0,3 és <span class="emphasis"><em>K<sub>D</sub></em></span> = 0,8 paraméterekkel a 25.20. (c) ábrán lévő trajektóriát kapjuk. A pálya sokkal simább, és nem látható oszcilláció sem. Ahogy a példa is mutatja, egy differenciáló tag stabillá tehet egy szabályozót, amely enélkül nem az.</p><p>A gyakorlatban a PD szabályozónak is lehetnek hibái. Van úgy, hogy a PD szabályozó akkor sem tudja nullára redukálni a hibát, ha a külső eltérítés megszűnik. Ez a példánkból nem nyilvánvaló, de néha szükség van egy másik visszacsatolásra is az arányoson felül, hogy a hibát meg lehessen szüntetni. A megoldás erre a problémára egy harmadik tag hozzáadása a szabályozáshoz, ami a hiba idő szerinti integrálján alapul:</p><p><span class="inlinemediaobject"><img src="math/mi-25-0015.gif" alt="Dinamika és vezérlés"/></span></p><p><span class="emphasis"><em>K<sub>I</sub></em></span> egy újabb erősítési tényező. A kifejezés kiszámítja a hiba idő szerinti integrálját. Ennek hatására a referenciajel és az aktuális állapot között hosszan fennálló eltérés megszűnik. Például ha <span class="emphasis"><em>x<sub>t</sub></em></span> hosszabb ideig kisebb, mint <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>t</em></span>), akkor az integrál addig fog nőni, amíg az <span class="emphasis"><em>a<sub>t</sub></em></span> el nem tünteti a hibát. Az integrátor biztosítja, hogy a szabályozónak ne legyen rendszeres hibája, azon az áron, hogy nő az oszcilláció veszélye. <span class="strong"><strong>PID szabályozó</strong></span>nak (<span class="strong"><strong>PID controller</strong></span>) hívjuk azt a szabályozót, amelyik mindhárom tagot tartalmazza. Széles körben használják különböző ipari alkalmazásokhoz és irányítási feladatokhoz.</p></div><div class="section" title="Potenciáltér-vezérlés"><div class="titlepage"><div><div><h2 class="title"><a id="id794148"/>Potenciáltér-vezérlés</h2></div></div></div><p>A potenciáltereket mint újabb költségfüggvényeket vezettük be a robotmozgás-tervezés során, de alkalmasak arra is, hogy közvetlenül generálják a robot mozgását, kiegészítve a pályatervezési fázist. Ahhoz, hogy ezt elérjük, definiálnunk kell egy vonzó erőt, ami a robotot a célkonfiguráció felé vonzza, valamint egy taszító potenciálteret, amely távol tartja az akadályoktól. Egy ilyen teret már bemutattunk a 25.21. ábrán. Az egyetlen globális minimumhelye a célkonfiguráció, értéke pedig az e céltól való távolság, valamint az akadályok közelségének összege. Az ábrán bemutatott potenciáltér kialakítását nem előzte meg tervezés. Éppen ezért a potenciálterek jól alkalmazhatók valós idejű megoldásokhoz. A 25.21. ábrán két trajektória látható, ahogy egy robot két különböző kezdeti konfigurációból megpróbálja megmászni a potenciálteret. Nagyon sok alkalmazás esetén a potenciálteret hatékonyan ki lehet számítani bármilyen adott konfiguráció esetében. Sőt adott robotkonfiguráció esetén a potenciálok kialakulásával a potenciálgradienst is meghatározhatjuk. Ezek a számítások általában különösen hatékonyak, főleg a pályatervező algoritmusokhoz hasonlítva, amelyek mind exponenciálisak a konfigurációs tér dimenziójában (a szabadságfokokban).</p><div class="figure"><a id="id794154"/><p class="title"><strong>25.21. ábra - Potenciáltér-vezérlés. A robot egy potenciáltérben halad, amely az akadályoktól taszító erőkből és a célkonfigurációhoz vonzókból áll. (a) Sikeres útvonal. (b) Lokális optimum.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/25-21.png" alt="Potenciáltér-vezérlés. A robot egy potenciáltérben halad, amely az akadályoktól taszító erőkből és a célkonfigurációhoz vonzókból áll. (a) Sikeres útvonal. (b) Lokális optimum."/></div></div></div><p>Az a tény, hogy a potenciálteres módszer ilyen hatékonyan megtalálja az utat a célhoz a konfigurációs térben még nagy távolságok esetén is, megkérdőjelezi a tervezés szükségességét. Vajon csak szerencsénk volt a példánk esetében, vagy tényleg elegendő a potenciálterek használata? A válasz az, hogy szerencsénk volt. A potenciáltereknek számos olyan lokális minimumhelye lehet, amely csapdába ejti a robotot. Ebben az esetben a robot úgy közelíti meg az akadályt, hogy csak vállcsuklóját mozgatja egészen addig, amíg bele nem ütközik az akadályba a rossz oldalon. A potenciáltér nem ad annyi információt, hogy a robot behajlítsa a könyökét, hogy átférjen az akadály alatt. Más szavakkal, a potenciáltéren alapuló technikák nagyon jók lokális robotirányításra, de globális tervezést igényelnek. A másik hátulütője ennek a módszernek az, hogy az erők, amiket generál, csak az akadályoktól és a céltól való távolságtól függnek, nem veszik figyelembe a robot sebességét. Így a potenciáltér-alapú vezérlés tényleg egy kinematikai módszer, és nem feltétlenül működik, ha a robot gyorsan mozog.</p></div><div class="section" title="Reaktív irányítás"><div class="titlepage"><div><div><h2 class="title"><a id="id794166"/>Reaktív irányítás</h2></div></div></div><p>Eddig olyan irányítási módszerekkel foglalkoztunk, amelyek megkívánták a környezet bizonyos fokú ismeretét ahhoz, hogy akár referenciapályát, akár potenciálteret alkothassunk. Ezzel a megközelítéssel kapcsolatban azonban felmerülnek bizonyos problémák. Először is, sokszor nagyon nehéz pontos modellt alkotni a környezetről, különösen ha az komplex vagy nagyon távol van, mint mondjuk a Mars felszíne. Másodszor, még ha sikerül is pontos modellt készítenünk, a számítási nehézségek és a lokalizációs technikák hibája folytán alkalmazhatatlanná válnak ezek a módszerek. Bizonyos esetekben megfelelőbb a reflexszerű ágensek használata, ezt hívják <span class="strong"><strong>reaktív irányítás</strong></span>nak (<span class="strong"><strong>reactive control</strong></span>).</p><p>Erre példa a 25.22. (a) ábra <span class="strong"><strong>hexapod</strong></span>ja, azaz hatlábú robotja, amelyet nehéz terepen való közlekedésre terveztek. A robot szenzorai többnyire alkalmatlanok arra, hogy megfelelő pontosságú modellt alkossanak a környezetről, hogy a robot a korábban tárgyalt pályatervezési algoritmusok bármelyikét használhassa. De hiába látnánk el megfelelő szenzorokkal, a tizenkét szabadságfok (kettő lábanként) túl nagy számítási kapacitást igényelne pályatervezés esetén.</p><div class="figure"><a id="id794190"/><p class="title"><strong>25.22. ábra - (a) Hexapod robot. (b) Kiterjesztett véges automata (KVA) (augmented finite state machine, AFSM) egyetlen láb vezérléséhez. Fontos, hogy ez a KVA-szenzoros visszacsatolásra reagál: ha a láb megakad az előremozgatás során, akkor magasabbra emeli.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/25-22.png" alt="(a) Hexapod robot. (b) Kiterjesztett véges automata (KVA) (augmented finite state machine, AFSM) egyetlen láb vezérléséhez. Fontos, hogy ez a KVA-szenzoros visszacsatolásra reagál: ha a láb megakad az előremozgatás során, akkor magasabbra emeli."/></div></div></div><p>Mindazonáltal a környezet explicit ismerete nélkül is lehetséges közvetlenül szabályozót tervezni a feladathoz. (Már láttuk ezt a PD szabályozó esetében, amely képes volt a komplex robotkart a megadott pályán tartani a robot dinamikájának pontos ismerete <span class="emphasis"><em>nélkül</em></span>. Ugyanakkor szükség volt a kinematikai modell alapján megalkotott referenciapályára.) A hatlábú robot esetében megfelelő absztrakciós szinten meglepően könnyű meghatározni az irányítási törvényt. A megfelelő algoritmus ciklusosan mozgathatná a lábakat. Egy ideig a levegőben mozognak, utána pedig a földön támaszkodnak. A hat lábat úgy kell koordinálni, hogy egyszerre három (ellentétes oldalakon) mindig a földön legyen, biztosítva a robot fizikai stabilitását. Egy ilyen irányítási algoritmust könnyű programozni, és remekül működik sík felületen. Nehéz terepen az egyes akadályok meggátolhatják a lábakat az előremozdulásban. Ezen a problémán egy egészen egyszerű irányítási szabállyal segíthetünk: <span class="emphasis"><em>ha a láb mozgását valami blokkolja, a robot egyszerűen húzza vissza, emelje magasabbra, és próbálja újra! </em></span>Az eredményül kapott vezérlést, mint véges automatát mutatja a 25.22. (b) ábra. Egy reflexszerű ágenshez állapotokat társít, ahol a belső állapot a gép aktuális állapotának indexe (<span class="emphasis"><em>s</em></span><sub>1</sub>-től <span class="emphasis"><em>s</em></span><sub>4</sub>-ig) jelöli.</p><p>Ennek az egyszerű visszacsatoláson alapuló szabályozónak a különböző változatai figyelemre méltóan robusztus lépegető vezérlést valósítanak meg, amellyel a robot göröngyös terepen is képes előrejutni. Világos, hogy ehhez a szabályozóhoz nem kell környezeti modell, és nem kell semmiféle keresést alkalmazni a vezérlés megalkotásához. Amikor egy ilyen vezérlőt használunk, a robot viselkedésének kialakításában nagyon fontos szerepet kapnak a környezetből visszacsatolásként érkező jelek. A szoftver magától még nem határozza meg, hogy éppen mi fog történni a robottal, ha belehelyezik az adott környezetbe. Az olyan viselkedést, ami egy (egyszerű) szabályozó és a (komplex) környezet kölcsönhatásaként jön létre <span class="strong"><strong>kibontakozó viselkedés</strong></span>nek (<span class="strong"><strong>emergent behavior</strong></span>) hívjuk. Szigorúan véve bármelyik eddig tárgyalt robotra mondhatnánk, hogy kibontakozó viselkedést mutat, hiszen egyetlen modell sem tökéletes. Történeti okok miatt azonban ezt a kifejezést csak arra az irányítási technikára mondják, amelyik nem használ explicit környezeti modellt. A kibontakozó viselkedés jellemző tulajdonsága számos biológiai organizmusnak is.</p><p>Technikailag a reaktív irányítás csak egy implementációja az MDF-ek (illetve ha vannak belső állapotok, akkor POMDF-ek) stratégiáinak. A 17. fejezetben számos technikát ismertettünk, amelyek alkalmasak a robot modelljéből és a robot környezetének a modelljéből stratégiák generálására. A robotikában az ilyen stratégiák kézzel történő megszerkesztésének nagy gyakorlati jelentősége van, mivel képtelenek vagyunk tökéletes modelleket alkotni. A 21. fejezetben leírt megerősítéses tanulási módszerek segítségével tapasztalati úton lehet stratégiákat szerkeszteni. Néhány ezen módszerek közül – például a Q-tanulás és a stratégiakereső módszerek – nem igényel környezeti modellt, hanem a tanulás során összegyűjtött, nagy mennyiségű adatra támaszkodik. Így alkalmas jó minőségű szabályozók létrehozására robotok számára.</p></div></div></body></html>
