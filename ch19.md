<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="19. fejezet - A tudás szerepe a tanulásban"><div class="titlepage"><div><div><h1 class="title"><a id="id729172"/>19. fejezet - A tudás szerepe a tanulásban</h1></div></div></div><p><span class="emphasis"><em>Ebben a fejezetben a tanulással foglalkozunk, de csak akkor, amikor már tudunk is valamit.</em></span></p><p class="Tartalom3">Az előbbi három fejezetben bemutatott tanulási módszerek mindegyikében az volt az alapötlet, hogy egy olyan függvényt konstruálunk, amelynek bemeneti/kimeneti viselkedése megegyezik azzal, amit az adatoknál megfigyeltünk. Bármilyen esetet is nézünk, a tanulási módszer tulajdonképpen nem más, mint egy megfelelő függvénynek a hipotézistérben történő megkeresése, a függvény formájára vonatkozó igen elemi feltételezésekből kiindulva. Ilyen feltételezés lehet például, hogy a függvény „egy másodrendű polinom” vagy „egy döntési fa”, vagy az az elfogultság, hogy „az egyszerűbb a jobb”. Ennek megvalósítása felért azzal, mintha azt mondanánk, hogy mielőtt valami újat tanulnánk, el kellene felejteni (majdnem) mindent, amit tudunk. Ebben a fejezetben olyan tanulási módszereket tanulmányozunk, amelyek <span class="strong"><strong>a priori tudás</strong></span>ból (<span class="strong"><strong>prior knowledge</strong></span>) merítenek előnyöket. Az esetek többségében az a priori tudást elsőrendű elméletek segítségével reprezentáljuk. Így most először fogjuk összekapcsolni a tudásreprezentációra és a tanulásra vonatkozó eredményeket. </p><div class="section" title="A tanulás logikai megfogalmazása"><div class="titlepage"><div><div><h1 class="title"><a id="id729194"/>A tanulás logikai megfogalmazása</h1></div></div></div><p>A 18. fejezetben a tisztán induktív tanulást olyan folyamatnak tekintettük, amely egy, az adatokkal konzisztens hipotézist keresett. Most ezt a definíciót olyan esetre pontosítjuk, amikor a hipotézist logikai állítások halmazával reprezentáljuk. A példaleírások és besorolások szintén logikai állítások, egy új példát pedig úgy tudunk osztályozni, hogy egy osztályozó állítást a hipotézisből és a példa leírásából kikövetkeztetünk. Ezzel a megközelítéssel a hipotéziseket inkrementálisan, állításonként építhetjük. A megközelítés lehetővé teszi az a priori tudás használatát is, mivel a már megismert állításokat bevethetjük új példák osztályozásába. A tanulás logikai megfogalmazásában először látszólag sok a munka, ez azonban a tanulás számos aspektusát segíti tisztázni. Ez lehetővé teszi, hogy a 18. fejezetben megismert egyszerű tanulási módszereket jócskán túlszárnyaljuk azáltal, hogy a logikai következtetés teljes erejét tanulási célokra használjuk.</p><div class="section" title="Példák és hipotézisek"><div class="titlepage"><div><div><h2 class="title"><a id="id729200"/>Példák és hipotézisek</h2></div></div></div><a id="ID_783_oldal"/><p class="Tartalom3">Emlékezzünk a 18. fejezetben a tanulási problémára bemutatott étterem példára: egy olyan döntési szabály megtanulására, hogy vajon érdemes-e egy asztalra várni. A példákat olyan <span class="strong"><strong>attribútum</strong></span>okkal (<span class="strong"><strong>attribute</strong></span>s) írtuk le, mint az <span class="emphasis"><em>Alternatíva</em></span>, <span class="emphasis"><em>Bár</em></span>, <span class="emphasis"><em>Péntek/Szombat</em></span> stb. Logikai megközelítésben egy példa egy logikai állítással leírt objektum; az attribútumok pedig unáris predikátumok. Nevezzük általánosságban az <span class="emphasis"><em>i</em></span>-edik példát <span class="emphasis"><em>X<sub>i</sub></em></span>-nek. A 18.3. ábra első példáját az alábbi állítások írják le:</p><p><code class="code"><em><span class="remark">Alternatíva</span></em>(<em><span class="remark">X</span></em><sub>1</sub>) ∧ ¬<em><span class="remark">Bár</span></em>(<em><span class="remark">X</span></em><sub>1</sub>) ∧ ¬<em><span class="remark">PéntekSzombat</span></em>(<em><span class="remark">X</span></em><sub>1</sub>) ∧  <em><span class="remark">Éhes</span></em>(<em><span class="remark">X</span></em><sub>1</sub>) ∧  …</code></p><p>A <span class="emphasis"><em>D<sub>i</sub></em></span>(<span class="emphasis"><em>X<sub>i</sub></em></span>) jelöléssel az <span class="emphasis"><em>X<sub>i</sub></em></span> leírására fogunk hivatkozni, ahol <span class="emphasis"><em>D<sub>i</sub></em></span> tetszőleges, egyargumentumú logikai kifejezés lehet. Az objektumok osztályozását a</p><p><code class="code"><em><span class="remark">VárjunkE</span></em>(<em><span class="remark">X</span></em><sub>1</sub>)</code></p><p>állítás végzi. Pozitív példák esetén a <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>X<sub>i</sub></em></span>), negatív példák esetén a ¬<span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>X<sub>i</sub></em></span>) általános jelölést fogjuk használni. A teljes tanító halmaz az összes leíró és besoroló állítás konjunkciója.</p><p>Logikai megközelítésben az induktív tanulás célja a <span class="emphasis"><em>Q</em></span> célpredikátummal ekvivalens logikai kifejezés megtalálása, amivel korrektül tudjuk a példákat osztályozni. Mindegyik hipotézis egy-egy javaslat a keresett logikai kifejezésre, amit mi a célpredikátum <span class="strong"><strong>definíciójelölt</strong></span>jének (<span class="strong"><strong>candidate definition</strong></span>) nevezünk. Jelöljük <span class="emphasis"><em>C<sub>i</sub></em></span>-vel a definíciójelöltet, ekkor mindegyik <span class="emphasis"><em>H<sub>i</sub></em></span> hipotézis egy ∀<span class="emphasis"><em>x</em></span> <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>x</em></span>) ⇔ <span class="emphasis"><em>C<sub>i</sub></em></span>(<span class="emphasis"><em>x</em></span>) formájú kifejezés. Például a döntési fa azt fejezi ki, hogy a célpredikátum egy objektum esetében csak akkor igaz, ha az <span class="emphasis"><em>igaz</em></span>-hoz vezető egyik ága teljesül. Így a 18.6. ábrán látható döntési fa a következő logikai definíciót fejezi ki (amelyre a jövőben <span class="emphasis"><em>H<sub>r</sub></em></span>-rel fogunk hivatkozni):</p><p><code class="code">∀<em><span class="remark">r</span></em>  <em><span class="remark">VárjunkE</span></em>(<em><span class="remark">r</span></em>)    ⇔ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Néhány</span></em>)</code></p><p><code class="code"> ∨ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Tele</span></em>) ∧ <em><span class="remark">Éhes</span></em>(<em><span class="remark">r</span></em>) ∧ <em><span class="remark">Konyha</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Francia</span></em>)</code></p><p><code class="code">∨ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Tele</span></em>) ∧ <em><span class="remark">Éhes</span></em>(<em><span class="remark">r</span></em>) ∧ <em><span class="remark">Konyha</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Thai</span></em>)</code></p><p><code class="code">			∧ <em><span class="remark">Péntek</span></em>/<em><span class="remark">Szombat</span></em>(<em><span class="remark">r</span></em>)</code></p><p><code class="code">		 ∨ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Tele</span></em>) ∧ <em><span class="remark">Éhes</span></em>(<em><span class="remark">r</span></em>) ∧ <em><span class="remark">Konyha</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">Burger</span></em>)	(19.1)</code></p><p>Mindegyik hipotézis azt jósolja meg, hogy példák egy bizonyos halmaza, nevezetesen azok, amelyek kielégítik a hipotézisdefiníció jelöltjét, a célpredikátumnak megfelelő példák lesznek. Ezt a halmazt a predikátum <span class="strong"><strong>kiterjedés</strong></span>ének (<span class="strong"><strong>extension</strong></span>) nevezzük. Két különböző kiterjedéssel rendelkező hipotézis így logikailag ellentmondásban van egymással, hiszen legalább egy példa esetén eltérő eredményt jósolnak. Ha viszont azonos a kiterjedésük, akkor logikailag ekvivalensek.</p><p>A <span class="strong"><strong>H</strong></span> hipotézistér ezek után az összes olyan hipotézis {<span class="emphasis"><em>H</em></span><sub>1</sub>, …, <span class="emphasis"><em>H<sub>n</sub></em></span>} halmaza, amelyek kezelésére a tanuló algoritmust tervezték. Például <code class="code">DÖNTÉSI-FA-TANULÁS</code> algoritmus az adott attribútumokkal kialakítható összes döntési fa hipotézissel képes foglalkozni; így hipotézistere az összes döntési fát tartalmazza. Feltehetően a tanuló algoritmus hisz abban, hogy az egyik hipotézis korrekt, azaz hisz a</p><p><code class="code"><em><span class="remark">H</span></em><sub>1</sub> ∨ <em><span class="remark">H</span></em><sub>2</sub> ∨ <em><span class="remark">H</span></em><sub>3</sub> ∨ … ∨ <em><span class="remark">H<sub>n</sub></span></em>						(19.2)</code></p><p>logikai kifejezésben. Ahogy a példák érkeznek, a példákkal nem <span class="strong"><strong>konzisztens</strong></span> (<span class="strong"><strong>consistent</strong></span>) hipotéziseket ki lehet zárni. Vizsgáljuk meg alaposabban a konzisztencia ezen fogalmát. Nyilvánvaló, hogy ha a <span class="emphasis"><em>H<sub>i</sub></em></span> hipotézis a teljes tanító halmazzal konzisztens, akkor mindegyik példával konzisztensnek kell lennie. Mit jelent viszont az, hogy valamelyik példával ellentmondásban van? Ez kétféle módon történhet meg:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A hipotézis szempontjából egy példa <span class="strong"><strong>hamis negatív</strong></span> (<span class="strong"><strong>false negative</strong></span>), ha a valóságban pozitív, de a hipotézis szerint negatív. Például a következő leírással rendelkező <span class="emphasis"><em>X</em></span><sub>13</sub> új példa:</p></li></ul></div><p><code class="code">		<em><span class="remark">Vendégek</span></em>(<em><span class="remark">X</span></em><sub>13</sub>, <em><span class="remark">Tele</span></em>) ∧ <em><span class="remark">BecsültVárakozásE</span></em>(<em><span class="remark">X</span></em><sub>13</sub>,<em><span class="remark"> 0-10</span></em>) ∧ ¬<em><span class="remark">Éhes</span></em>(<em><span class="remark">X</span></em><sub>13</sub>) ∧ … ∧ 						∧<em><span class="remark">VárjunkE</span></em>(<em><span class="remark">X</span></em><sub>13</sub>)</code></p><p>	a korábban definiált <span class="emphasis"><em>H<sub>r</sub></em></span> hipotézis számára hamis negatív példa lesz. <span class="emphasis"><em>H<sub>r</sub></em></span>-ből, illetve a példa leírásából kikövetkeztethető mind a <span class="emphasis"><em>VárjunkE</em></span>(<span class="emphasis"><em>X</em></span><sub>13</sub>) – ezt állítja a példa, mind a ¬<span class="emphasis"><em>VárjunkE</em></span>(<span class="emphasis"><em>X</em></span><sub>13</sub>) – ezt állítja a hipotézis. Tehát a hipotézis és a példa logikailag ellentmondásban van.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A hipotézis szempontjából egy példa <span class="strong"><strong>hamis pozitív</strong></span> (<span class="strong"><strong>false positive</strong></span>), ha a valóságban negatív, de a hipotézis szerint pozitív.<sup>[<a id="id729736" href="#ftn.id729736" class="footnote">189</a>]</sup></p></li></ul></div><p>Ha egy példa hamis negatív vagy hamis pozitív egy hipotézis szempontjából, akkor a példa és a hipotézis logikailag ellentmondásban van egymással. Feltéve, hogy a példa a tények korrekt megfigyelésén alapul, a hipotézist kizárhatjuk. Logikailag ez a következtetés a rezolúciós szabállyal pontos analógiában van (lásd 9. fejezet). Hipotézisek diszjunkciója felel meg egy klóznak, a példa pedig megfelel annak a literálisnak, amely a klózban levő egyik literálissal rezolvál. Egy szokásos logikai következtető rendszer tehát elméletileg tud példákból tanulni oly módon, hogy egy vagy több hipotézist kizár. Tegyük fel például, hogy a példát az <span class="emphasis"><em>I</em></span><sub>1</sub> állítással jelöljük, és a hipotézistér <span class="emphasis"><em>H</em></span><sub>1</sub><span class="emphasis"><em> </em></span>∨ <span class="emphasis"><em>H</em></span><sub>2</sub><span class="emphasis"><em> </em></span>∨ <span class="emphasis"><em>H</em></span><sub>3</sub><span class="emphasis"><em> </em></span>∨ <span class="emphasis"><em>H</em></span><sub>4</sub>. Ha <span class="emphasis"><em>I</em></span><sub>1</sub> ellentmondásban van <span class="emphasis"><em>H</em></span><sub>2</sub>-vel és <span class="emphasis"><em>H</em></span><sub>3</sub>-mal, akkor a logikai következtető rendszer származtatni tudja az új <span class="emphasis"><em>H</em></span><sub>1</sub><span class="emphasis"><em> </em></span>∨ <span class="emphasis"><em>H</em></span><sub>4</sub> hipotézisteret.</p><p class="Tartalom3">Tehát az induktív tanulást logikai leírással olyan folyamatként jellemezhetjük, mint amelyik fokozatosan kizárja a példáknak ellentmondó hipotéziseket, leszűkítve a lehetőségek körét. Mivel a hipotézistér rendszerint nagy (vagy elsőrendű logika esetén egyenesen végtelen), nem javasoljuk egy rezolúcióalapú tételbizonyító rendszer építését és a hipotézistér teljes számbavételét. Ehelyett két megközelítést tárgyalunk, amelyek sokkal kisebb erőfeszítéssel logikailag ellentmondásmentes hipotéziseket képesek találni.</p></div><div class="section" title="A pillanatnyilag legjobb hipotézis keresése"><div class="titlepage"><div><div><h2 class="title"><a id="id729816"/>A pillanatnyilag legjobb hipotézis keresése</h2></div></div></div><p class="Tartalom3">A <span class="strong"><strong>pillanatnyilag legjobb hipotézis</strong></span> (<span class="strong"><strong>current-best-hypothesis</strong></span>) keresési eljárás alapgondolata az, hogy egyetlen hipotézist vegyünk figyelembe, és ha új példa érkezik, akkor ennek figyelembevételével alakítsuk át a hipotézist annak érdekében, hogy az ellentmondás-mentességet fenntartsuk. Az algoritmus alapját John Stuart Mill írta le (Mill, 1843), de könnyen lehet, hogy már korábban megalkották.</p><p>Tegyük fel, hogy van valamilyen hipotézisünk, például <span class="emphasis"><em>H<sub>r</sub></em></span>, amit már meglehetősen megkedveltünk. Amíg egy új példával sincs ellentmondásban, semmit sem kell tennünk. Aztán egyszer csak egy hamis negatív példa (<span class="emphasis"><em>X</em></span><sub>13</sub>) érkezik. Mit csináljunk? A 19.1. (a) ábra sematikusan úgy mutatja be <span class="emphasis"><em>H<sub>r</sub></em></span>-t, mint egy területet, a négyszögön belül minden <span class="emphasis"><em>H<sub>r</sub></em></span> kiterjedésébe tartozik. Az eddig látott példákat „+” vagy „–” jelöli, és látható, hogy <span class="emphasis"><em>H<sub>r</sub></em></span> jól sorolja be az összes példát, mint <span class="emphasis"><em>VárjunkE </em></span>pozitív vagy negatív példáit. A 19.1. (b) ábrán egy új – hamis negatív – példa jelenik meg (bekarikázva): a hipotézis azt állítja, hogy negatív, pedig valójában pozitív példa. A hipotézis kiterjedését növelni kell ahhoz, hogy tartalmazza ezt a példát is. Ezt a lépést <span class="strong"><strong>általánosítás</strong></span>nak (<span class="strong"><strong>generalization</strong></span>) nevezzük: egy lehetséges általánosítás a 19.1. (c) ábrán látható. Ezután a 19.1. (d) ábrán egy hamis pozitív példát látunk: a hipotézis azt állítja, hogy pozitív, pedig valójában negatív. A hipotézis kiterjedését csökkenteni kell ahhoz, hogy kizárjuk ezt a példát. Ezt <span class="strong"><strong>szűkítés</strong></span>nek (<span class="strong"><strong>specialization</strong></span>) nevezzük; a 19.1. (e) ábrán a hipotézis egy lehetséges szűkítését látjuk.</p><div class="figure"><a id="id729888"/><p class="title"><strong>19.1. ábra - (a) Egy konzisztens hipotézis. (b) Egy hamis negatív példa. (c) A hipotézist általánosítottuk. (d) Egy hamis pozitív példa. (e) A hipotézist szűkítettük.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-01.png" alt="(a) Egy konzisztens hipotézis. (b) Egy hamis negatív példa. (c) A hipotézist általánosítottuk. (d) Egy hamis pozitív példa. (e) A hipotézist szűkítettük."/></div></div></div><p class="Tartalom3">Most már specifikálni tudjuk a 19.2. ábrán látható <code class="code">PILLANATNYILAG-LEGJOBB-TANULÁS</code> algoritmusát. Vegyük észre, hogy valahányszor általánosítjuk vagy szűkítjük a hipotézist, ellenőriznünk kell az összes többi példára, hiszen nincs garancia arra, hogy a kiterjedés önkényes növelése/csökkentése elkerüli bármelyik másik negatív/pozitív példa befoglalását/kirekesztését.</p><div class="figure"><a id="id729906"/><p class="title"><strong>19.2. ábra - A pillanatnyilag-legjobb-hipotézis tanuló algoritmus. Konzisztens hipotézist keres és viszszalép, ha nem található konzisztens szűkítés/általánosítás.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-02.png" alt="A pillanatnyilag-legjobb-hipotézis tanuló algoritmus. Konzisztens hipotézist keres és viszszalép, ha nem található konzisztens szűkítés/általánosítás."/></div></div></div><p>Az általánosítást és a szűkítést úgy definiáltuk, mint olyan műveleteket, amelyek a hipotézis <span class="emphasis"><em>kiterjedését</em></span> változtatják meg. Most pontosan meg kell határoznunk azt, hogy ezek a műveletek hogyan implementálhatók olyan szintaktikus műveletekként, amelyek a hipotézishez rendelt definíciójelöltet úgy változtatják meg, hogy azt egy program végre tudja hajtani. Ehhez először is vegyük észre, hogy az általánosítás és a szűkítés egyben hipotézisek közötti<span class="emphasis"><em> logikai</em></span> relációk. Ha a <span class="emphasis"><em>C</em></span><sub>1</sub> definíciónak megfelelő <span class="emphasis"><em>H</em></span><sub>1</sub> hipotézis a <span class="emphasis"><em>C</em></span><sub>2</sub> definíciónak megfelelő <span class="emphasis"><em>H</em></span><sub>2</sub> hipotézis általánosítása, akkor fenn kell állnia annak, hogy:</p><p><code class="code">∀<em><span class="remark">x</span></em>  <em><span class="remark">C</span></em><sub>2</sub>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">C</span></em><sub>1</sub>(<em><span class="remark">x</span></em>)</code></p><p>Tehát ahhoz, hogy a <span class="emphasis"><em>H</em></span><sub>2</sub> hipotézis általánosítását létrehozzuk, egyszerűen egy olyan <span class="emphasis"><em>C</em></span><sub>1</sub> definíciót kell találnunk, amelyik logikailag következik <span class="emphasis"><em>C</em></span><sub>2</sub>-ből. Ezt könnyen megtehetjük. Ha például <span class="emphasis"><em>C</em></span><sub>2</sub>(<span class="emphasis"><em>x</em></span>) <span class="emphasis"><em>Alternatíva</em></span>(<span class="emphasis"><em>x</em></span>) ∧ <span class="emphasis"><em>Vendégek</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Néhány</em></span>), akkor egy általánosítási lehetőség a <span class="emphasis"><em>C</em></span><sub>1</sub>(<span class="emphasis"><em>x</em></span>) ≡ <span class="emphasis"><em>Vendégek</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Néhány</em></span>). Ezt <span class="strong"><strong>feltételek törlésé</strong></span>nek (<span class="strong"><strong>dropping condit</strong></span><span class="strong"><strong>ions</strong></span>) nevezzük. Felfoghatjuk úgy, hogy egy gyengébb definíció jön létre, így a pozitív példák nagyobb halmazát teszi lehetővé. Számos egyéb általánosítási eljárás is létezik, azon nyelvtől függően, amelyen a műveleteket végezzük. Hasonlóképpen, egy hipotézist szűkíteni tudunk, ha további feltételeket adunk a hozzá tartozó definíciójelölthöz, illetve ha eltávolítunk tagokat egy diszjunktív definícióból. Lássuk, hogyan működik ez az éttermi feladatban, 18.3. ábra adatait használva:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Az első példa – <span class="emphasis"><em>X</em></span><sub>1</sub> – pozitív. <span class="emphasis"><em>Alternatíva</em></span>(<span class="emphasis"><em>X</em></span><sub>1</sub>) igaz, tehát vegyük fel a következő kiinduló hipotézist:</p></li></ul></div><p><code class="code"><em><span class="remark">	H</span></em><sub>1</sub>: ∀<em><span class="remark">x</span></em> <em><span class="remark">VárjunkE</span></em>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">Alternatíva</span></em>(<em><span class="remark">x</span></em>)</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A második példa – <span class="emphasis"><em>X</em></span><sub>2</sub> – negatív. <span class="emphasis"><em>H</em></span><sub>1</sub> alapján pozitív lenne, így hamis pozitív. Ezért szűkítenünk kell <span class="emphasis"><em>H</em></span><sub>1</sub>-et. Ezt megtehetjük például úgy, hogy egy olyan további feltételt adunk hozzá, amely feltétel kizárja <span class="emphasis"><em>X</em></span><sub>2</sub>-t. Egy lehetőség:</p></li></ul></div><p><code class="code"><em><span class="remark">	H</span></em><sub>2</sub>: ∀<em><span class="remark">x</span></em> <em><span class="remark">VárjunkE</span></em>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">Alternatíva</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Néhány</span></em>)</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A harmadik példa – <span class="emphasis"><em>X</em></span><sub>3</sub> – pozitív. <span class="emphasis"><em>H</em></span><sub>2</sub> alapján negatív lenne, így hamis negatív. Tehát általánosítanunk kell <span class="emphasis"><em>H</em></span><sub>2</sub>-t. Ezt elérhetjük, ha töröljük <span class="emphasis"><em>Alternatíva</em></span> feltételt, amely a következő hipotézisre vezet:</p></li></ul></div><p><code class="code"><em><span class="remark">	H</span></em><sub>3</sub>: ∀<em><span class="remark">x</span></em> <em><span class="remark">VárjunkE</span></em>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Néhány</span></em>)</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A negyedik példa – <span class="emphasis"><em>X</em></span><sub>4</sub> – pozitív. <span class="emphasis"><em>H</em></span><sub>3</sub> alapján negatív lenne, így hamis negatív. Így általánosítanunk kell <span class="emphasis"><em>H</em></span><sub>3</sub>-at. Nem törölhetjük <span class="emphasis"><em>Vendégek</em></span> feltételt, mert ez egy mindent tartalmazó hipotézishez vezetne, ami ellentmondásban van <span class="emphasis"><em>X</em></span><sub>2</sub>-vel. Egyik lehetőség a következő diszjunkció bevezetése:</p></li></ul></div><p><code class="code"><em><span class="remark">	H</span></em><sub>4</sub>: ∀<em><span class="remark">x</span></em> <em><span class="remark">VárjunkE</span></em>(<em><span class="remark">x</span></em>) ⇔ <em><span class="remark">Vendégek</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Néhány</span></em>)</code></p><p><code class="code">		∨ (<em><span class="remark">Vendégek</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Tele</span></em>) ∧ <em><span class="remark">Péntek</span></em>/<em><span class="remark">Szombat</span></em>(<em><span class="remark">x</span></em>))</code></p><p>A hipotézis ezek után már kezd ésszerűnek tűnni. Nyilvánvaló, hogy más lehetőségek is vannak, amelyek konzisztensek az első négy példával, kettő ezek közül:</p><p>	<span class="inlinemediaobject"><img src="math/mi-19-0001.gif" alt="A pillanatnyilag-legjobb-hipotézis tanuló algoritmus. Konzisztens hipotézist keres és viszszalép, ha nem található konzisztens szűkítés/általánosítás."/></span></p><p>A <code class="code">PILLANATNYILAG-LEGJOBB-TANULÁS</code> algoritmusát nem determinisztikusan írjuk le, mivel bármely ponton számos olyan szűkítési vagy általánosítási lehetőség lehet, melyek bármelyikét alkalmazhatjuk. A már meghozott döntések nem szükségszerűen vezetnek a legegyszerűbb hipotézishez, sőt olyan megoldhatatlan szituációhoz is vezethetnek, amelyben nincs a hipotézisnek olyan egyszerű módosítása, amely minden adattal konzisztens hipotézist állít elő. Ilyen esetekben a programnak egy előző választási ponthoz kell visszalépnie.</p><p>A <code class="code">PILLANATNYILAG-LEGJOBB-TANULÁS</code> algoritmusát – és különböző változatait – számos gépi tanulást felhasználó rendszerben alkalmazták, először Patrick Winston (Winston, 1970) „ív-tanuló” programjában. Azonban ha a tér nagy, és nagyszámú példával dolgozunk, akkor bizonyos nehézségek merülnek fel:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Az összes előző példa újraellenőrzése minden egyes módosításnál nagyon munkaigényes.</p></li><li class="listitem"><p>Nehéz jó keresési heurisztikát találni, és a visszalépések örökké tarthatnak. Mint a 18. fejezetben már láttuk, a hipotézistér kétszeresen exponenciálisan nagy tér lehet.</p></li></ol></div></div><div class="section" title="Legkisebb megkötés elvű keresés"><div class="titlepage"><div><div><h2 class="title"><a id="id730361"/>Legkisebb megkötés elvű keresés</h2></div></div></div><p>A visszalépésre azért van szükség, mert a „pillanatnyilag-legjobb-hipotézis” eljárásban <span class="emphasis"><em>választani</em></span> kell egy legjobb becslést, egy partikuláris hipotézist, akkor is, ha még nincs elég adatunk ahhoz, hogy biztosak legyünk a választásunk helyességében. Ehelyett azt tehetjük, hogy az összes olyan és csak olyan hipotézist megtartjuk, amelyek az eddigi adatainkkal konzisztensek. Ezek után mindegyik új eset vagy nincs hatással, vagy kizár néhányat a hipotéziseink közül. Emlékezzünk arra, hogy a hipotézistér egy diszjunktív állításnak tekinthető:</p><p><code class="code"><em><span class="remark">H</span></em><sub>1 </sub>∨ <em><span class="remark">H</span></em><sub>2 </sub>∨ <em><span class="remark">H</span></em><sub>3 </sub>∨ … ∨ <em><span class="remark">H</span></em><sub><em><span class="remark">n</span></em> </sub></code></p><p>Ahogy egyre több hipotézis bizonyul a példákkal inkonzisztensnek, ez a diszjunktív állítás zsugorodik, csak azokat a hipotéziseket tartva meg, amelyeket nem szűrtünk ki. Feltéve, hogy az eredeti hipotézistér tartalmazza a helyes választ, a redukált diszjunktív állításnak is szükségszerűen tartalmaznia kell azt, hiszen csak inkorrekt hipotéziseket szűrtünk ki. A megmaradt hipotézisek halmazát nevezzük <span class="strong"><strong>verziótér</strong></span>nek (<span class="strong"><strong>version space</strong></span>). Az ilyen elven működő tanulási algoritmust (amelyet a 19.3. ábrán vázoltunk fel) verziótér tanulási algoritmusnak (más néven <span class="strong"><strong>jelölteltávolítás</strong></span>i –<span class="strong"><strong> candidate elimination</strong></span> – algoritmusnak) nevezzük.</p><div class="figure"><a id="id730421"/><p class="title"><strong>19.3. ábra - Verziótér tanuló algoritmus. <span class="emphasis"><em>V</em></span>-nek olyan részhalmazát tanulja meg, amelynek elemei a <span class="emphasis"><em>példák</em></span>kal konzisztensek.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-03.png" alt="Verziótér tanuló algoritmus. V-nek olyan részhalmazát tanulja meg, amelynek elemei a példákkal konzisztensek."/></div></div></div><p class="Tartalom3">Fontos tulajdonsága ennek a megközelítésnek, hogy <span class="emphasis"><em>inkrementális:</em></span> soha nem kell visszalépnünk és újravizsgálnunk a régi példákat. Az összes megmaradt hipotézis garantáltan konzisztens az összes példával. Másrészt <span class="strong"><strong>legkisebb megkötés elv</strong></span>ű (<span class="strong"><strong>least commitment</strong></span>) algoritmusnak is nevezhetjük, ugyanis nem tesz önkényes választásokat (vö. a 11. fejezetben található részben rendezett tervkészítő algoritmussal). Van viszont egy nyilvánvaló probléma. Már leszögeztük, hogy a hipotézistér óriási, hogyan tudjuk akkor leírni ezt az óriási diszjunktív állítást?</p><div class="figure"><a id="id730455"/><p class="title"><strong>19.4. ábra - A verziótér a példákkal konzisztens összes hipotézist tartalmazza</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-04.png" alt="A verziótér a példákkal konzisztens összes hipotézist tartalmazza"/></div></div></div><p>A következő egyszerű analógia sokat segít a megértésben. Hogyan ábrázoljuk az öszszes 1 és 2 közé eső valós számot? Végül is végtelen sok ilyen van! A megoldás az intervallumábrázolás, amelyik csak a halmaz határait specifikálja: [1, 2]. Ez azért működik, mert a valós számok felett értelmezett egy <span class="emphasis"><em>rendezés</em></span>.</p><p>A hipotézistér felett is rendelkezünk rendezéssel, nevezetesen az általánosítás/szűkítés alapján. Ez egy részleges rendezés, ami azt jelenti, hogy a határ nem egy pont, hanem a hipotézisek egy halmaza: a <span class="strong"><strong>határhalmaz</strong></span> (<span class="strong"><strong>boundary set</strong></span>). A nagyszerű a dologban az, hogy a teljes verziótér reprezentálható csupán két határhalmaz: egy legáltalánosabb határhalmaz (a <span class="strong"><strong>G halmaz</strong></span>) és egy legszűkebb határhalmaz (az <span class="strong"><strong>S halmaz</strong></span>) segítségével. <span class="emphasis"><em>E kettő közé eső bármely hipotézis garantáltan konzisztens az összes példával</em></span>. Mielőtt ezt bizonyítjuk, röviden foglaljuk össze az eddigieket:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A jelenlegi verziótér azon hipotézisek halmaza, amelyek az összes eddigi példával konzisztensek. Ezt az S halmaz és a G halmaz segítségével ábrázoljuk, mindkettő a hipotézisek valamilyen halmaza.</p></li><li class="listitem"><p>Az S halmaz összes eleme konzisztens az összes eddigi megfigyeléssel, és nincs ennél szűkebb konzisztens hipotézis.</p></li><li class="listitem"><p>A G halmaz összes eleme konzisztens az összes eddigi megfigyeléssel, és nincs ennél általánosabb konzisztens hipotézis.</p></li></ul></div><p>Azt kívánjuk meg, hogy a kezdeti tér (mielőtt bármelyik példát megvizsgáltuk volna), az összes elképzelhető hipotézist tartalmazza. Ezt úgy biztosítjuk, hogy a G halmazt egyszerűen az <span class="emphasis"><em>Igaz</em></span> értékre állítjuk (az a hipotézis, amely mindent tartalmaz), az S halmazt pedig egyszerűen a <span class="emphasis"><em>Hamis</em></span> értékre állítjuk (az a hipotézis, amelynek kiterjedése üres).</p><p>A 19.4. ábra a verziótér határhalmazokkal való ábrázolásának általános struktúráját mutatja. Ahhoz, hogy megmutassuk, hogy ez az ábrázolás elégséges, két tulajdonságra van szükségünk:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Mindegyik konzisztens hipotézis (amelyik nem valamelyik határhalmaz eleme) szűkebb, mint a G halmaz valamelyik eleme, és általánosabb, mint az S halmaz valamelyik eleme. (Azaz nincsenek kívül „kóbor” elemek.) Ez közvetlenül következik az <span class="emphasis"><em>S</em></span> és <span class="emphasis"><em>G</em></span> definíciójából. Ha lenne egy kóbor <span class="emphasis"><em>h</em></span>, akkor az vagy nem lehetne szűkebb <span class="emphasis"><em>G</em></span> valamely eleménél, tehát <span class="emphasis"><em>G</em></span>-hez kellene tartoznia, vagy nem lehetne általánosabb <span class="emphasis"><em>S</em></span> valamely eleménél, ebben az esetben viszont <span class="emphasis"><em>S</em></span>-hez tartozna.</p></li><li class="listitem"><p>Mindegyik hipotézis, amelyik szűkebb a G halmaz valamely eleménél, és általánosabb az S halmaz valamely eleménél, konzisztens hipotézis (azaz a határok között nincsenek „lyukak”). Bármely – az <span class="emphasis"><em>S</em></span> és <span class="emphasis"><em>G</em></span> közé eső – <span class="emphasis"><em>h</em></span>-nak az összes olyan negatív példát vissza kell utasítania, amelyet <span class="emphasis"><em>G</em></span> minden egyes tagja visszautasít (mivel szűkebb), ugyanakkor el kell fogadnia az összes pozitív példát, amelyet az <span class="emphasis"><em>S</em></span> akármelyik tagja elfogad (mivel általánosabb). Így <span class="emphasis"><em>h</em></span> az összes példát jól kezeli, tehát nem lehet inkonzisztens. A 19.5. ábra mutatja be a helyzetet: nincs ismert példa, amely <span class="emphasis"><em>S</em></span>-en kívül, de <span class="emphasis"><em>G</em></span>-n belül helyezkedik el, így a kettő közt elhelyezkedő összes hipotézisnek konzisztensnek kell lennie.</p></li></ol></div><div class="figure"><a id="id730588"/><p class="title"><strong>19.5. ábra - A <span class="emphasis"><em>G</em></span> és az <span class="emphasis"><em>S</em></span> elemeinek kiterjesztései. A kettő között nem található ismert példa.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-05.png" alt="A G és az S elemeinek kiterjesztései. A kettő között nem található ismert példa."/></div></div></div><p class="Tartalom3">Bemutattuk tehát, hogy <span class="emphasis"><em>ha</em></span> <span class="emphasis"><em>S</em></span>-t és <span class="emphasis"><em>G</em></span>-t definíciójuknak megfelelően kezeljük, akkor a verziótér kielégítő leírását adják. Az egyetlen hátralévő probléma, hogy hogyan <span class="emphasis"><em>módosítsuk</em></span> <span class="emphasis"><em>S</em></span>-t és <span class="emphasis"><em>G</em></span>-t egy új példa esetén (a <code class="code">VERZIÓ-TÉR-MÓDOSÍTÁS</code> függvény feladata). Elsőre ez meglehetősen bonyolultnak tűnik, de a definíciók és a 19.4. ábra alapján nem túl nehéz az algoritmus előállítása.</p><p>Az S és G halmazok <span class="emphasis"><em>S<sub>i</sub> </em></span>és <span class="emphasis"><em>G<sub>i</sub></em></span> elemeivel kell foglalkoznunk. Az új példa bármelyik esetén lehet hamis pozitív vagy hamis negatív.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="emphasis"><em>S<sub>i</sub></em></span>-re hamis pozitív. Azt jelenti, hogy <span class="emphasis"><em>S<sub>i</sub></em></span> túl általános, de mivel <span class="emphasis"><em>S<sub>i</sub></em></span>-nek (a definíciója értelmében) nincs konzisztens szűkítése, így <span class="emphasis"><em>S<sub>i</sub></em></span>-t eltávolítjuk az S halmazból.</p></li><li class="listitem"><p><span class="emphasis"><em>S<sub>i</sub></em></span>-re hamis negatív. Azt jelenti, hogy <span class="emphasis"><em>S<sub>i</sub></em></span> túl szűk, így <span class="emphasis"><em>S<sub>i</sub></em></span>-t az összes közvetlen általánosításával helyettesítjük, feltéve, hogy ezek szűkebbek, mint <span class="emphasis"><em>G</em></span> egyes elemei.</p></li><li class="listitem"><p><span class="emphasis"><em>G<sub>i</sub></em></span>-re hamis pozitív. Azt jelenti, hogy <span class="emphasis"><em>G<sub>i</sub></em></span> túl általános, így az összes közvetlen szűkítésével helyettesítjük, feltéve, hogy ezek általánosabbak, mint <span class="emphasis"><em>S</em></span> egyes elemei.</p></li><li class="listitem"><p><span class="emphasis"><em>G<sub>i</sub></em></span>-re hamis negatív. Azt jelenti, hogy <span class="emphasis"><em>G<sub>i</sub></em></span> túl szűk, de mivel nincs konzisztens általánosítása (definíciója értelmében), így <span class="emphasis"><em>G<sub>i</sub></em></span>-t eltávolítjuk a G halmazból.</p></li></ol></div><p>Ezeket a műveleteket minden új példára elvégezzük addig, amíg az alábbi három eset valamelyike fel nem lép:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Pontosan egy hipotézis marad a verziótérben, ebben az esetben ezt adjuk vissza mint az egyetlen hipotézist.</p></li><li class="listitem"><p>A verziótér <span class="emphasis"><em>összeomlik</em></span> – vagy S, vagy G üressé válik, azt jelezve, hogy nincs a tanító halmazra nézve konzisztens hipotézis. Ez megegyezik az egyszerű döntési fa algoritmus sikertelen kimenetelével.</p></li><li class="listitem"><p>Kifogyunk a példákból, miközben számos hipotézis maradt a verziótérben. Ez azt jelenti, hogy a verziótér a hipotézisek diszjunkcióját reprezentálja. Ha egy új példa esetén a diszjunkció összes tagjában azonos eredményt kapunk, akkor ezt adhatjuk vissza mint a példa besorolását. Ha az eredmények nem egyeznek meg, akkor egyik lehetőségként alkalmazhatjuk a többségi szavazást.</p></li></ol></div><p>Gyakorlás céljára hagyjuk a <code class="code">VERZIÓ-TÉR-TANULÁS</code> algoritmusnak az éttermi adatokra való alkalmazását.</p><p>A verziótér megközelítésnek két alapvető hátránya van:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ha a problématerület adatai zajt tartalmaznak, vagy ha az attribútumok a pontos besoroláshoz nem elégségesek, akkor a verziótér mindig összeomlik.</p></li><li class="listitem"><p>Ha korlátlan méretű diszjunkciót megengedünk a hipotézistérben, akkor az S halmaz mindig tartalmazni fog egy egyedi legszűkebb hipotézist, nevezetesen az összes eddig látott pozitív példa diszjunkcióját. Hasonlóképpen a G halmaz tartalmazni fogja a negatív példák diszjunkciójának negáltját.</p></li><li class="listitem"><p>Egyes hipotézistereknél az S- és a G-beli elemek száma az attribútumok számában exponenciálisan növekedhet annak ellenére, hogy az ilyen hipotézisterekhez ismertek hatékony tanuló algoritmusok.</p></li></ul></div><p>A zaj problémájára napjainkig nem ismert teljes, sikeres megoldás. A diszjunktív kapcsolatok problémája kezelhető oly módon, hogy csak korlátozott méretű diszjunktív formákat engedünk meg, vagy az általánosabb predikátumokra egy <span class="strong"><strong>általánosítási hie</strong></span><span class="strong"><strong>rarchiá</strong></span>t (<span class="strong"><strong>generalization hierarchy</strong></span>) vezetünk be. Például a <span class="emphasis"><em>BecsültVárakozás</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>30-60</em></span>) ∨  <span class="emphasis"><em>BecsültVárakozás</em></span>(<span class="emphasis"><em>x</em></span>, &gt;60) helyett használhatjuk a <span class="emphasis"><em>HosszúVárakozás</em></span>(<span class="emphasis"><em>x</em></span>) literált. Az általánosítási és a szűkítési műveletek egyszerűen kiterjeszthetők ennek kezelésére.</p><p>A verziótér algoritmus tiszta változatát először a Meta-<code class="code">DENDRAL</code> rendszerben alkalmazták. Ezt a rendszert olyan szabályok megtanulására tervezték, amelyek azt írják le, hogy egy tömegspektrométerben a molekulák hogyan esnek szét darabokra (Buchanan és Mitchell, 1978). A Meta-<code class="code">DENDRAL</code> képes volt olyan szabályok generálására, amelyek elég újak voltak egy analitikus kémiával foglalkozó újságban való publikálhatósághoz. Ezek voltak az első – egy számítógépes program által felfedezett – valós tudományos eredmények. Az algoritmust az elegáns <code class="code">LEX</code> rendszerben (Mitchell és társai, 1983) szintén használták, ez a rendszer saját sikereinek és kudarcainak tanulmányozása alapján szimbolikus integrálási problémák megoldásának megtanulására volt képes. Bár a verziótér-módszerek valószínűleg a legtöbb valós probléma tanulása esetén – főleg a zaj miatt – nem praktikusak, jó betekintést adnak a hipotézistér logikai szerkezetébe.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id729736" href="#id729736" class="para">189</a>] </sup> „Hamis pozitív” és „hamis negatív” kifejezéseket először a gyógyításban használták arra, hogy a téves laboratóriumi eredményeket jellemezzék. Egy eredmény akkor hamis pozitív, ha azt jelzi, hogy a páciens az adott betegségben szenved, míg valójában nem ez a helyzet.</p></div></div></div></body></html>
