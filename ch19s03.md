<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Magyarázatalapú tanulás"><div class="titlepage"><div><div><h1 class="title"><a id="id732889"/>Magyarázatalapú tanulás</h1></div></div></div><p>Ahogy a fejezet bevezetőjében elmagyaráztuk, a magyarázatalapú tanulás olyan módszer, ami megfigyelésekből általános szabályokat nyer ki. Tekintsük például az algebrai kifejezések egyszerűsítését és differenciálását (lásd 9.15. feladat). <span class="emphasis"><em>X</em></span><sup>2</sup>-et <span class="emphasis"><em>X</em></span> szerint differenciálva 2<span class="emphasis"><em>X</em></span>-et kapunk (vegyük észre, hogy az aritmetikai ismeretlent nagy <span class="emphasis"><em>X</em></span> betűvel jelöljük az <span class="emphasis"><em>x</em></span> logikai változótól megkülönböztetve). Egy logikai következtető rendszerben a célt így a <code class="code">KÉRDEZ</code>(<span class="emphasis"><em>Derivált</em></span>(<span class="emphasis"><em>X</em></span><sup>2</sup>, <span class="emphasis"><em>X</em></span>) = <span class="emphasis"><em>d</em></span>, <span class="emphasis"><em>TB</em></span>) kifejezéssel fejezhetjük ki, ahol a megoldás a <span class="emphasis"><em>d </em></span>= 2<span class="emphasis"><em>X</em></span>.</p><p>Bárki, aki a differenciálszámítást ismeri, a megoldást „ránézésre” tudja. Az ilyen problémákkal első alkalommal találkozó hallgatónak vagy netán a tapasztalatot nélkülöző programnak sokkal nehezebb lesz a dolga. A differenciálás közismert szabályai segítségével a kifejezést előbb-utóbb az 1 × (2 × (<span class="emphasis"><em>X</em></span><sup>(2–1)</sup>)) alakra lehet hozni, és ez előbb-utóbb elvezet minket a 2<span class="emphasis"><em>X</em></span>-hez. A szerzők logikai programjának ez 136 bizonyítási lépésbe került, amiből 99 lépés a bizonyítás zsákutca elágazásaira esett. Ezt tapasztalva azt szeretnénk, ha a program ugyanennek a problémának a megoldását a következő alkalommal lényegesen gyorsabban adná meg.</p><p>A <span class="strong"><strong>memoizálás</strong></span> (<span class="strong"><strong>memoization</strong></span>) módszerét a számítógép-tudományban régóta alkalmazzák, miszerint a számítások meggyorsíthatók az eredmények eltárolása révén. A memofüggvény alapgondolata, hogy bemenet/kimenet párokat gyűjtünk ki egy külön adatbázisba. Meghíváskor a függvény először megvizsgálja az adatbázist, hátha a probléma teljes újbóli megoldását így meg tudja kerülni. A magyarázatalapú tanulás ezt az ötletet továbbfejleszti úgy, hogy egy <span class="emphasis"><em>általános</em></span> szabályt fogalmaz meg, amely az esetek egész osztályát képes lefedni. A differenciálás esetében a memoizálás emlékezne ugyan arra, hogy az <span class="emphasis"><em>X</em></span><sup>2</sup>-nek <span class="emphasis"><em>X</em></span> szerinti deriváltja 2<span class="emphasis"><em>X</em></span>, a <span class="emphasis"><em>Z</em></span><sup>2</sup> <span class="emphasis"><em>Z</em></span> szerinti deriváltjának kiszámítását azonban teljes egészében az ágensre hagyná. Célszerű lenne, ha egy olyan általános szabályt<sup>[<a id="id732997" href="#ftn.id732997" class="footnote">190</a>]</sup> tudnánk megfogalmazni, amely minden lehetséges <span class="emphasis"><em>u</em></span> aritmetikai ismeretlen esetén megadná, hogy az <span class="emphasis"><em>u</em></span><sup>2</sup>-nek <span class="emphasis"><em>u</em></span> szerint deriváltja 2<span class="emphasis"><em>u</em></span>. A logikában ezt az alábbi szabállyal fejezhetjük ki:</p><p><code class="code"><em><span class="remark">AritmetikaiIsmeretlen</span></em>(<em><span class="remark">u</span></em>) ⇒ <em><span class="remark">Derivált</span></em>(<em><span class="remark">u</span></em><sup>2</sup>, <em><span class="remark">u</span></em>) = 2<em><span class="remark">u</span></em></code></p><p>Ha a tudásbázis rendelkezik egy ilyen szabállyal, akkor minden új eset, ami a szabály egy példánya, azonnal megoldható.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p class="Tartalom3">Természetesen ez csupán egy triviális példa egy igen általános jelenségre. Ha egyszer megértettünk valamit, azt általánosítva más körülmények között is felhasználhatjuk. Egy „nyilvánvaló” megoldási lépést kapunk, amely építőkockaként felhasználható bonyolultabb problémák megoldásában. Alfred North Whitehead, aki Bertrand Russell-lel együtt a <span class="emphasis"><em>Principia Mathematica</em></span> társszerzője – talán a Zog felfedezése jellegű események megértéséhez saját magára alkalmazva a MAT elvét – azt írta, hogy <span class="emphasis"><em>„A civilizáció azáltal halad előre, hogy szaporítja azoknak a fontos cselekvéseknek a számát, amelyeket gondolkodás nélkül véghezvihetünk”</em></span> (Whitehead, 1911). Ha ön, kedves olvasó, a deriválási példa lényegét megértette, akkor az agya már buzgón azon dolgozik, hogy megkísérelje a magyarázatalapú tanulás általános elvét kinyerni ebből a példából. Figyelje meg, hogy hacsak nem lényegesen okosabb a szerzőknél, a magyarázatalapú példa bemutatása előtt <span class="emphasis"><em>még nem</em></span> ismerte fel a MAT-ot. A Zogot figyelő ősemberekhez hasonlóan önnek (és nekünk is) egy példát kellett látnunk, mielőtt az alapelvet meg tudtuk fogalmazni. Ez azért van így, mert <span class="emphasis"><em>megmagyarázni,</em></span> hogy <span class="emphasis"><em>miért</em></span> jó egy ötlet, sokkal könnyebb, mint magát az ötletet megfogalmazni.</p></div><div class="section" title="Általános szabályok kinyerése példákból"><div class="titlepage"><div><div><h2 class="title"><a id="id733076"/>Általános szabályok kinyerése példákból</h2></div></div></div><p>A MAT alapötlete az, hogy először az előzetes tudásra alapozva megkonstruáljuk a megfigyelés magyarázatát, majd meghatározzuk annak az esetosztálynak a definícióját, amelyre a megkonstruált magyarázat alkalmazható. A definíció alapul szolgál az osztály eseteit lefedő szabály számára. A „magyarázat” lehet egy logikai bizonyítás, de általánosságban lehet akármilyen következtetési vagy problémamegoldó folyamat, feltéve, hogy a lépései jól definiáltak. Kulcsfontosságú azoknak a szükséges feltételeknek az azonosítása, amelyek révén az egyes lépések más esetre is alkalmazhatók lesznek.</p><p>Következtető rendszerként a 9. fejezetben leírt egyszerű, hátrahaladó tételbizonyító rendszert fogjuk használni. A <span class="emphasis"><em>Derivált</em></span>(<span class="emphasis"><em>X</em></span><sup>2</sup>, <span class="emphasis"><em>X</em></span>) = 2<span class="emphasis"><em>X</em></span> bizonyítási fája túlságosan nagy ahhoz, hogy példaként szerepeljen, ezért az általánosítás módszertanát egy valamivel egyszerűbb példával fogjuk illusztrálni. Tegyük fel, hogy az 1 × (0 + <span class="emphasis"><em>X</em></span>) kifejezést akarjuk egyszerűsíteni. A tudásbázis az alábbi szabályokat tartalmazza:</p><p><code class="code"><em><span class="remark">Átírás</span></em>(<em><span class="remark">u</span></em>, <em><span class="remark">v</span></em>) ∧ <em><span class="remark">Egyszerűsítés</span></em>(<em><span class="remark">v</span></em>, <em><span class="remark">w</span></em>) ⇒ <em><span class="remark">Egyszerűsítés</span></em>(<em><span class="remark">u</span></em>, <em><span class="remark">w</span></em>)</code></p><p><code class="code"><em><span class="remark">Primitív</span></em>(<em><span class="remark">u</span></em>) ⇒ <em><span class="remark">Egyszerűsítés</span></em>(<em><span class="remark">u</span></em>, <em><span class="remark">u</span></em>)</code></p><p><code class="code"><em><span class="remark">AritmetikaiIsmeretlen</span></em>(<em><span class="remark">u</span></em>) ⇒ <em><span class="remark">Primitív</span></em>(<em><span class="remark">u</span></em>)</code></p><p><code class="code"><em><span class="remark">Szám</span></em>(<em><span class="remark">u</span></em>) ⇒ <em><span class="remark">Primitív</span></em>(<em><span class="remark">u</span></em>)</code></p><p><code class="code"><em><span class="remark">Átírás</span></em>(1 × <em><span class="remark">u</span></em>, <em><span class="remark">u</span></em>)</code></p><p><code class="code"><em><span class="remark">Átírás</span></em>(0 + <em><span class="remark">u</span></em>, <em><span class="remark">u</span></em>)</code></p><p><code class="code">…</code></p><p>Annak bizonyítása, hogy a válasz <span class="emphasis"><em>X</em></span>, a 19.7. ábra felső részében látható. A MAT-módszer egyidőben két bizonyítási fát konstruál. A második bizonyítási fa a <span class="emphasis"><em>szabad változókkal rendelkező célt</em></span> használja, ahol az eredeti cél konstansait változókkal helyettesítettük. Ahogy az eredeti bizonyítás halad előre, úgy halad a szabad változós bizonyítás is, <span class="emphasis"><em>pontosan ugyanazokat a szabályokat alkalmazva</em></span>. Lehetséges, hogy néhány változót közben le kell kötni. Ahhoz, hogy az <span class="emphasis"><em>Átírás</em></span>(1 × <span class="emphasis"><em>u</em></span>, <span class="emphasis"><em>u</em></span>) szabályt használhassuk, az <span class="emphasis"><em>Átírás</em></span>(<span class="emphasis"><em>x</em></span> × (<span class="emphasis"><em>y</em></span> + <span class="emphasis"><em>z</em></span>), <span class="emphasis"><em>v</em></span>) részcél <span class="emphasis"><em>x</em></span> változóját 1-re kell lekötni. Hasonlóképpen az <span class="emphasis"><em>Átírás</em></span>(<span class="emphasis"><em>y</em></span> + <span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>v</em></span>') részcél <span class="emphasis"><em>y</em></span> változóját 0-ra kell lekötni, ha az <span class="emphasis"><em>Átírás</em></span>(0 + <span class="emphasis"><em>u</em></span>, <span class="emphasis"><em>u</em></span>) szabályt szeretnénk alkalmazni. Az általánosított bizonyítási fa birtokában a levelekből (a szükséges kötéseket figyelembe véve) a célpredikátum általános szabályát képezzük:</p><p><code class="code"><em><span class="remark">Átírás</span></em>(1 × (0 + <em><span class="remark">z</span></em>),0 + <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Átírás</span></em>(0 + <em><span class="remark">z</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">AritmetikaiIsmeretlen</span></em>(<em><span class="remark">z</span></em>) </code></p><p><code class="code">	⇒ <em><span class="remark">Egyszerűsítés</span></em>(1 × (0 + <em><span class="remark">z</span></em>), <em><span class="remark">z</span></em>)</code></p><p>Vegyük észre, hogy a bal oldal első két feltétele igaz <span class="emphasis"><em>függetlenül attól, hogy z-nek mi az értéke</em></span>. Így ezeket kihagyhatjuk a szabályból, és eredményül azt kapjuk, hogy:</p><p><code class="code"><em><span class="remark">AritmetikaiIsmeretlen</span></em>(<em><span class="remark">z</span></em>) ⇒ <em><span class="remark">Egyszerűsítés</span></em>(1 × (0 + <em><span class="remark">z</span></em>), <em><span class="remark">z</span></em>)</code></p><p>Általánosságban elmondható, hogy a végleges szabályból azok a feltételek hagyhatók ki, amelyek nem jelentenek kényszert a szabály jobb oldalán lévő változókra vonatkozólag. Az eredményül kapott szabály továbbra is igaz, sőt még hatékonyabb is lesz. Vegyük észre azt is, hogy az <span class="emphasis"><em>AritmetikaiIsmeretlen</em></span>(<span class="emphasis"><em>z</em></span>) feltétel nem hagyható ki, hiszen a <span class="emphasis"><em>z</em></span>-nek nem minden lehetséges értéke aritmetikai ismeretlen. A <span class="emphasis"><em>z</em></span> más jellegű értékei esetén feltehetően más egyszerűsítési szabályokat kellene alkalmazni – például ha <span class="emphasis"><em>z</em></span> netán 2 × 3 lenne, akkor az 1 × (0       + (2 × 3)) helyes egyszerűsítése 6, és nem 2 × 3 lenne.</p><p>Összegezve, az alap MAT-módszer a következőképpen működik:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Ha adott egy példa, a rendelkezésre álló háttértudást felhasználva konstruáljunk egy bizonyítást arra, hogy a célpredikátum érvényes a példára.</p></li><li class="listitem"><p>Az előbbivel egy időben az eredeti bizonyítás következtetési lépéseivel azonos lépéseket alkalmazva konstruáljuk meg a szabad változós cél általánosított bizonyítási fáját.</p></li><li class="listitem"><p>Konstruáljuk meg az új szabályt úgy, hogy a szabály bal oldala a fa leveleiből áll, a jobb oldala viszont a szabad változós cél (az általánosított bizonyítás változókötéseit figyelembe véve).</p></li><li class="listitem"><p>Hagyjuk ki azokat a feltételeket, amelyek a célban foglalt változók értékeitől nem függnek.</p></li></ol></div><div class="figure"><a id="id733412"/><p class="title"><strong>19.7. ábra - Az egyszerűsítési probléma bizonyítási fái. Az első fa az eredeti problémapéldány bizonyítása, amiből az <span class="emphasis"><em>AritmetikaiIsmeretlen</em></span>(<span class="emphasis"><em>z</em></span>) ⇒ <span class="emphasis"><em>Egyszerűsítés</em></span>(1 × (0 + <span class="emphasis"><em>z</em></span>),<span class="emphasis"><em> z</em></span>) vezethető le. A második fa az a bizonyítás, amikor az eredeti problémapéldányban szereplő összes konstanst változókkal helyettesítettük, amiből viszont további szabályok sokaságát vezethetjük le.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-07.png" alt="Az egyszerűsítési probléma bizonyítási fái. Az első fa az eredeti problémapéldány bizonyítása, amiből az AritmetikaiIsmeretlen(z) ⇒ Egyszerűsítés(1 × (0 + z), z) vezethető le. A második fa az a bizonyítás, amikor az eredeti problémapéldányban szereplő összes konstanst változókkal helyettesítettük, amiből viszont további szabályok sokaságát vezethetjük le."/></div></div></div></div><div class="section" title="A hatékonyság javítása"><div class="titlepage"><div><div><h2 class="title"><a id="id733440"/>A hatékonyság javítása</h2></div></div></div><p>A 19.7. ábrán látható általánosított bizonyítási fából több általánosított szabályt is képesek vagyunk kinyerni. Ha a fa jobb oldali ágának növekedését leállítjuk, vagy az ágat <span class="strong"><strong>lemetsszük</strong></span> (<span class="strong"><strong>prune</strong></span>), amikor <span class="emphasis"><em>Primitív</em></span> lépéshez jutottunk, az alábbi szabályt kapjuk: </p><p><code class="code"><em><span class="remark">Primitív</span></em>(<em><span class="remark">z</span></em>) ⇒ <em><span class="remark">Egyszerűsítés</span></em>(1 × (0 + <em><span class="remark">z</span></em>), <em><span class="remark">z</span></em>)</code></p><p>Ez a szabály annyira érvényes, mint az <span class="emphasis"><em>AritmetikaiIsmeretlen</em></span>-t felhasználó szabály, bár annál általánosabb, mivel olyan esetekre is vonatkozik, amikor <span class="emphasis"><em>z</em></span> numerikus értékű. Még általánosabb szabályokat is kinyerhetünk, ha az <span class="emphasis"><em>Egyszerűsítés</em></span>(<span class="emphasis"><em>y </em></span>+ <span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>w</em></span>) után metszünk. Ekkor a szabály:</p><p><code class="code"><em><span class="remark">Egyszerűsítés</span></em>(<em><span class="remark">y </span></em>+ <em><span class="remark">z</span></em>, <em><span class="remark">w</span></em>) ⇒ <em><span class="remark">Egyszerűsítés</span></em>(1 ×  (<em><span class="remark">y </span></em>+ <em><span class="remark">z</span></em>), <em><span class="remark">w</span></em>)</code></p><p>Általánosságban elmondható, hogy szabályokat az általánosított bizonyítási fa <span class="emphasis"><em>bármely részfájából</em></span> nyerhetünk. Szembe kell néznünk azonban azzal a problémával, hogy ezek után melyik szabályt válasszuk.</p><p>Az a döntés, hogy melyik szabályt érdemes létrehozni, végső soron a hatékonyságon múlik. A MAT által biztosított hatékonyságnövekedésnek három tényezője van:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A tudásbázishoz nagyszámú szabály hozzáadása a következtetési folyamatot lelassíthatja, mivel a következtetési mechanizmusnak ezeket a szabályokat akkor is meg kell vizsgálnia, amikor ezek nem járulnak hozzá a megoldáshoz. Másképpen fogalmazva, a keresési tér <span class="strong"><strong>elágazási tényező</strong></span>je (<span class="strong"><strong>branching factor</strong></span>) ilyenkor növekszik. </p></li><li class="listitem"><p>Ahhoz, hogy ezt a jelenséget kompenzáljuk, a létrehozott szabályoknak lényeges sebességnövekedést kell garantálniuk az általuk lefedett problémapéldányok esetében. Az ilyen sebességnövekedés főleg abból származik, hogy a származtatott szabályok révén elkerülhetjük azokat a holtágakat, amelyekbe különben a bizonyítás során belemennénk, illetve abból, hogy a bizonyítások rövidebbek lesznek.</p></li><li class="listitem"><p>A származtatott szabályoknak a lehető legáltalánosabbaknak kell lenniük, hogy a lehető legnagyobb esethalmazt fedjék le.</p></li></ol></div><p>A származtatott szabályok hatékonyságát megszokott módon úgy biztosíthatjuk, hogy megköveteljük a szabály minden részcéljától, hogy <span class="strong"><strong>hatásos</strong></span> (<span class="strong"><strong>operational</strong></span>) legyen. Durván fogalmazva, egy cél hatásos, ha „könnyű” megoldani. A <span class="emphasis"><em>Primitív</em></span>(<span class="emphasis"><em>z</em></span>) részcélt például könnyű megoldani, a megoldásához két lépés elegendő. Ezzel szemben az <span class="emphasis"><em>Egyszerűsítés</em></span>(<span class="emphasis"><em>y </em></span>+ <span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>w</em></span>) részcél tetszőleges számú következtetéshez vezethet az <span class="emphasis"><em>y</em></span> és a <span class="emphasis"><em>z</em></span> értékeinek függvényében. Ha az általánosított bizonyítás megkonstruálásakor a hatásossági tesztet minden lépésnél elvégezzük, az ágat azonnal lemetszhetjük, amint egy hatásos részcélra rátaláltunk. A hatásos részcélt ilyenkor az új szabály egy konjunktív elemeként megtartjuk.</p><p>Sajnos a hatásosság és az általánosság között általában kompromisszumot kell kötni. A konkrétabb részcélokat könnyebb megoldani, viszont azok kevesebb esetet fednek le. A hatásosság tovább fokozható; egy vagy két lépés nyilvánvalóan hatásos, de mi a helyzet 10-zel vagy 100-zal? Egy adott részcél megoldásának a költsége végül attól függ, hogy a tudásbázis milyen egyéb szabályokat tartalmaz. A költség növekedhet vagy csökkenthet, ahogy a tudásbázishoz új szabályokat adunk. Az adott kezdeti tudásbázis hatékonyságának maximalizálásánál a MAT-rendszerek valóban igen komplex optimizációs problémával kerülnek szembe. Néha megalkotható annak matematikai modellje, hogy egy adott szabály hozzáadása általában milyen hatással van a hatékonyságra, és ennek a modellnek a használatával a hozzáadandó legjobb szabály megválasztható. Az elemzés azonban igen komplikált lehet, különösképpen ha rekurzív szabályokkal van dolgunk. Ígéretes megközelítés a hatékonyság empirikus vizsgálata, amikor néhány szabály hozzáadásával meggyőződünk arról, hogy a szabályok közül melyik az, amelyik ténylegesen hasznos, és amelyik az eljárásokat felgyorsítja.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A hatékonyság empirikus elemzésének gondolata a MAT lényegét érinti. Amit eddig informálisan „az adott tudásbázis hatékonyságának” neveztünk, az nem más, mint egy átlagos esetkomplexitás a megoldandó problémák egy eloszlásán mérve. A <span class="emphasis"><em>régi példák általánosításával a MAT növeli a tudásbázis hatékonyságát a jövőben ésszerűen várható problémák szempontjából</em></span>. Az ötlet addig jó, amíg a régi példák eloszlása durván megegyezik a jövőbeli példák eloszlásával. Ez a feltételezés azonos azzal, amit a 18.5. alfejezetben a VKH-tanulás kapcsán megtettünk. Ha a MAT-rendszert gondosan kivitelezték, a későbbi problémáknál lényeges javulás érhető el. Egy nagyon nagy méretű, svéd és angol nyelv közötti beszédfordításra kifejlesztett, Prolog-alapú, természetes nyelvi rendszerben például, a valós idejű fordítási képességet csak az elemző folyamatra alkalmazott MAT révén sikerült elérni (Samuelsson és Rayner, 1991). </p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="Képalá"><sup>[<a id="ftn.id732997" href="#id732997" class="para">190</a>] </sup> Természetesen az <span class="emphasis"><em>u<sup>n</sup></em></span> általános szabályát is meg tudnánk valósítani, a mondanivalót azonban a közölt példa is jól illusztrálja.</p></div></div></div></body></html>
