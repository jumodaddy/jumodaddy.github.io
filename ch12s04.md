<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Feltételes tervkészítés"><div class="titlepage"><div><div><h1 class="title"><a id="id655703"/>Feltételes tervkészítés</h1></div></div></div><p>Feltételes tervkészítés a bizonytalanság kezelésének egy módja. Módszere, hogy a terv előre meghatározott pontjain ellenőrzi, hogy valójában mi is történik a környezetben. A feltételes tervkészítés bemutatása a teljesen megfigyelhető környezetek esetén a legegyszerűbb, így ezzel az esettel kezdünk. A részlegesen megfigyelhető eset jóval nehezebb, de egyben jóval érdekesebb is. </p><div class="section" title="Feltételes tervkészítés teljesen megfigyelhető környezetekben"><div class="titlepage"><div><div><h2 class="title"><a id="id655709"/>Feltételes tervkészítés teljesen megfigyelhető környezetekben</h2></div></div></div><p>A teljes megfigyelhetőség jelentése, hogy az ágens mindig ismeri az aktuális állapotot. Nemdeterminisztikus környezet esetén azonban, az ágens nem képes megjósolni a cselekvéseinek <span class="emphasis"><em>kimenetelét</em></span>. A feltételes tervkészítő ágens a nemdeterminisztikusságot úgy kezeli, hogy a tervekbe feltételes lépéseket épít be (tervkészítési időben), amelyek ellenőrzik a környezet állapotát (futási időben), hogy a továbbiakról dönthessen. A kérdés tehát, hogyan készíthetők el az ilyen feltételes tervek. </p><p>Példaként a <span class="strong"><strong>porszívóvilág</strong></span> (<span class="strong"><strong>vacuum word</strong></span>) problémakört használjuk, amelynek állapotterét a determinisztikus esetre a <a class="xref" href="ch03s02.md#ID_103_oldal">„Példaproblémák”</a> részben fektettük le. Emlékezzünk vissza, hogy a <span class="emphasis"><em>Balra</em></span>, a <span class="emphasis"><em>Jobbra</em></span> és a <span class="emphasis"><em>Szív</em></span> a rendelkezésre álló cselekvések. Szükségünk lesz néhány propozícióra, hogy definiáljuk az állapotokat: legyen az <span class="emphasis"><em>OttBal </em></span>(<span class="emphasis"><em>OttJobb</em></span>) igaz, ha az ágens a bal (jobb) állapotban van, és legyen a <span class="emphasis"><em>TisztaBal </em></span>(<span class="emphasis"><em>TisztaJobb</em></span>) igaz, ha a bal (jobb) állapot tiszta.<sup>[<a id="id655760" href="#ftn.id655760" class="footnote">122</a>]</sup> Az első feladatunk a <code class="code">STRIPS</code> nyelv kiterjesztése, hogy megengedje a nemdeterminisztikusságot. Ennek érdekében megengedjük a cselekvésekben a <span class="strong"><strong>diszjunktív következmények</strong></span>et (<span class="strong"><strong>disjunctive effects</strong></span>), ami azt jelenti, hogy egy cselekvést bármikor végrehajtva annak kettő vagy több különböző kimenetele is lehet. Tegyük fel például, hogy a <span class="emphasis"><em>Balra</em></span> lépés néha sikertelen. Ekkor a </p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Balra</span></em>, Előfeltétel:<em><span class="remark">OttJobb</span></em>, Következmény:<em><span class="remark">OttBal </span></em>∧ ¬<em><span class="remark">OttJobb</span></em>)</code></p><p>normál cselekvésleírást módosítanunk kell, hogy diszjunktív következményt is tartalmazzon:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Balra</span></em>, Előfeltétel:<em><span class="remark">OttJobb</span></em>, Következmény:<em><span class="remark">OttBal</span></em> ∨ <em><span class="remark">OttJobb</span></em>)	(12.1)</code></p><p>Szintén hasznosnak találjuk a <span class="strong"><strong>feltételes következmény</strong></span>eket (<span class="strong"><strong>conditional effect</strong></span>s), amikor is egy cselekmény következménye függ attól az állapottól, amelyben végrehajtjuk. A feltételes következmények a cselekvés <code class="code">KÖVETKEZMÉNY</code> részében jelennek meg a „<span class="strong"><strong>when </strong></span>&lt;<span class="emphasis"><em>feltétel</em></span>&gt;: &lt;<span class="emphasis"><em>következmény</em></span>&gt;” szintaxissal. Például a <span class="emphasis"><em>Szív</em></span> cselekvés modellezésére a </p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Szív</span></em>, Előfeltétel:, Következmény:(<em><span class="remark">when</span></em> <em><span class="remark">OttBal</span></em>: <em><span class="remark">TisztaBal</span></em>)</code></p><p><code class="code"><em><span class="remark">	</span></em>∧ (<em><span class="remark">when OttJobb</span></em>: <em><span class="remark">TisztaJobb</span></em>))]</code></p><p>kifejezést írnánk fel. A feltételes következmények nem vezetik be a nemdeterminisztikusságot, de segítséget nyújtanak annak modellezésében. Tegyük fel például, hogy egy körmönfont porszívónk van, ami néha, ha mozog, piszkot szór a célnégyzetre, de csak akkor, ha az tiszta. Ez a </p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Balra</span></em>, Előfeltétel:<em><span class="remark">OttJobb</span></em>, Következmény:<em><span class="remark">OttBal</span></em></code></p><p><code class="code">	∨ (<em><span class="remark">OttBal</span></em> ∧ (<em><span class="remark">when TisztaBal</span></em>: ¬<em><span class="remark">TisztaBal</span></em>))</code></p><p>leírással modellezhető, ami mind diszjunktív, mind pedig feltételes.<sup>[<a id="id655937" href="#ftn.id655937" class="footnote">123</a>]</sup> Hogy feltételes terveket készíthessünk, <span class="strong"><strong>feltételes lépés</strong></span>ekre (<span class="strong"><strong>conditional step</strong></span>s) van szükségünk. Ezeket az „<span class="strong"><strong>if</strong></span> &lt;<span class="emphasis"><em>teszt</em></span>&gt; <span class="strong"><strong>then</strong></span> <span class="emphasis"><em>terv_A</em></span> <span class="strong"><strong>else</strong></span> <span class="emphasis"><em>terv_B</em></span>” szintaxis használatával írjuk le, ahol a &lt;<span class="emphasis"><em>teszt</em></span>&gt; egy kétértékű függvénye az állapotváltozóknak. Az „<span class="strong"><strong>if</strong></span> <span class="emphasis"><em>OttBal</em></span> ∧ <span class="emphasis"><em>TisztaBal</em></span> <span class="strong"><strong>then</strong></span> <span class="emphasis"><em>Jobbra</em></span> <span class="strong"><strong>else</strong></span> <span class="emphasis"><em>Szív</em></span>” például a porszívóvilág egy feltételes lépése lehet. Egy ilyen lépés végrehajtása a kézenfekvő módon történik. A feltételes lépések egymásba ágyazásaival a tervek fák lesznek. </p><p>A feltételes tervektől elvárjuk, hogy működjenek, <span class="emphasis"><em>függetlenül attól, hogy valójában a cselekvés mely kimenetele következik be</em></span>. Ezzel a problémával egy másik köntösbe bújtatva már találkoztunk korábban. A kétszemélyes játékokban (lásd 6.<span class="emphasis"><em> </em></span>fejezet) olyan lépéseket szeretnénk, amelyek <span class="emphasis"><em>az ellenfél lépéseitől függetlenül</em></span> győzelemhez vezetnek. A nemdeterminisztikus tervkészítési problémákat ezért gyakran <span class="strong"><strong>természet elleni játék</strong></span>oknak (<span class="strong"><strong>games against nature</strong></span>) nevezik.</p><p>Vegyük a porszívóvilág egy speciális példáját. A kiinduló állapotban a robot a tiszta világ jobb oldali négyzetén van. Mivel a környezet teljesen megfigyelhető, az ágens ismeri a teljes <span class="emphasis"><em>OttJobb</em></span> ∧ <span class="emphasis"><em>TisztaBal</em></span> ∧ <span class="emphasis"><em>TisztaJobb</em></span> állapotleírást. A célállapotban a robot a tiszta világ bal oldali négyzetén van. Ez a feladat elég triviális lenne, ha nem a „dupla-Murphy” porszívóval lenne dolgunk, amely néha piszkot hagy maga után, amikor egy tiszta célnégyzetre lép, és néha bepiszkolja a tiszta négyzetet, ha a <span class="emphasis"><em>Szívás</em></span> cselekvés végrehajtódik. </p><p>Ennek a környezetnek a „játékfáját” a 12.9.<span class="emphasis"><em> </em></span>ábrán mutatjuk be. A cselekvéseket a robot a fa „állapot” csomópontjaiban hajtja végre, majd a körrel jelölt „valószínűségi” csomópontokban a természet dönt a cselekvés kimeneteléről. A megoldás egy részfa, mely (1) minden levelében egy cél csomópontot tartalmaz, (2) minden „állapot” csomóponthoz egy cselekvést specifikál, és (3) minden „valószínűségi” csomópontban tartalmazza az összes kimenetelhez tartozó ágat. Az ábrán a megoldást vastag vonallal jelöltük, ami a [<span class="emphasis"><em>Balra</em></span>,<span class="emphasis"><em> </em></span><span class="strong"><strong>if</strong></span> <span class="emphasis"><em>OttBal </em></span>∧ <span class="emphasis"><em>TisztaBal </em></span>∧ <span class="emphasis"><em>TisztaJobb</em></span> <span class="strong"><strong>then</strong></span> [] <span class="strong"><strong>else</strong></span> <span class="emphasis"><em>Szív</em></span>] tervnek felel meg. (Mivel állapottér-tervkészítőt használunk, a feltételes lépésekben használt tesztek egyelőre teljes állapot leírások.)</p><div class="figure"><a id="id656123"/><p class="title"><strong>12.9. ábra - A „dupla-Murphy” porszívóvilág keresési fájának első két szintje. Az állapotcsomópontokban és a <code class="code">VAGY</code> csomópontokban cselekvéseket kell választani. A valószínűségi csomópontok, amelyeket körökkel jelöltünk <code class="code">ÉS</code> csomópontok, ahol, ahogy azt a kimenő ágakon szereplő ív is jelöli, minden kimenetelt kezelni kell. A megoldást vastag vonallal jelöltük.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-09.png" alt="A „dupla-Murphy” porszívóvilág keresési fájának első két szintje. Az állapotcsomópontokban és a VAGY csomópontokban cselekvéseket kell választani. A valószínűségi csomópontok, amelyeket körökkel jelöltünk ÉS csomópontok, ahol, ahogy azt a kimenő ágakon szereplő ív is jelöli, minden kimenetelt kezelni kell. A megoldást vastag vonallal jelöltük."/></div></div></div><p>A játékok pontos megoldásához a <span class="strong"><strong>minimax algoritmus</strong></span>t használjuk (lásd 6.3.<span class="emphasis"><em> </em></span>ábra). Ehhez a feltételes tervkészítésben tipikusan két módosítás tartozik. Először is, a <code class="code">MAX</code> és a <code class="code">MIN</code> csomópontok <code class="code">VAGY</code> és <code class="code">ÉS</code> csomópontokká válhatnak. Nyilvánvalóan a tervnek minden elért állapotban választania kell <span class="emphasis"><em>valamilyen</em></span> cselekvést, de kezelnie kell ezen cselekvés <span class="emphasis"><em>minden</em></span> kimenetelét. Másodszor, az algoritmusnak nemcsak egy lépést kell megadnia, hanem egy feltételes tervet kell készítenie. Egy <code class="code">VAGY</code> csomópontban a terv egyszerűen a választott cselekvés, amelyet bármi követhet. Egy <code class="code">ÉS</code> csomópontban a terv <span class="emphasis"><em>if-then-else</em></span> lépések egymásba ágyazott sorozata, melyek minden lehetséges kimenetelhez egy résztervet adnak meg. Ezen lépésekben a feltétel vizsgálatokban teljes állapotleírások szerepelnek.<sup>[<a id="id656183" href="#ftn.id656183" class="footnote">124</a>]</sup></p><div class="figure"><a id="id656194"/><p class="title"><strong>12.10. ábra - Egy algoritmus a nemdeterminisztikus környezetek által generált <code class="code">ÉS-VAGY</code> gráfok keresésére. Feltételezzük, hogy az <code class="code">ÁLLAPOTÁTMENET</code> függvény a cselekvések egy listáját adja vissza, melyek mindegyike egy lehetséges kimenetel <span class="emphasis"><em>halmazhoz</em></span> tartozik. A cél egy feltételes terv megtalálása, ami bármilyen körülmények között elér egy célállapotot.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-10.png" alt="Egy algoritmus a nemdeterminisztikus környezetek által generált ÉS-VAGY gráfok keresésére. Feltételezzük, hogy az ÁLLAPOTÁTMENET függvény a cselekvések egy listáját adja vissza, melyek mindegyike egy lehetséges kimenetel halmazhoz tartozik. A cél egy feltételes terv megtalálása, ami bármilyen körülmények között elér egy célállapotot."/></div></div></div><p>Formálisan az eddig definiált keresési tér egy <code class="code"><em><span class="remark">és-vagy</span></em></code> <span class="strong"><strong>gráf</strong></span>. Az <code class="code">ÉS-VAGY</code> gráfok korábban a 7.<span class="emphasis"><em> </em></span>fejezetben az ítéletlogikai Horn-klóz következtetésben jelentek meg. Itt az ágak logikai következtető lépések helyett cselekvések, de az algoritmus azonos. A 12.10.<span class="emphasis"><em> </em></span>ábra az <code class="code">ÉS-VAGY</code> gráfok keresésére egy rekurzív, mélységi kereső algoritmust ad meg.</p><p>A bemutatott algoritmusban kulcsfontosságú a nemdeterminisztikus tervkészítési problémákban gyakran felmerülő ciklusok kezelésének módja (például ha egy cselekvésnek néha nincs következménye vagy egy helytelen következmény kijavítható). Ha az aktuális állapot azonos a gyökértől idáig vezető útvonal egy állapotával, akkor hibával tér vissza. Ez nem jelenti, hogy <span class="emphasis"><em>nincs</em></span> megoldás az aktuális állapotból, egyszerűen annyit jelent, hogy <span class="emphasis"><em>van</em></span> egy nemciklikus megoldás, ami elérhető az aktuális állapot korábbi előfordulásából, így az állapot újabb bekövetkezése kihagyható. Ezzel az ellenőrzéssel biztosítjuk, hogy az algoritmus minden véges állapottér esetén leálljon, mivel minden útvonal célt ér, zsákutcába jut, vagy egy állapot ismétlése. Vegyük észre, hogy az algoritmus nem ellenőrzi, hogy az aktuális állapot egy <span class="emphasis"><em>másik</em></span> útvonalon szereplő állapot ismétlése-e. A 12.15.<span class="emphasis"><em> </em></span>feladat ezt a kérdést járja körül.</p><div class="figure"><a id="id656258"/><p class="title"><strong>12.11. ábra - A „tripla-Murphy” porszívóvilág keresési gráfjának első szintje, ahol a ciklusokat explicit megjelöltük. A probléma összes megoldása ciklikus terv.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-11.png" alt="A „tripla-Murphy” porszívóvilág keresési gráfjának első szintje, ahol a ciklusokat explicit megjelöltük. A probléma összes megoldása ciklikus terv."/></div></div></div><p>Az <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code> által visszaadott tervek feltételes lépéseket tartalmaznak, melyek a teljes állapotleírást megvizsgálják, hogy egy ágról döntsenek. A legtöbb esetben ennél jóval kevésbé kimerítő ellenőrzésekkel is megúszhatjuk. Például a 12.9.<span class="emphasis"><em> </em></span>ábrán látható megoldás a [<span class="emphasis"><em>Balra</em></span>, <span class="strong"><strong>if</strong></span> <span class="emphasis"><em>TisztaBal</em></span> <span class="strong"><strong>then</strong></span> [] <span class="strong"><strong>else</strong></span> <span class="emphasis"><em>Szív</em></span>] megadással egyszerűen leírható. Ennek oka, hogy a <span class="emphasis"><em>TisztaBal</em></span> teszt elegendő, hogy az <code class="code">ÉS</code> csomópont állapotait két egyelemű halmazba sorolja úgy, hogy a tesztek után az ágens pontosan ismerje az állapotát. Valójában az egyváltozós if-then-else tesztek sorozata mindig elegendő, hogy állapotok egy halmazát egyelemű halmazokra ossza,<span class="emphasis"><em> feltéve, </em></span>hogy<span class="emphasis"><em> </em></span>az állapot teljesen megfigyelhető. Ezért az általánosság teljes megőrzése mellett a teszteket egyváltozós tesztekre szűkíthetjük.</p><p>Az utolsó nehézség, ami gyakran felmerül a nemdeterminisztikus feladatkörökben,  a következő: a dolgok nem mindig működnek elsőre, így újra kell próbálkozni. Vegyük például a „tripla-Murphy” porszívó példáját, mely (a korábban bemutatott szokások mellett) néha nem mozdul az utasítás ellenére. Például csakúgy, mint a (12.1)<span class="emphasis"><em> </em></span>egyenletben, a <span class="emphasis"><em>Balra</em></span> cselekvés tartalmazhatja a <span class="emphasis"><em>OttBal</em></span> ∨ <span class="emphasis"><em>OttJobb</em></span> diszjunktív hatást. Ekkor a [<span class="emphasis"><em>Balra</em></span>, <span class="strong"><strong>if</strong></span> <span class="emphasis"><em>TisztaBal</em></span> <span class="strong"><strong>then</strong></span> [] <span class="strong"><strong>else</strong></span> <span class="emphasis"><em>Szív</em></span>] terv már nem garantált, hogy működik. A 12.11.<span class="emphasis"><em> </em></span>ábra a keresési gráf egy részletét mutatja. Tisztán látható, hogy a továbbiakban nincsenek ciklusmentes megoldások, és az <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code> hibával térne vissza. Létezik azonban egy <span class="strong"><strong>ciklikus megoldás</strong></span> (<span class="strong"><strong>cyclic solution</strong></span>), ami addig próbálgatja a <span class="emphasis"><em>Balra</em></span> lépést, mígnem egyszer működik. Ez a megoldás könnyebben kifejezhető, ha a terv egy részét egy <span class="strong"><strong>címké</strong></span>vel (<span class="strong"><strong>label</strong></span>) jelöljük meg, és a terv ismételgetése helyett erre a címkére hivatkozunk. Így a ciklikus megoldásunk </p><p><code class="code">[<em><span class="remark">L</span></em><sub>1 </sub>: <em><span class="remark">Balra</span></em>, <em><span class="remark">if</span></em> <em><span class="remark">OttJobb</span></em> <em><span class="remark">then</span></em> <em><span class="remark">L</span></em><sub>1</sub> <em><span class="remark">else</span></em> <em><span class="remark">if TisztaBal </span></em><em><span class="remark">then</span></em> [] <em><span class="remark">else</span></em> <em><span class="remark">Szív</span></em>]</code></p><p>alakú. (A „<span class="strong"><strong>while</strong></span> <span class="emphasis"><em>OttJobb</em></span> <span class="strong"><strong>do</strong></span> <span class="emphasis"><em>Balra</em></span>” kifejezés egy jobb szintaxis a terv ciklikus részére.) Az <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code>-ben szükséges módosításokat a 12.16.<span class="emphasis"><em> </em></span>feladat dolgozza fel. A megvalósítás kulcsa, hogy az állapottérben egy <span class="emphasis"><em>L</em></span> állapotba visszalépő hurok a tervben egy arra a pontra visszamutató hurkot jelent, ahol az <span class="emphasis"><em>L</em></span> állapotba vezető résztervet végrehajtjuk.</p><p>Így már képesek vagyunk feltételeket és ciklusokat tartalmazó programokhoz hasonlatos összetett tervek létrehozására. Sajnos ezek a ciklusok <span class="emphasis"><em>végtelen</em></span> ciklusok lehetnek. Például a tripla-Murphy világ cselekvés reprezentációjában a semmi jelentése, hogy a <span class="emphasis"><em>Balra</em></span> szükségszerűen sikeres. A ciklikus tervek ezért kevésbé előnyösek, mint a ciklus nélküliek, de megoldásnak tekinthetők, amennyiben minden levél egy célállapot, és a terv minden pontjából elérhető egy levél.</p></div><div class="section" title="Feltételes tervkészítés részlegesen megfigyelhető környezetekben"><div class="titlepage"><div><div><h2 class="title"><a id="id656481"/>Feltételes tervkészítés részlegesen megfigyelhető környezetekben</h2></div></div></div><p>Az előző alfejezet teljesen megfigyelhető környezetekkel foglalkozott, amelyek előnye, hogy a feltételes ellenőrzések bármit kérdezhetnek, és biztosak lehetnek a választ kapnak. A valódi világban a részleges megfigyelhetőség jóval gyakoribb. Egy részlegesen megfigyelhető tervkészítési feladat kiinduló állapotában az ágens csak bizonyos dolgokat tud az aktuális állapotról. Ennek a helyzetnek a legegyszerűbb modellezése, ha a kiinduló állapotról annyit mondunk, hogy egy <span class="strong"><strong>állapothalmaz</strong></span>ba tartozik. Az állapothalmaz az ágens kiinduló <span class="strong"><strong>hiedelmi állapot</strong></span>át (<span class="strong"><strong>belief state</strong></span>) írja le.<sup>[<a id="id656501" href="#ftn.id656501" class="footnote">125</a>]</sup></p><p>Tegyük fel, hogy a porszívóvilág ágens tudja, hogy a jobb oldali négyzeten van, és az tiszta, de nem tudja érzékelni a piszok jelenlétét vagy hiányát a többi négyzeten. Ekkor, <span class="emphasis"><em>legjobb ismeretei szerint</em></span> két állapotban lehet: a bal oldali négyzet vagy piszkos, vagy tiszta. Ezt a hiedelmi állapotot a 12.12.<span class="emphasis"><em> </em></span>ábrán <span class="emphasis"><em>A</em></span>-val jelöltük. Az ábra a „váltakozó dupla-Murphy” porszívóvilág <code class="code">ÉS-VAGY</code> gráfjának egy részét mutatja be, melyben a tiszta négyzetet elhagyó ágens piszkot hagyhat maga után.<sup>[<a id="id656523" href="#ftn.id656523" class="footnote">126</a>]</sup> Ha a világ teljesen megfigyelhető volna, az ágens egy „Mozogj balra és jobbra, és szívd fel a piszkot, amennyiben találsz, amíg mindkét kocka tiszta nem lesz, és a bal oldali kockán vagyok” formájú ciklikus megoldást készíthetne (lásd 12.16.<span class="emphasis"><em> </em></span>feladat). Sajnos csak lokális szemétérzékeléssel ez a terv végrehajthatatlan, hiszen a „mindkét kocka tiszta” teszt igazságértéke nem határozható meg.</p><p>Figyeljük meg az <code class="code">ÉS-VAGY</code> gráf felépítését. Az <span class="emphasis"><em>A</em></span> hiedelmi állapotból a <span class="emphasis"><em>Balra</em></span> mozgás kimenetelét mutatjuk. (A többi cselekvésnek nincs értelme.) Mivel az ágens piszkot hagyhat maga után, a két kiinduló világból négy lehetséges világ adódhat, ahogy az a <span class="emphasis"><em>B</em></span> és <span class="emphasis"><em>C</em></span> állapotokban látható. A rendelkezésre álló érzékelő információk alapján a világ két különálló hiedelmi állapotra osztható.<sup>[<a id="id656553" href="#ftn.id656553" class="footnote">127</a>]</sup> A <span class="emphasis"><em>B</em></span>-ben, az ágens tudása a <span class="emphasis"><em>TisztaBal</em></span>, míg <span class="emphasis"><em>C</em></span>-ben a ¬<span class="emphasis"><em>TisztaBal</em></span>. A piszok feltakarítása <span class="emphasis"><em>C</em></span>-ben az ágenst a <span class="emphasis"><em>B</em></span>-be mozgatja. A <span class="emphasis"><em>B</em></span>-ből a jobbra mozgás vagy hagy piszkot maga után, vagy nem, így az ágensnek azon tudása alapján, hogy <span class="emphasis"><em>TisztaJobb</em></span> igaz (vissza az <span class="emphasis"><em>A</em></span>-ra) vagy hamis (<span class="emphasis"><em>D</em></span> hiedelmi állapot), ismét négy lehetséges világ adódik.</p><p>Összegezve a nemdeterminisztikus, részben megfigyelhető környezetek a hiedelmi állapotok egy <code class="code">ÉS-VAGY</code> gráfját eredményezik. Ebből adódóan feltételes tervek találhatók pontosan ugyanazon algoritmusokkal, mint a teljesen megfigyelhető esetben, nevezetesen az <code class="code">ÉS-VAGY-GRÁF-KERESÉS</code>-sel. Ez abból is könnyen megérhető, ha belátjuk, hogy az ágens <span class="emphasis"><em>hiedelmi</em></span> állapota <span class="emphasis"><em>mindig</em></span> teljesen megfigyelhető, azaz mindig tudja, hogy mit tud. A „hagyományos” teljesen megfigyelhető problémamegoldás csak egy speciális eset, melyben minden hiedelmi állapot egy egyelemű halmaz, pontosan egy fizikai állapottal. </p><div class="figure"><a id="id657787"/><p class="title"><strong>12.12. ábra - A „váltakozó dupla-Murphy” porszívóvilág <code class="code">ÉS-VAGY</code> gráfjának egy részét mutatja be, melyben a tiszta négyzetet elhagyó ágens piszkot hagyhat maga után. Az ágens nem tudja érzékelni a más négyzetben levő piszkot.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-12.png" alt="A „váltakozó dupla-Murphy” porszívóvilág ÉS-VAGY gráfjának egy részét mutatja be, melyben a tiszta négyzetet elhagyó ágens piszkot hagyhat maga után. Az ágens nem tudja érzékelni a más négyzetben levő piszkot."/></div></div></div><p>Ezzel készen vagyunk? Nem egészen! Még meg kell határoznunk, hogy hogyan reprezentáljuk a hiedelmi állapotokat, hogyan működik az érzékelés, és hogy ebben az új helyzetben hogyan írjuk le a cselekvéseket. </p><p>A hiedelmi állapotok esetén alapvetően három választásunk van:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p> Teljes állapotleírások halmazai. Például a 12.12.<span class="emphasis"><em> </em></span>ábra kiinduló hiedelmi állapota az </p></li></ol></div><p><code class="code">{(<em><span class="remark">OttJobb</span></em> ∧ <em><span class="remark">TisztaJobb</span></em> ∧ <em><span class="remark">TisztaBal</span></em>), (<em><span class="remark">OttJobb</span></em> ∧ <em><span class="remark">TisztaJobb</span></em> ∧ ¬<em><span class="remark">TisztaBal</span></em>)}</code></p><p>Ezzel a leírással könnyű dolgozni, de nagyon költséges: ha <span class="emphasis"><em>n</em></span> kétértékű ítéletállítás definiál egy állapotot, akkor a hiedelmi állapot <span class="emphasis"><em>O</em></span>(2<sup>n</sup>) fizikai állapotleírást tartalmazhat, melyek mindegyike <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) méretű. Ha az ágens az ítéletállításoknak csak egy töredékét ismeri, exponenciálisan nagy hiedelmi állapotok adódnak — minél kevesebbet tud, annál több lehetséges állapotban lehet. </p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Logikai mondatok, melyek pontosan leírják a hiedelmi állapotban lehetséges világok halmazát. Például a kiinduló állapot az</p></li></ol></div><p><code class="code"><em><span class="remark">OttJobb</span></em> ∧ <em><span class="remark">TisztaJobb</span></em></code></p><p>formában adható meg. Nyilvánvaló, hogy bármely hiedelmi állapot pontosan befoglalható egyetlen logikai mondatba. Ha akarjuk, az összes konjuktív állapotleírás diszjunkcióját vehetjük, de a példánk mutatja, hogy ennél tömörebb mondatok létezhetnek.</p><p>Az általános logikai mondatok egyik hátulütője, hogy mivel sok ekvivalens, de különböző logikai mondat írhatja le ugyanazt a hiedelmi állapotot, az ismétlődő állapotok ellenőrzése általános tételbizonyító képességeket vár el a gráfkereső algoritmustól. Ezért a mondatok egy <span class="emphasis"><em>kanonikus</em></span> reprezentációját szeretnénk, amelyben minden hiedelmi állapot pontosan ugyanannak a mondatnak felel meg.<sup>[<a id="id657887" href="#ftn.id657887" class="footnote">128</a>]</sup> Egy ilyen reprezentáció, azaz ítéletállítások nevei alapján rendezett literálok konjukcióját használja, melynek egy példája a ¬<span class="emphasis"><em>OttJobb</em></span> ∧ <span class="emphasis"><em>TisztaJobb</em></span>. Ez a 11.<span class="emphasis"><em> </em></span>fejezet <span class="strong"><strong>nyílt világ feltételezés</strong></span>ében (<span class="strong"><strong>open-world assumption</strong></span>) egy egyszerű állapotleírás. Nem minden logikai mondat írható fel ilyen alakban (például nincs mód az <span class="emphasis"><em>OttBal</em></span> ∨ <span class="emphasis"><em>TisztaJobb</em></span> felírására), de számos probléma kezelhető.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Tudás ítéletállítás</strong></span>ok (<span class="strong"><strong>knowledge proposition</strong></span>s), amelyek az ágens ismereteit írják le. (Ugyanezt lásd a 7.7.<span class="emphasis"><em> </em></span>alfejezetben.) A kiinduló állapotunk: </p></li></ol></div><p><code class="code"><em><span class="remark">K</span></em>(<em><span class="remark">OttJobb</span></em>) ∧ <em><span class="remark">K</span></em>(<em><span class="remark">TisztaJobb</span></em>)</code></p><p>ahol <span class="emphasis"><em>K</em></span> jelentése „tudja” és <span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>P</em></span>) jelentése, hogy az ágens tudja, hogy <span class="emphasis"><em>P</em></span> igaz.<sup>[<a id="id657995" href="#ftn.id657995" class="footnote">129</a>]</sup> A tudás ítéletállításokkal zárt világ feltételezést használunk, azaz ha egy állítás nem jelenik meg a listában, akkor hamisnak feltételezzük. Például a ¬<span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>TisztaBal</em></span>) és a ¬<span class="emphasis"><em>K</em></span>(¬<span class="emphasis"><em>TisztaBal</em></span>) implicit szerepelnek a fenti mondatban, így az rögzíti a tényt, hogy az ágens érzéketlen a <span class="emphasis"><em>TisztaBal</em></span> igazságértékére.</p><p>Kimutatható, hogy a második és harmadik lehetőségek durván azonosak, de mi a harmadik tudás, az ítéletállítás lehetőséget használjuk, mert ez az érzékelés egy erősebb leírását adja, és mert már tudjuk, hogy hogyan írhatunk a <span class="strong"><strong>zárt</strong></span><span class="strong"><strong> </strong></span><span class="strong"><strong>világ feltételezés</strong></span> (<span class="strong"><strong>closed-world assumption</strong></span>) mellett <code class="code">STRIPS</code> kifejezéseket.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Mindkét esetben, minden ítéletszimbólum háromféleképpen jelenhet meg: lehet pozitív, negált vagy ismeretlen. Ezért így pontosan 3<sup>n</sup> lehetséges hiedelmi állapot adható meg. A hiedelmi állapotok halmaza így a hatványhalmaza (az összes részhalmaz halmaza) a fizikai állapotoknak. Összesen 2<sup>n</sup> fizikai állapot van, ezért 2^2<sup>n</sup><span class="emphasis"><em> </em></span>hiedelmi állapot, ami sokkal több, mint 3<sup>n</sup>, így a 2. és 3. választás eléggé korlátozottan alkalmas a hiedelmi állapotok leírására. Ez jelenleg használhatatlannak tűnik, hiszen <span class="emphasis"><em>bármely séma</em></span>,<span class="emphasis"><em> ami képes minden lehetséges hiedelmi állapot reprezentálására</em></span>, <span class="emphasis"><em>O</em></span>(log<sub>2</sub>(2^2<sup>n</sup>)) = <span class="emphasis"><em>O</em></span>(2<sup>n</sup>) <span class="emphasis"><em>bitet igényel</em></span>,<span class="emphasis"><em> hogy legrosszabb esetben mindegyiket leírhassa</em></span>. A mi egyszerű sémánk csak <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) bitet igényel a hiedelmi állapotok leírásához, mert a kifejezőképességet a tömörségre cseréltük. Nevezetesen, ha egy cselekvés megjelenik, amelynek az előfeltételei ismeretlenek, akkor az eredményként kapott hiedelmi állapot nem lesz pontosan reprezentálható, és a cselekvés kimenetele ismeretlen lesz.</p></div><p>Most arról kell döntenünk, hogy az érzékelés hogyan működik. Itt két választásunk van. Használhatunk <span class="strong"><strong>automatikus érzékelés</strong></span>t (<span class="strong"><strong>automatic sensing</strong></span>), ami annyit tesz, hogy az ágens minden időlépésben az összes elérhető érzetet megkapja. A 12.12.<span class="emphasis"><em> </em></span>ábrán látható példa a helyzet és a helyi tisztaság meghatározására automatikus érzékelést feltételez. Használhatunk ellenben <span class="strong"><strong>aktív érzékelés</strong></span>t (<span class="strong"><strong>active sensing</strong></span>), ami annyit jelent, hogy az érzékelt információk csak megadott <span class="strong"><strong>érzékelési cselekvés</strong></span>ek (<span class="strong"><strong>sensory action</strong></span>s), (mint <span class="emphasis"><em>TisztaságEllenőrzés</em></span> és <span class="emphasis"><em>PozícióEllenőrzés</em></span>) végrehajtásával nyerhetők. Az érzékelési típusokat sorban tárgyalni fogjuk. </p><p>Most használjunk tudás állításokat a cselekvések leírásához. Tegyük fel, hogy az automatikus helyi tisztaságérzékeléssel felruházott váltakozó-dupla-Murphy világ problémában az ágens <span class="emphasis"><em>Balra</em></span> lép. Az erre a világra vonatkozó szabályoknak megfelelően az ágens hagy, vagy talán nem hagy piszkot maga után, ha a négyzet tiszta volt. Mint <span class="emphasis"><em>fizikai</em></span> következmény, ez <span class="emphasis"><em>diszjunktív</em></span> lenne, de mint <span class="emphasis"><em>tudás</em></span> következmény ez egyszerűen törli az ágens <span class="emphasis"><em>TisztaJobb</em></span> tudását. Emellett az ágens a helyi piszokérzékelés miatt így vagy úgy tudni fogja, hogy vajon a <span class="emphasis"><em>TisztaBal</em></span> igaz-e, és tudni fogja, hogy a pozíciója <span class="emphasis"><em>OttBal</em></span>:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Balra</span></em>, Előfeltétel:<em><span class="remark">OttJobb</span></em>, </code></p><p><code class="code">	Következmény:<em><span class="remark">K</span></em>(<em><span class="remark">OttBal</span></em>) ∧ ¬<em><span class="remark">K</span></em>(<em><span class="remark">OttJobb</span></em>) ∧</code></p><p><code class="code">	<em><span class="remark">when TisztaJobb</span></em>: ¬<em><span class="remark">K</span></em>(<em><span class="remark">TisztaJobb</span></em>) ∧</code></p><p><code class="code">	<em><span class="remark">when TisztaBal</span></em>:<em><span class="remark"> K</span></em>(<em><span class="remark">TisztaBal</span></em>) ∧</code></p><p><code class="code">	 <em><span class="remark">when </span></em>¬<em><span class="remark">TisztaBal</span></em>:<em><span class="remark"> K</span></em>(¬<em><span class="remark">TisztaBal</span></em>)			(12.2)</code></p><p>Vegyük észre, hogy az előfeltételek és a <span class="strong"><strong>when</strong></span> feltételek egyszerű állítások és nem tudás állítások. Ez úgy van, ahogy lennie kell, hiszen a cselekvések kimenetele függ az aktuális világtól, de hogyan ellenőrizhetnénk ezen feltételek igazságértékét csupán a hiedelmi állapot alapján? Ha az ágens az aktuális hiedelmi állapotban <span class="emphasis"><em>tudja</em></span> mondjuk a <span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>OttJobb</em></span>)<span class="emphasis"><em> </em></span>állítást, akkor az állításnak igaznak kell lennie az aktuális fizikai állapotban, így egyben a cselekvés is alkalmazható. Ha az ágens nem ismeri az állítást (például <span class="emphasis"><em>TisztaBal</em></span> az <span class="strong"><strong>if</strong></span> feltételt), akkor a hiedelmi állapotnak tartalmaznia kell olyan világokat, melyekben a <span class="emphasis"><em>TisztaBal</em></span> igaz, és olyan világokat, amelyekben a <span class="emphasis"><em>TisztaBal</em></span> hamis. Pontosan ez az, ami miatt egy cselekvés többszörös hiedelmi állapotokat eredményez. Így, ha a kiinduló állapot a  (<span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>OttJobb</em></span>) ∧ <span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>TisztaJobb</em></span>)), akkor a <span class="emphasis"><em>Balra</em></span> lépés után a (<span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>OttBal</em></span>) ∧ <span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>TisztaBal</em></span>))<span class="emphasis"><em> </em></span>és a (<span class="emphasis"><em>K</em></span>(<span class="emphasis"><em>OttBal</em></span>) ∧ <span class="emphasis"><em>K</em></span>(¬<span class="emphasis"><em>TisztaBal</em></span>)) a két lehetséges hiedelmi állapot. Mindkét esetben ismert a <span class="emphasis"><em>TisztaBal</em></span> értéke, így a <span class="emphasis"><em>TisztaBal</em></span> teszt felhasználható a tervben. </p><p>Aktív érzékelés (mint az automatikus érzékelés ellentettje) esetén, az ágens csak kérésre kap új megfigyeléseket. Így a <span class="emphasis"><em>Balra</em></span> lépés után az ágens nem tudja, hogy a bal oldali négyzet piszkos-e, ezért a (12.2)<span class="emphasis"><em> cselekvésleíró </em></span>egyenletben az utolsó két feltételes következmény már nem jelenik meg. Az ágens a <span class="emphasis"><em>TisztaságEllenőrzés</em></span> cselekvéssel derítheti ki, hogy a négyzet piszkos-e:</p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">TisztaságEllenőrzés</span></em>, Következmény: <em><span class="remark">when</span></em> <em><span class="remark">OttBal</span></em> ∧ <em><span class="remark">TisztaBal</span></em>:<em><span class="remark"> K</span></em>(<em><span class="remark">TisztaBal</span></em>) ∧</code></p><p><code class="code">			<em><span class="remark">when OttBal</span></em> ∧ ¬<em><span class="remark">TisztaBal</span></em>:<em><span class="remark"> K</span></em>(¬<em><span class="remark">TisztaBal</span></em>) ∧</code></p><p><code class="code">			<em><span class="remark">when OttBal</span></em> ∧ <em><span class="remark">TisztaJobb</span></em>:<em><span class="remark"> K</span></em>(<em><span class="remark">TisztaJobb</span></em>) ∧	</code></p><p><code class="code">			<em><span class="remark">when OttBal</span></em> ∧ ¬<em><span class="remark">TisztaJobb</span></em>:<em><span class="remark"> K</span></em>(¬<em><span class="remark">TisztaJobb</span></em>)		(12.3)</code></p><p>Könnyű megmutatni, hogy aktív érzékelés esetén a <span class="emphasis"><em>Balra </em></span>lépéssel követett <span class="emphasis"><em>TisztaságEllenőrzés</em></span> cselekvés ugyanazt a két hiedelmi állapotot eredményezi, amit az automatikus érzékelés esetén a <span class="emphasis"><em>Balra</em></span> adott. Aktív érzékelés esetén a fizikai cselekvések egy hiedelmi állapotot mindig egyetlen követő hiedelmi állapotra képeznek le. A többszörös hiedelmi állapotok csak az érzékelő cselekvések által jöhetnek létre, melyek specifikus tudást adnak, s ezért lehetővé teszik a feltételvizsgálatok használatát a tervekben. </p><p>Az eddigiekben az állapottér <code class="code">ÉS-VAGY</code> keresésén alapuló feltételes tervkészítésre mutattunk be egy általános megközelítést. Ez a megközelítés néhány tesztproblémán elég hatékonynak bizonyult, de más feladatokra alkalmatlan. Bizonyítható, hogy a feltételes tervkészítés nagyobb algoritmikus komplexitású, mint a hagyományos. Emlékezzünk vissza, hogy az <span class="emphasis"><em>NP</em></span> osztály definíciója alapján egy megoldásról ellenőrizhető, hogy polinomiális idejű-e. Ez a hagyományos tervekre (legalábbis a polinomiális méretűekre) igaz, így a hagyományos tervkészítés az <span class="emphasis"><em>NP</em></span> osztályba tartozik. A feltételes tervkészítés esetén egy jelöltre ellenőrizni kell, hogy az <span class="emphasis"><em>összes</em></span> lehetséges állapotra a tervben létezik-e <span class="emphasis"><em>valamilyen,</em></span> a célt kielégítő útvonal. Az „összes/valamilyen” összeállítás nem ellenőrizhető polinomiális időben, így a feltételes tervkészítés nehezebb, mint <span class="emphasis"><em>NP</em></span>. Ez csak úgy kerülhető el, hogy a tervkészítési fázisban figyelmen kívül hagyunk néhány lehetséges eshetőséget, és ezeket csak akkor kezeljük, ha valójában fellépnek. A következő alfejezetben ezt a megközelítést elemezzük. </p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id655760" href="#id655760" class="para">122</a>] </sup> Nyilvánvalóan az <span class="emphasis"><em>OttJobb</em></span> akkor és csak akkor igaz, ha a ¬<span class="emphasis"><em>OttBal</em></span> igaz, és fordítva. A két állítás használatának oka főként az olvashatóság javítása.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id655937" href="#id655937" class="para">123</a>] </sup> A <span class="strong"><strong>when</strong></span> <span class="emphasis"><em>TisztaBal</em></span>:<span class="emphasis"><em> </em></span>¬<span class="emphasis"><em>TisztaBal</em></span> feltételes következmény egy kicsit furcsának tűnhet. Emlékezzünk vissza azonban, hogy itt a <span class="emphasis"><em>TisztaBal</em></span> a cselekvés <span class="emphasis"><em>előtti,</em></span> míg a ¬<span class="emphasis"><em>TisztaBal</em></span> a cselekvés végrehajtása <span class="emphasis"><em>utáni</em></span> helyzetre vonatkozik.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id656183" href="#id656183" class="para">124</a>] </sup> Az ilyen terveket <span class="strong"><strong>case</strong></span> szerkezettel is leírhatnánk.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id656501" href="#id656501" class="para">125</a>] </sup> Ezeket a fogalmakat a 3.6. alfejezetben vezettük be, így az olvasó ezt átismételheti a továbblépés előtt.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id656523" href="#id656523" class="para">126</a>] </sup> A kisgyermekes szülők jól ismerhetik ezt a jelenséget. Tisztelet a kivételnek.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id656553" href="#id656553" class="para">127</a>] </sup> Vegyük észre, hogy ezek nem aszerint kerülnek osztályzásra, hogy az ágens piszkot hagy-e maga után, amikor mozdul. A hiedelmi állapottérbeli elágazásokat a különböző tudáslehetőségek, és nem a különböző fizikai kimenetelek okozzák.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id657887" href="#id657887" class="para">128</a>] </sup> Az általános ítéletlogikai mondatok legjobb kanonikus reprezentációja a <span class="strong"><strong>bináris döntési diagram</strong></span> (<span class="strong"><strong>binary</strong></span><span class="strong"><strong> decision diagram</strong></span>) vagy <span class="strong"><strong>BDD </strong></span>(Bryant, 1992).</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id657995" href="#id657995" class="para">129</a>] </sup> Ez a jelölés ugyanaz, mint amit a 7. fejezetben az áramköralapú ágenseknél használtunk. Néhány szerző ezt a „tudja, hogy <span class="emphasis"><em>P</em></span> igaz-e” értelemben használja. A két értelmezés közötti fordítás kézenfekvő.</p></div></div></div></body></html>
