<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Tudástervezés az elsőrendű logikában"><div class="titlepage"><div><div><h1 class="title"><a id="id600711"/>Tudástervezés az elsőrendű logikában</h1></div></div></div><p>A megelőző alfejezet bemutatta az elsőrendű logika használatát a tudás reprezentálására három egyszerű tárgyterületben. Ez az alfejezet a tudásbázis felépítésének általános folyamatát írja le – egy folyamatot, amit <span class="strong"><strong>tudástervezés</strong></span>nek (<span class="strong"><strong>knowledge engineering</strong></span>) nevezünk. A tudásmérnök egy olyan személy, aki egy bizonyos tárgyterületet vizsgál, megismeri, hogy mely koncepciók fontosak abban a tárgyterületben, és megalkot egy formális reprezentációt a tárgyterületben található objektumokra és relációkra. A tudástervezés folyamatát az elektronikus áramkör tárgyterületében fogjuk illusztrálni, amely már valószínűleg ismerős, így koncentrálhatunk az ezzel járó reprezentációs problémákra. Az általunk alkalmazott megközelítés <span class="emphasis"><em>speciális célú </em></span>tudásbázisok kialakításához megfelelő, amelyek tárgyterülete alaposan körülhatárolt, és amelyek lekérdezéseinek az egész sorozatát előre ismerjük. Általános<span class="emphasis"><em> célú </em></span>tudásbázisokat, amelyeket arra használunk, hogy lekérdezéseket tegyenek lehetővé az emberi tudás teljes területére vonatkozóan, a 10. fejezetben tárgyaljuk majd meg.</p><div class="section" title="A tudástervezés folyamata"><div class="titlepage"><div><div><h2 class="title"><a id="id600734"/>A tudástervezés folyamata</h2></div></div></div><p>A tudástervezési projektek különbözők tárgyukat, tárgykörüket és nehézségüket tekintve, de minden ilyen projekt tartalmazza a következő lépéseket:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="emphasis"><em>A feladat beazonosítása. </em></span>A tudásmérnöknek fel kell vázolnia a kérdések sorát, amelyekkel a tudásbázis foglalkozni fog, és a tényeknek azokat a csoportjait, amelyek minden egyes problémaspecifikus példányban megtalálhatók lesznek. El kell döntenie például, hogy a wumpus tudásbázisnak képesnek kell-e lennie a cselekvések kiválasztására, vagy hogy csak az várható el, hogy a környezet elemeivel kapcsolatos kérdéseket válaszolja meg. Tudnia kell, hogy az érzékelőktől származó tények leírják-e a jelenlegi helyzetet. A feladat határozza meg, hogy mely tudást kell tárolni, hogy a problémapéldányokban a válaszokat megadhassuk az adott esetre vonatkozóan. Ez a lépés analóg az ágensek tervezésénél látott TKBÉ-folyamattal, amelyről a 2. fejezetben írtunk.</p></li><li class="listitem"><p><span class="emphasis"><em>A releváns tudás összegyűjtése.</em></span> A tudásmérnök vagy már szakértője a tárgyterületnek, vagy együtt kell működnie igazi szakértőkkel, hogy megismerje az ő tudásukat – ezt a folyamatot <span class="strong"><strong>tudásmegszerzés</strong></span>nek (<span class="strong"><strong>knowledge acquisition</strong></span>) nevezzük. Ezen a szinten a tudást formálisan nem reprezentáljuk. A cél az, hogy megértsük a tudásbázis tárgykörét, amit a feladat határol be, és meg kell érteni azt is, hogy a tárgyterület hogyan működik a gyakorlatban.</p></li></ol></div><p>	A wumpus világban, amelyet mesterségesen létrehozott szabályrendszer határoz meg, könnyű az idevonatkozó tudásbázist azonosítani. (Vegyük észre azonban, hogy a szomszédosság definíciója nem volt explicit megadva a wumpus világ szabályaiban.) A valódi tárgyterületekben a relevancia problémája meglehetősen bonyolult lehet – például egy VLSI tervező szimulációs rendszernek figyelembe kell vennie a szórt kapacitásokat és a felületi hatásokat.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="emphasis"><em>Meg kell határozni a predikátumok, függvények és konstansok szótárát. </em></span>Ez azt jelenti, hogy a fontos tárgyterület szintű koncepciókat le kell fordítani logikai szintű nevekre. Ez számos, a megközelítés <span class="emphasis"><em>jellegét</em></span> tárgyaló kérdést érint. Hasonlóan, mint a programozási stílusnak, ennek is jelentős hatása lehet a projekt végső sikerére. Például ilyen kérdés, hogy a csapdákat vajon objektumok jelenítsék-e meg vagy egy a négyzetekre vonatkozó unáris predikátum? Az ágens iránya függvény legyen-e vagy predikátum? A wumpus helyzete az időtől függjön-e? Mihelyt a választás megtörtént, az eredmény egy szótár, amit a tárgyterület <span class="strong"><strong>ontológiá</strong></span>jának (<span class="strong"><strong>ontology</strong></span>) nevezzünk. Az <span class="emphasis"><em>ontológia </em></span>fogalma egy olyan elméletet takar, ami a létezés természetét írja le. Meghatározza, hogy milyen dolgok léteznek, de nem határozza meg a rájuk jellemző tulajdonságokat, sem a köztük fennálló kapcsolatokat.</p></li><li class="listitem"><p><span class="emphasis"><em>A tárgyterületről szóló általános tudás kódolása. </em></span>A tudásmérnök leírja a szótár öszszes termjéhez tartozó axiómákat. Ez lerögzíti (amennyire lehetséges) a termek jelentését, és lehetővé teszi a szakértő számára a tartalom ellenőrzését. Ez a lépés gyakran feltárja a félreértelmezéseket vagy a hiányosságokat a szótárban, amelyeket a 3. lépéshez újra és újra visszatérve, iteratív eljárással javíthatunk.</p></li><li class="listitem"><p><span class="emphasis"><em>Az adott probléma példány leírásának kódolása. </em></span>Ha az ontológia jól átgondolt, ez a lépés már könnyű lesz. Egyszerű atomi mondatokat kell az ontológiában már leírt fogalmak példányaira megfogalmazni. Egy logikai ágens számára a problémapéldányokat az érzékelők biztosítják, amikor a „különálló” tudásbázist kiegészítik mondatokkal ugyanúgy, ahogy a hagyományos programoknak bemeneti adatokat adunk meg.</p></li><li class="listitem"><p><span class="emphasis"><em>Lekérdezéseket fogalmazunk meg a következtetési folyamat számára és válaszokat vezetünk le. </em></span>Itt kapjuk meg az eddigi munkánk jutalmát: működtethetjük a következtetési folyamatot az axiómákon és a problémaspecifikus tényeken, hogy megkapjuk a minket érdeklő tényeket.</p></li><li class="listitem"><p><span class="emphasis"><em>Szűrjük ki a hibákat a tudásbázisból. </em></span>Sajnos az első próbálkozásra a kérdésekre kapott válaszok nagyon ritkán lesznek helyesek. Pontosabban, a válaszok helyesek lesznek <span class="emphasis"><em>a megadott tudásbázis szempontjából, </em></span>feltételezve, hogy a következtetési folyamat megfelelő, de a válaszok nem azok lesznek, amiket a felhasználó vár. Például ha hiányzik egy axióma, akkor bizonyos kérdések megválaszolhatatlanok lesznek a tudásbázis alapján. Ilyenkor egy hibajavítási folyamatra van szükség. A hiányzó vagy túl gyenge axiómák könnyen megtalálhatók úgy, hogy felfedezzük azokat a helyeket, ahol a következtetés lánca váratlanul megszakad. Például ha a tudásbázis tartalmazza az egyik, csapdákra vonatkozó diagnosztikus axiómát,</p></li></ol></div><p><code class="code">∀<em><span class="remark">s  Szellős</span></em>(<em><span class="remark">s</span></em>)<em><span class="remark"> </span></em>⇒ ∃<em><span class="remark">r  Szomszédos</span></em>(<em><span class="remark">r</span></em>, <em><span class="remark">s</span></em>)<em><span class="remark"> </span></em>∧ <em><span class="remark">Csapda</span></em>(<em><span class="remark">r</span></em>)</code></p><p>	de nem tartalmazza a másikat, akkor az ágens soha nem lesz képes bizonyítani a csapdák <span class="emphasis"><em>hiányát. </em></span>A helytelen axiómák azonosíthatók, mivel ezek hamis állítások a világról. Például az a mondat, hogy:</p><p><code class="code">∀<em><span class="remark">x  LábakSzáma</span></em>(<em><span class="remark">x</span></em>, 4)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Emlős</span></em>(<em><span class="remark">x</span></em>)</code></p><p>	hamis a hüllőkre, kétéltűekre vagy ami még fontosabb, az asztalokra nézve. </p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p><span class="emphasis"><em>Ennek a mondatnak a hamissága a tudásbázis többi részétől függetlenül meghatározható. </em></span>Ezzel szemben egy tipikus programhiba ilyen:</p><p><code class="code">eltolás = pozíció + 1</code></p><p>Nem lehet ez alapján megmondani, hogy a mondat helyes-e anélkül, hogy megnéznénk a program többi részét. Például azt, hogy az eltolás-t a jelenlegi pozícióra vonatkozóan használjuk-e, vagy arra, amely eggyel a jelenlegi pozíció mögött van, vagy arra, hogy a pozíció<span class="emphasis"><em> </em></span>értéke megváltozott egy másik állítás által, és így az eltolás-t is meg kell változtatni.</p></div><p class="Tartalom3">Hogy jobban megértsük ezt a hétlépéses folyamatot, alkalmazzuk most egy kiterjesztett példára – az elektronikus áramkörök tárgyterületére.</p></div><div class="section" title="Az elektronikus áramkörök tárgyterülete"><div class="titlepage"><div><div><h2 class="title"><a id="id600908"/>Az elektronikus áramkörök tárgyterülete<sup>[<a id="id600911" href="#ftn.id600911" class="footnote">84</a>]</sup></h2></div></div></div><p class="Tartalom3">Létrehozunk egy ontológiát és egy tudásbázist, amelynek felhasználásával képesek leszünk következtetéseket végezni olyan típusú digitális áramkörökről, mint amilyet a 8.4. ábra mutat. A tudástervezés hétlépéses folyamatát fogjuk követni.</p></div><div class="section" title="A feladat meghatározása"><div class="titlepage"><div><div><h2 class="title"><a id="id600923"/>A feladat meghatározása</h2></div></div></div><p>Számos következtetési feladatot lehet a digitális áramkörökkel kapcsolatban elvégezni. A legmagasabb szinten az áramkör funkcionalitását vizsgálhatjuk. Például szabályosan ad-e össze a 8.4. ábrán látható áramkör? Ha minden bemenet magas, akkor mi az <span class="emphasis"><em>A</em></span><sub>2</sub> kapu kimenetének állapota? Az áramkör szerkezetéről feltett kérdések is érdekesek. Például melyek azok a kapuk, amelyek az első bemeneti ponthoz vannak kapcsolva? Tartalmaz-e az áramkör visszacsatolásokat? Ebben az alfejezetben ezeket a feladatokat vizsgáljuk meg. Léteznek az elemzésnek részletesebb szintjei is, például amelyek az időzítés késleltetésével, az áramkör területével, áramfogyasztásával, működtetési költségeivel és így tovább kapcsolatosak. Minden egyes ilyen szint vizsgálata további ismereteket igényel.</p></div><div class="section" title="A releváns tudás összegyűjtése"><div class="titlepage"><div><div><h2 class="title"><a id="id600935"/>A releváns tudás összegyűjtése</h2></div></div></div><p>Mit tudunk a digitális áramkörökről? A céljainknak megfelelően azt, hogy vezetékekből és kapukból állnak. A jelek a vezetékeken keresztül áramlanak a kapuk bemeneti termináljához, és minden kapu egy jelet hoz létre a kimeneti terminálon, ami aztán egy másik vezetéken áramlik. Ahhoz, hogy meghatározzuk, melyek is ezek a jelek, ismernünk kell, hogy a kapuk hogyan alakítják át bemeneti jeleiket. Négyféle kaput használunk: az AND, az OR és a XOR kapuknak két bemenetük van, míg a NOT kapuknak csak egy. Minden kapunak egy kimenete van. Az áramköröknek, hasonlóan a kapukhoz, bemeneteik és kimeneteik is vannak.</p><p>Ahhoz, hogy következtetéseket végezhessünk a funkcionalitásról és az összeköttetésekről, nem szükséges magukról a vezetékekről vagy ezek útvonalairól, két vezeték találkozásánál levő kereszteződéseiről tudást megfogalmazni. Csak a be- és kimenetek közötti összeköttetések számítanak – tehát csak azt kell kimondani, hogy egy kimenet össze van-e kapcsolva egy másik bemenettel, anélkül hogy meg kellene említeni a vezetékeket, amik valójában összekötik őket. A tárgyterületnek sok más tényezője van, ami a mi vizsgálatunkban nem releváns. Ilyen például a különböző elemek mérete, formája, színe vagy ára.</p><div class="figure"><a id="id600944"/><p class="title"><strong>8.4. ábra - Egy <span class="emphasis"><em>C</em></span><sub>1</sub>-es digitális áramkör, amelynek az a célja, hogy egy egybites teljes összeadást végezzen. Az első két bemenet az a két bit, amit össze kell adni, míg a harmadik bemenet az átvitel. Az első kimenet az összeg, míg a második kimenet az átvitel a következő összeadó felé. Az áramkör két XOR, két AND és egy OR kaput tartalmaz.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/08-04.png" alt="Egy C1-es digitális áramkör, amelynek az a célja, hogy egy egybites teljes összeadást végezzen. Az első két bemenet az a két bit, amit össze kell adni, míg a harmadik bemenet az átvitel. Az első kimenet az összeg, míg a második kimenet az átvitel a következő összeadó felé. Az áramkör két XOR, két AND és egy OR kaput tartalmaz."/></div></div></div><p class="Tartalom3">Ha a célunk valami más lenne, és nem a kapuszintű tervezés helyességének ellenőrzése, akkor az ontológiánk is más lenne. Például ha az érdekelne minket, hogyan lehetne a hibákat a hibás áramkörökben megtalálni, akkor valószínűleg jó ötlet lenne a vezetékekkel is foglalkozni az ontológiában, mivel egy hibás vezeték meghamisíthatja a rajta keresztülhaladó jelet. Az időzítési hibák megtalálásához a kapuk késleltetésével kapcsolatos fogalmakat kellene leírni. Ha az érdekelne minket, hogy hogyan lehet egy nyereséges terméket tervezni, akkor az áramkörök költségének és sebességének a piacon jelen lévő egyéb termékekkel történő összehasonlíthatósága lenne fontos.</p></div><div class="section" title="A szótár meghatározása"><div class="titlepage"><div><div><h2 class="title"><a id="id600963"/>A szótár meghatározása</h2></div></div></div><p class="Tartalom3">Tudjuk, hogy áramkörökről, be- és kimenetekről, jelekről és kapukról akarunk beszélni. A következő lépés az ezeket reprezentáló függvények, predikátumok és konstansok kiválasztása. Az egyes kaputípusoktól fogunk indulni, és végül eljutunk az áramkörökig.</p><p>Először is meg kell tudnunk különböztetni egy kaput a többi kaputól. Ezt úgy érjük el, hogy konstansokat használunk a kapuk megnevezésére: <span class="emphasis"><em>X</em></span><sub>1</sub>,<span class="emphasis"><em> X</em></span><sub>2</sub><span class="emphasis"><em> </em></span>és így tovább. Habár minden kapu a maga egyedi módján kapcsolódik az áramkörhöz, a <span class="emphasis"><em>viselkedése</em></span> – vagyis az a mód, ahogyan átalakítja a bemeneti jeleket kimeneti jelekké – csakis a <span class="emphasis"><em>típusától </em></span>függ. Egy kapu típusának jelölésére<sup>[<a id="id600994" href="#ftn.id600994" class="footnote">85</a>]</sup> egy függvényt használhatunk. Például írhatjuk, hogy <span class="emphasis"><em>Típus</em></span>(<span class="emphasis"><em>X</em></span><sub>1</sub>)<span class="emphasis"><em> </em></span>=<span class="emphasis"><em> XOR. </em></span>Ez hozzárendeli az <span class="emphasis"><em>XOR</em></span> konstanst egy bizonyos kaputípushoz. A többi konstans nevei: <span class="emphasis"><em>OR</em></span>, <span class="emphasis"><em>AND</em></span> és <span class="emphasis"><em>NOT</em></span> lesznek. A <span class="emphasis"><em>Típus </em></span>függvény nem az egyetlen lehetséges módja annak, hogy kódoljuk az ontológiai megkülönböztetést. Használhattunk volna egy bináris predikátumot is, mint a <span class="emphasis"><em>Típus</em></span>(<span class="emphasis"><em>X</em></span><sub>1</sub>, <span class="emphasis"><em>XOR</em></span>),<span class="emphasis"><em> </em></span>vagy több egyargumentumú predikátumot, mint például az <span class="emphasis"><em>XOR</em></span>(<span class="emphasis"><em>X</em></span><sub>1</sub>)<span class="emphasis"><em>. </em></span>Ezeknek a megoldásoknak bármelyike jól működne, de a <span class="emphasis"><em>Típus </em></span>függvény választásával kiküszöböltük, hogy szükség legyen egy olyan axiómára, amely azt mondja ki, hogy minden egyes kapunak csak egyetlen típusa lehet.</p><p class="Tartalom3">Ezután megvizsgáljuk a végpontokat (be- és kimeneteket). Egy kapunak vagy áramkörnek egy vagy több bemenete, és egy vagy több kimenete lehet. Mindegyiket elnevezhetnénk egyszerűen egy konstanssal, mint ahogy azt a kapukkal tettük. Így az <span class="emphasis"><em>X</em></span><sub>1 </sub>kapunak olyan végpontjai lennének, mint az <span class="emphasis"><em>X</em></span><sub>1</sub><span class="emphasis"><em>Be</em></span><sub>1</sub>, az<span class="emphasis"><em> X</em></span><sub>1</sub><span class="emphasis"><em>Be</em></span><sub>2</sub><span class="emphasis"><em> </em></span>és az <span class="emphasis"><em>X</em></span><sub>1</sub><span class="emphasis"><em>Ki</em></span><sub>1</sub><span class="emphasis"><em>. </em></span>A hosszú, összetett elnevezéseket azonban célszerű kerülni. Az, hogy valamit <span class="emphasis"><em>X</em></span><sub>1</sub><span class="emphasis"><em>Be</em></span><sub>1</sub>-nek nevezünk, nem jelenti azt, hogy ez az <span class="emphasis"><em>X</em></span><sub>1</sub> első bemenete; még ekkor is hozzá kell tennünk valamit egy explicit állítást használva. Valószínűleg szerencsésebb egy függvénnyel leírni egy kaput, hasonlóan mint, ahogy János király bal lábát elneveztük <span class="emphasis"><em>BalLáb</em></span>(<span class="emphasis"><em>János</em></span>)-nak. Így tehát jelöljük az <span class="emphasis"><em>X</em></span><sub>1</sub><span class="emphasis"><em> </em></span>kapu első bemenetét úgy, hogy: <span class="emphasis"><em>Be</em></span>(1, <span class="emphasis"><em>X</em></span><sub>1</sub>)<span class="emphasis"><em>. </em></span>Egy hasonló <span class="emphasis"><em>Ki</em></span> függvényt használunk a kimenetekre.</p><p class="Tartalom3">A kapuk közötti összeköttetést reprezentálhatjuk az <span class="emphasis"><em>Összekapcsolt </em></span>predikátummal, ami két végpontot vesz argumentumként, például így: <span class="emphasis"><em>Összekapcsolt</em></span>(<span class="emphasis"><em>Ki</em></span>(1, <span class="emphasis"><em>X</em></span><sub>1</sub>),<span class="emphasis"><em> Be</em></span>(1, <span class="emphasis"><em>X</em></span><sub>2</sub>)).</p><p class="Tartalom3">Végül, ismernünk kell, hogy egy jel magas vagy alacsony állapotban van-e. Erre egy lehetőség egy <span class="emphasis"><em>On</em></span> bináris predikátum használata, és akkor igaz, ha a jel egy végponton magas értékű. Ez azonban egy kissé megnehezíti az olyan kérdések feltevését, mint például: „Mik a lehetséges értékei a <span class="emphasis"><em>C</em></span><sub>1</sub> áramkör kimenetein lévő jeleknek?” Ezért be fogunk vezetni objektumokként két „jelértéket”, az 1-et és a 0-t, valamint egy <span class="emphasis"><em>Jel </em></span>függvényt, aminek egy végpont az argumentuma, és ami kijelöli ennek a végpontnak a jelértékét.</p></div><div class="section" title="A tárgyterülettel kapcsolatos általános tudás kódolása"><div class="titlepage"><div><div><h2 class="title"><a id="id601223"/>A tárgyterülettel kapcsolatos általános tudás kódolása</h2></div></div></div><p>Az egyik jele annak, hogy megfelelő ontológiát használunk az, hogy kevés olyan általános szabály van, amit később a példányokra specifikussá kellene tennünk. A helyes szótár jellemzője az, hogy minden egyes szabályt világosan és tömören meg tudunk fogalmazni. A mi példánkban csak hét egyszerű szabályra van szükségünk, hogy leírjunk mindent, amit tudnunk kell az áramkörökről.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Ha két végpont össze van kapcsolva, akkor ugyanaz lesz a jelértékük:</p></li></ol></div><p><code class="code">∀<em><span class="remark">t</span></em><sub>1</sub>, <em><span class="remark">t</span></em><sub>2</sub><em><span class="remark">  Összekapcsolt</span></em>(<em><span class="remark">t</span></em><sub>1</sub>, <em><span class="remark">t</span></em><sub>2</sub>)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Jel</span></em>(<em><span class="remark">t</span></em><sub>1</sub>)<em><span class="remark"> </span></em>=<em><span class="remark"> Jel</span></em>(<em><span class="remark">t</span></em><sub>2</sub>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A jel minden végpontnál vagy 1, vagy 0 (de soha nem mindkettő):</p></li></ol></div><p><code class="code">∀<em><span class="remark">t</span></em><sub>1</sub><em><span class="remark">  Jel</span></em>(<em><span class="remark">t</span></em>)<em><span class="remark"> </span></em>= 1 ∨ <em><span class="remark">Jel</span></em>(<em><span class="remark">t</span></em>)<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>0</code></p><p><code class="code">1 ≠ 0</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Az Összekapcsolt egy felcserélhető (kommutatív) predikátum:</p></li></ol></div><p><code class="code">∀<em><span class="remark">t</span></em><sub>1</sub>, <em><span class="remark">t</span></em><sub>2</sub><em><span class="remark">  Összekapcsolt</span></em>(<em><span class="remark">t</span></em><sub>1</sub>, <em><span class="remark">t</span></em><sub>2</sub>)<em><span class="remark"> </span></em>⇔<em><span class="remark"> Összekapcsolt</span></em>(<em><span class="remark">t</span></em><sub>1</sub>, <em><span class="remark">t</span></em><sub>2</sub>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Egy OR kapu kimenete akkor és csak akkor 1, ha bármelyik bemenete 1:</p></li></ol></div><p><code class="code">∀<em><span class="remark">g  Típus</span></em>(<em><span class="remark">g</span></em>)<em><span class="remark"> </span></em>= <em><span class="remark">OR</span></em> ⇒</code></p><p><code class="code"><em><span class="remark">      Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">g</span></em>))<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>1 ⇔ ∃<em><span class="remark">n  Jel</span></em>(<em><span class="remark">Be</span></em>(<em><span class="remark">n</span></em>, <em><span class="remark">g</span></em>))<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>1</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Egy AND kapu kimenete akkor és csakis akkor 0, ha bármelyik bemenete 0:</p></li></ol></div><p><code class="code">∀<em><span class="remark">g  Típus</span></em>(<em><span class="remark">g</span></em>)<em><span class="remark"> </span></em>= <em><span class="remark">AND</span></em> ⇒</code></p><p><code class="code"><em><span class="remark">      Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">g</span></em>))<em><span class="remark"> </span></em>= 0 ⇔ ∃<em><span class="remark">n  Jel</span></em>(<em><span class="remark">Be</span></em>(<em><span class="remark">n</span></em>, <em><span class="remark">g</span></em>))<em><span class="remark"> </span></em>= 0</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Egy XOR kapu kimenete akkor és csakis akkor 1, ha a bemenetei különbözők:</p></li></ol></div><p><code class="code">∀<em><span class="remark">g  Típus</span></em>(<em><span class="remark">g</span></em>)<em><span class="remark"> </span></em>= <em><span class="remark">XOR</span></em> ⇒</code></p><p><code class="code"><em><span class="remark">      Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">g</span></em>))<em><span class="remark"> </span></em>= 1 ⇔ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">g</span></em>) ≠ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(2, <em><span class="remark">g</span></em>))</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Egy NOT kapu kimenete különbözik a bemenetétől:</p></li></ol></div><p><code class="code">∀<em><span class="remark">g  </span></em>(<em><span class="remark">Típus</span></em>(<em><span class="remark">g</span></em>) = <em><span class="remark">NOT</span></em>) ⇒ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">g</span></em>)) ≠ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">g</span></em>))</code></p></div><div class="section" title="A problémaspecifikus példányok kódolása"><div class="titlepage"><div><div><h2 class="title"><a id="id601638"/>A problémaspecifikus példányok kódolása</h2></div></div></div><p>A 8.4. ábrán bemutatott áramkör neve <span class="emphasis"><em>C</em></span><sub>1</sub><span class="emphasis"><em> </em></span>és az itt következő leírással adjuk meg. Először kategorizáljuk a kapukat:</p><p><code class="code"><em><span class="remark">Típus</span></em>(<em><span class="remark">X</span></em><sub>1</sub>)<em><span class="remark"> </span></em>= <em><span class="remark">XOR</span></em>	<em><span class="remark">Típus</span></em>(<em><span class="remark">X</span></em><sub>2</sub>) = <em><span class="remark">XOR</span></em></code></p><p><code class="code"><em><span class="remark">Típus</span></em>(<em><span class="remark">A</span></em><sub>1</sub>)<em><span class="remark"> </span></em>= <em><span class="remark">AND</span></em>	<em><span class="remark">Típus</span></em>(<em><span class="remark">A</span></em><sub>2</sub>)<em><span class="remark"> </span></em>= <em><span class="remark">AND</span></em></code></p><p><code class="code"><em><span class="remark">Típus</span></em>(<em><span class="remark">O</span></em><sub>1</sub>)<em><span class="remark"> </span></em>= <em><span class="remark">OR</span></em></code></p><p>Ezután leírjuk a köztük fennálló kapcsolatokat:</p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">X</span></em><sub>1</sub>), <em><span class="remark">Be</span></em>(1, <em><span class="remark">X</span></em><sub>2</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(1, <em><span class="remark">X</span></em><sub>1</sub>))</code></p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">X</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(2, <em><span class="remark">A</span></em><sub>2</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(1, <em><span class="remark">A</span></em><sub>1</sub>))</code></p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1,<em><span class="remark"> A</span></em><sub>2</sub>),<em><span class="remark"> Be</span></em>(1, <em><span class="remark">O</span></em><sub>1</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(2,<em><span class="remark"> C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(2, <em><span class="remark">X</span></em><sub>1</sub>))</code></p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1,<em><span class="remark"> A</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(2, <em><span class="remark">O</span></em><sub>1</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(2,<em><span class="remark"> C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(2,<em><span class="remark"> A</span></em><sub>1</sub>))</code></p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">X</span></em><sub>2</sub>),<em><span class="remark"> Ki</span></em>(1,<em><span class="remark"> C</span></em><sub>1</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(3,<em><span class="remark"> C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(2, <em><span class="remark">X</span></em><sub>2</sub>))</code></p><p><code class="code"><em><span class="remark">Összekapcsolt</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">O</span></em><sub>1</sub>),<em><span class="remark"> Ki</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>))<em><span class="remark">	Összekapcsolt</span></em>(<em><span class="remark">Be</span></em>(3,<em><span class="remark"> C</span></em><sub>1</sub>),<em><span class="remark"> Be</span></em>(1, <em><span class="remark">A</span></em><sub>2</sub>))</code></p></div><div class="section" title="Lekérdezések megfogalmazása a következtetési eljárás felé"><div class="titlepage"><div><div><h2 class="title"><a id="id602027"/>Lekérdezések megfogalmazása a következtetési eljárás felé</h2></div></div></div><p>Milyen bemeneti kombinációk esetében lenne a <span class="emphasis"><em>C</em></span><sub>1</sub><span class="emphasis"><em> </em></span>első kimenete (az összegelem) 0 és a <span class="emphasis"><em>C</em></span><sub>1</sub> második kimenete (a maradék elem) 1?</p><p><code class="code">∃<em><span class="remark">i</span></em><sub>1</sub>, <em><span class="remark">i</span></em><sub>2</sub>, <em><span class="remark">i</span></em><sub>3</sub>  <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>))<em><span class="remark"> </span></em>= <em><span class="remark">i</span></em><sub>1</sub> ∧<em><span class="remark"> Jel</span></em>(<em><span class="remark">Be</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>))<em><span class="remark"> </span></em>= <em><span class="remark">i</span></em><sub>2</sub> ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(3, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>3</sub></code></p><p><code class="code">	∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>))<em><span class="remark"> </span></em>= 0 ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>))<em><span class="remark"> </span></em>= 1</code></p><p>A válaszok az <span class="emphasis"><em>i</em></span><sub>1</sub>,<span class="emphasis"><em> i</em></span><sub>2</sub> és <span class="emphasis"><em>i</em></span><sub>3</sub> változók behelyettesítései úgy, hogy a keletkezett mondat következzen a tudásbázisból. Három ilyen behelyettesítés létezik:</p><p><code class="code">{<em><span class="remark">i</span></em><sub>1</sub>/1, <em><span class="remark">i</span></em><sub>2</sub>/1, <em><span class="remark">i</span></em><sub>3</sub>/0}       {<em><span class="remark">i</span></em><sub>1</sub>/1, <em><span class="remark">i</span></em><sub>2</sub>/0, <em><span class="remark">i</span></em><sub>3</sub>/1}       {<em><span class="remark">i</span></em><sub>1</sub>/0, <em><span class="remark">i</span></em><sub>2</sub>/1, <em><span class="remark">i</span></em><sub>3</sub>/1}</code></p><p>Melyek a az összeadó áramkör összes végpontjának lehetséges értékhalmazai?</p><p><code class="code">∃<em><span class="remark">i</span></em><sub>1</sub>,<em><span class="remark"> i</span></em><sub>2</sub>,<em><span class="remark"> i</span></em><sub>3</sub>,<em><span class="remark"> o</span></em><sub>1</sub>,<em><span class="remark"> o</span></em><sub>2</sub>  <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>1</sub> ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>2</sub></code></p><p><code class="code">	∧<em><span class="remark"> Jel</span></em>(<em><span class="remark">Be</span></em>(3, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>3</sub> ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">o</span></em><sub>1 </sub>∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">o</span></em><sub>2</sub></code></p><p>Ez az utolsó lekérdezés egy teljes bemenet-kimenet táblázatot ad meg az eszközre, amelyet aztán ellenőrizhetünk, hogy valóban helyesen adja-e össze a bemeneteket. Ez egy egyszerű példa az <span class="strong"><strong>áramkör ellenőrzésé</strong></span>re (<span class="strong"><strong>circuit verification</strong></span>). Az áramkör bemutatott definícióját nagyobb digitális rendszerek építésére is felhasználhatjuk, amelyekre aztán ugyanez a fajta ellenőrzési folyamat alkalmazható (lásd 8.17. feladat). Sok tárgyterület kezelhető egy ehhez hasonló strukturált tudásbázis-fejlesztéssel, amelyekben összetettebb koncepciókat határozunk meg egyszerűbb koncepciókra építve.</p></div><div class="section" title="Hibák kiszűrése a tudásbázisból"><div class="titlepage"><div><div><h2 class="title"><a id="id602393"/>Hibák kiszűrése a tudásbázisból</h2></div></div></div><p class="Tartalom3">Sokféleképpen perturbálhatjuk a tudásbázist, hogy meglássuk, milyen fajta hibás viselkedések fordulhatnak elő. Például tételezzük fel, hogy kihagyjuk az 1 ≠ 0<sup>[<a id="id602400" href="#ftn.id602400" class="footnote">86</a>]</sup> állítást. A rendszer ebben a pillanatban már nem lesz képes semmilyen kimenetet sem produkálni az áramkörben, kivéve, ha a bemenet a 000 vagy az 110. Rábukkanhatunk a problémára, ha minden egyes kapu kimenetére rákérdezünk. Például, megkérdezhetjük:</p><p><code class="code">∃<em><span class="remark">i</span></em><sub>1</sub>, <em><span class="remark">i</span></em><sub>2</sub>, <em><span class="remark">o</span></em>  <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>1</sub> ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(2, <em><span class="remark">C</span></em><sub>1</sub>)) = <em><span class="remark">i</span></em><sub>2</sub> ∧ <em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1, <em><span class="remark">X</span></em><sub>1</sub>))</code></p><p>ami felfedi, hogy az <span class="emphasis"><em>X</em></span><sub>1</sub>-nél nem ismerjük a kimenetet az 10 és a 01 bemenetek esetén. Ezután megnézzük az XOR kapu axiómáit az <span class="emphasis"><em>X</em></span><sub>1</sub>-re alkalmazva:</p><p><code class="code"><em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1,<em><span class="remark"> X</span></em><sub>1</sub>))<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>1 ⇔ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(1, <em><span class="remark">X</span></em><sub>1</sub>))<em><span class="remark"> </span></em>≠ <em><span class="remark">Jel</span></em>(<em><span class="remark">Be</span></em>(2,<em><span class="remark"> X</span></em><sub>1</sub>))</code></p><p>Ha tudjuk, hogy a bemenetek, mondjuk, 1 és 0 voltak, akkor ezt lerövidíthetjük így:</p><p><code class="code"><em><span class="remark">Jel</span></em>(<em><span class="remark">Ki</span></em>(1,<em><span class="remark"> X</span></em><sub>1</sub>))<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>1 ⇔ 1 ≠ 0</code></p><p>Most már látható, hogy mi a probléma oka: a rendszer nem képes kikövetkeztetni azt, hogy <span class="emphasis"><em>Jel</em></span>(<span class="emphasis"><em>Ki</em></span>(1,<span class="emphasis"><em> X</em></span><sub>1</sub>)) = 1, így meg kell neki mondanunk, hogy 1 ≠ 0.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id600911" href="#id600911" class="para">84</a>] </sup> Ez az alfejezet a digitális áramkörök meglehetősen sajátos bemutatására vállalkozik. Miközben nem javasoljuk, hogy valaki ez alapján ismerkedjen meg a digitális áramkörökkel, és esetleg az itt bemutatottak alapján próbáljon digitális áramköröket tervezni, az itt leírtak mindenképpen érdekes nézőpontot tükröznek, és érdekes kísérletet jelentenek arra, hogy az elsőrendű logika fogalomkészletével mutassák be a digitális áramköröket. (<span class="emphasis"><em>A szerk.</em></span>)</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id600994" href="#id600994" class="para">85</a>] </sup> Vegyük észre, hogy megfelelő betűkkel kezdődő neveket használtunk – <span class="emphasis"><em>A</em></span><sub>1</sub>, <span class="emphasis"><em>X</em></span><sub>1</sub> és így tovább – pusztán azért, hogy könnyebben olvashatóvá tegyük a példát. A tudásbázisnak még így is tartalmaznia kell a kapuk típusára vonatkozó információkat.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id602400" href="#id602400" class="para">86</a>] </sup> Ez a fajta kihagyás eléggé gyakori, mert az emberek általában feltételezik, hogy a különböző nevek különböző dolgokat takarnak. A logikai programozási rendszerek, amelyeket bővebben a 9. fejezetben mutatunk be, szintén megteszik ezt a feltételezést.</p></div></div></div></body></html>
