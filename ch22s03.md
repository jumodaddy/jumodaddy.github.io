<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Szintaktikai analízis (elemzés)"><div class="titlepage"><div><div><h1 class="title"><a id="id759308"/>Szintaktikai analízis (elemzés)</h1></div></div></div><p>Már definiáltuk az <span class="strong"><strong>elemzés</strong></span>t (<span class="strong"><strong>parsing</strong></span>) mint az adott bemeneti füzérhez tartozó levezetési fa megtalálásának folyamatát. Azaz a <code class="code">PARSE</code> függvény meghívása, mint például a</p><p><code class="code">Parse(„the wumpus is dead”, ℰ<sub>0</sub>, <em><span class="remark">S</span></em>)</code></p><p>olyan fát kell visszaadnia, amelynek gyökerében <span class="emphasis"><em>S </em></span>áll, levelei a „the wumpus is dead” és belső csomópontjai az ℰ<sub>0 </sub>nyelvtan nem záró szimbólumai. A 22.1. ábrán láthattunk egy ilyen fát. Folytonos szövegként a következőképpen írhatjuk:</p><p><code class="code">[<em><span class="remark">S</span></em>:	[<em><span class="remark">NP</span></em>: [<em><span class="remark">Article</span></em>: <em><span class="remark">the</span></em>] [<em><span class="remark">Noun</span></em>: <em><span class="remark">wumpus</span></em>]]</code></p><p><code class="code">	[<em><span class="remark">VP</span></em>: [<em><span class="remark">Verb</span></em>:<em><span class="remark"> is</span></em>][<em><span class="remark">Adjective</span></em>: <em><span class="remark">dead</span></em>]]]</code></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p><span class="emphasis"><em>Az elemzés tekinthető egy levezetési fa megkeresésének folyamataként.</em></span> A keresési tér meghatározásának két szélsőséges (és sok közbülső) módja van. Az egyik szerint kiindulhatunk az <span class="emphasis"><em>S</em></span> szimbólumból, és kereshetünk egy olyan fát, amely leveleiben tartalmazza a szavakat. Ez az úgynevezett <span class="strong"><strong>fentről lefelé elemzés</strong></span> (<span class="strong"><strong>top-down parsing</strong></span>) (mivel <span class="emphasis"><em>S</em></span>-et a fa tetejére helyezzük). Másrészt kiindulhatunk a szavakból, és kereshetünk egy fát, ahol <span class="emphasis"><em>S</em></span> a gyökércsomópont. Ez a <span class="strong"><strong>lentről felfelé elemzés</strong></span> (<span class="strong"><strong>bottom-up </strong></span><span class="strong"><strong>parsing</strong></span>).<sup>[<a id="id759435" href="#ftn.id759435" class="footnote">223</a>]</sup> A fentről lefelé történő elemzés pontosan definiálható a következő keresési problémaként:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="strong"><strong>kezdeti állapot</strong></span> (<span class="strong"><strong>initial state</strong></span>) egy elemzési fa, amelynek <span class="emphasis"><em>S</em></span> a gyökércsomópontja, és egy ismeretlen gyerekcsomópontja van: [<span class="emphasis"><em>S</em></span>: ?]. Általánosságban a keresési térben minden állapot egy levezetési fa.</p></li><li class="listitem"><p>Az <span class="strong"><strong>állapotátmenet-függvény</strong></span> (<span class="strong"><strong>successor function</strong></span>) kiválasztja azt a legszélső csomópontot bal oldalon a fában, amelynek ismeretlen gyereke van. Ezek után a nyelvtanban olyan szabályokat keres, amelyek ezt a csomópontot tartalmazzák gyökérelemként. Minden ilyen szabályra generál egy következő állapotot, ahol a ? szimbólumot felcseréli a szabály jobb oldalának megfelelő listával. Például az ℰ<sub>0</sub> nyelvtanban két szabály van <span class="emphasis"><em>S</em></span>-re, így az [<span class="emphasis"><em>S</em></span>: ?] fát a következő két származtatottal cseréli le:</p></li></ul></div><p><code class="code">	[<em><span class="remark">S</span></em>:    [<em><span class="remark">S</span></em>: ?] [<em><span class="remark">Conjunction</span></em>: ?] [<em><span class="remark">S</span></em>: ?]]</code></p><p><code class="code">	[<em><span class="remark">S</span></em>:    [<em><span class="remark">NP</span></em>: ?] [<em><span class="remark">VP</span></em>: ?]]</code></p><p>A másodiknak hét származtatottja lesz, minden <span class="emphasis"><em>NP</em></span> átírási szabályhoz egy.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="strong"><strong>célteszt</strong></span> (<span class="strong"><strong>goal test</strong></span>) ellenőrzi, hogy a levezetési fa levelei pontosan megfelelnek-e a bemeneti füzérnek, nincsenek-e ismeretlenek és lefedetlen bemenetek.</p></li></ul></div><p>A fentről lefelé történő elemzés egyik nagy problémája az úgynevezett <span class="strong"><strong>bal-rekurzív szabály</strong></span>ok (<span class="strong"><strong>left-recursive rule</strong></span>s) kezelése, melyek <span class="emphasis"><em>X </em></span>→<span class="emphasis"><em> X </em></span>…<span class="emphasis"><em> </em></span>alakúak. Mélységi kereséssel egy ilyen szabály végtelen ciklusban <span class="emphasis"><em>X</em></span>-et [<span class="emphasis"><em>X</em></span>:<span class="emphasis"><em> X </em></span>…]-ra cserélné. Szélességi keresés esetén sikeresen megtaláljuk az érvényes mondatok elemzéseit, de érvénytelen mondatok esetében egy végtelen keresési térben ragadnánk le.</p><p>A lentről felfelé történő elemzés keresésként történő formalizálása a következő:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="strong"><strong>kezdeti állapot</strong></span> (<span class="strong"><strong>initial state</strong></span>) a bemeneti füzérben található szavak listája, mindegyiket egy olyan levezetési faként ábrázolva, melynek csak egy levele van, például: [<span class="strong"><strong>the</strong></span>,<span class="strong"><strong> wumpus</strong></span>,<span class="strong"><strong> is</strong></span>,<span class="strong"><strong> dead</strong></span>]. Általánosságban a keresés minden állapota levezetési fák egy listája.</p></li><li class="listitem"><p>Az <span class="strong"><strong>állapotátmenet-függvény</strong></span> (<span class="strong"><strong>successor function</strong></span>) megvizsgál minden <span class="emphasis"><em>i</em></span> pozíciót a fák listájában a nyelvtan szabályainak minden lehetséges jobb oldalán. Ha a lista <span class="emphasis"><em>i</em></span> pozíciójában kezdődő részsorozata illeszkedik a jobb oldalra, akkor a részsorozatot lecseréli egy új fára, amelynek kategóriája a szabály bal oldala, és amelynek gyerekei a részsorozat. „Illeszkedés” alatt azt értjük, hogy a csomópont kategóriája megegyezik a jobb oldal elemének kategóriájával. Például az <span class="emphasis"><em>Article </em></span>→ <span class="strong"><strong>the</strong></span> szabály illeszkedik a [<span class="strong"><strong>the</strong></span>,<span class="strong"><strong> wumpus</strong></span>,<span class="strong"><strong> is</strong></span>,<span class="strong"><strong> dead</strong></span>] első csomópontjából álló részsorozatra, így a következő állapot az [[<span class="emphasis"><em>Article</em></span>:<span class="emphasis"><em> </em></span><span class="strong"><strong>the</strong></span>],<span class="strong"><strong> wumpus</strong></span>,<span class="strong"><strong> is</strong></span>,<span class="strong"><strong> dead</strong></span>] lenne.</p></li><li class="listitem"><p>A <span class="strong"><strong>célteszt</strong></span> (<span class="strong"><strong>goal test</strong></span>) egy olyan állapotot keres, ahol egyetlen fa van, melynek gyökere az <span class="emphasis"><em>S</em></span>.</p></li></ul></div><p>A 22.5. ábra bemutat egy példát a lentről felfelé történő elemzésre.</p></div><div class="figure"><a id="id759713"/><p class="title"><strong>22.5. ábra - A „the wumpus is dead” lentről felfelé történő elemzési lépései. A szavakat tartalmazó csomópontok listájával kezdünk. Ezek után egy szabály jobb oldalára illeszkedő részsorozatokat felcserélünk egy új csomóponttal, amelynek gyökere a szabály bal oldala. Például a harmadik sorban az <span class="emphasis"><em>Article </em></span>és <span class="emphasis"><em>Noun</em></span> csomópontokat lecseréljük egy <span class="emphasis"><em>NP</em></span> csomópontra, amelynek e két csomópont lesz a gyereke. A fentről lefelé elemzés hasonló lépéseket eredményezne, de épp a fordított irányban.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-05.png" alt="A „the wumpus is dead” lentről felfelé történő elemzési lépései. A szavakat tartalmazó csomópontok listájával kezdünk. Ezek után egy szabály jobb oldalára illeszkedő részsorozatokat felcserélünk egy új csomóponttal, amelynek gyökere a szabály bal oldala. Például a harmadik sorban az Article és Noun csomópontokat lecseréljük egy NP csomópontra, amelynek e két csomópont lesz a gyereke. A fentről lefelé elemzés hasonló lépéseket eredményezne, de épp a fordított irányban."/></div></div></div><p>A lentről felfelé és a fentről lefelé történő elemzés is lehet kevéssé hatékony azon módok számossága miatt, ahogy különböző kifejezésekhez többféle elemzés rendelhető. Mindkettő elpazarolhatja az időt a keresési tér irreleváns részeinek vizsgálatával. A fentről lefelé keresés generálhat olyan közbülső csomópontokat, amelyek sosem zárhatók le szavakkal, és a lentről felfelé keresés generálhat olyan részleges elemzéseket a szavakhoz, amelyek nem fordulhatnak elő egy <span class="emphasis"><em>S</em></span>-ben sem.</p><p>Még ha lenne is egy tökéletes heurisztikánk, amely lehetővé tenné az irreleváns kitérők nélküli keresést, ezek az algoritmusok akkor sem lennének hatékonyak, mivel bizonyos mondatoknak <span class="emphasis"><em>exponenciálisan sok</em></span> levezetési fája van. A következő alfejezet megmutatja, hogy mit kezdhetünk ezzel a problémával.</p><div class="section" title="Hatékony elemzés"><div class="titlepage"><div><div><h2 class="title"><a id="id759745"/>Hatékony elemzés</h2></div></div></div><p>Vizsgáljuk meg a következő két mondatot:</p><p>Have the students in section 2 of Computer Science 101 take the exam.</p><p>Have the students in section 2 of Computer Science 101 taken the exam?</p><p>Bár az első 10 szavuk közös, teljesen különböző levezetésük van, mivel az első egy felszólítás, a második egy kérdés. Egy balról jobbra elemző algoritmusnak tippelnie kellene, hogy az első szó egy felszólítás vagy egy kérdés része-e, és nem tudná megmondani, hogy a tipp helyes-e egészen a tizenegyedik szóig: <span class="emphasis"><em>take </em></span>vagy <span class="emphasis"><em>taken</em></span>. Ha az algoritmus rosszul tippelt, egészen az első szóig kellene visszalépnie. Az ilyen típusú visszalépés elkerülhetetlen, de ha azt szeretnénk, hogy az algoritmusunk hatékony legyen, akkor el kell kerülnie a „the students in section 2 of Computer Science 101” <span class="emphasis"><em>NP</em></span>-ként történő újraelemzését minden alkalommal, amikor visszalép.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Ebben a részben egy olyan algoritmust alakítunk ki, amely ezt a hatékonysági problémát kezelni tudja. Az alapötlet a <span class="strong"><strong>dinamikus programozás</strong></span> (<span class="strong"><strong>dynamic programming</strong></span>) egy példája: <span class="emphasis"><em>minden alkalommal, amikor egy részfüzért elemzünk, tárold az eredményt, így később majd nem kell újraelemeznünk.</em></span> Például ha egyszer rájöttünk, hogy a „the students in section 2 of Computer Science 101” egy <span class="emphasis"><em>NP</em></span>, ezt eltárolhatjuk egy <span class="strong"><strong>diagram</strong></span>nak (<span class="strong"><strong>chart</strong></span>) nevezett adatstruktúrában. Az így működő algoritmusokat <span class="strong"><strong>diagramelemző</strong></span>knek (<span class="strong"><strong>chart parser</strong></span>s) nevezik. Mivel környezetfüggetlen nyelvtanokkal foglalkozunk, a keresési tér egy ágának kontextusában talált tetszőleges kifejezés éppúgy szerepelhet a keresési tér bármilyen más ágában is.</p></div><p>Egy <span class="emphasis"><em>n</em></span> szóból álló mondat diagramja <span class="emphasis"><em>n</em></span> + 1 <span class="strong"><strong>csomópont</strong></span>ból (<span class="strong"><strong>vertex</strong></span>) és számos, ezeket összekötő <span class="strong"><strong>él</strong></span>ből (<span class="strong"><strong>edges</strong></span>) áll. A 22.6. ábrán láthatunk egy diagramot hat csomóponttal (körök) és három éllel (vonalak). Például a</p><p><code class="code">[0, 5, <em><span class="remark">S</span></em> → <em><span class="remark">NP VP</span></em> •]</code></p><p>címkéjű él azt jelenti, hogy egy <span class="emphasis"><em>NP</em></span>-t egy <span class="emphasis"><em>VP</em></span> követ, és együtt alkotnak egy <span class="emphasis"><em>S</em></span>-et, mely a 0-tól 5-ig terjedő karaktersorozatot fedi le. Egy élben található • jel elválasztja a már megtaláltat a még keresettől.<sup>[<a id="id759861" href="#ftn.id759861" class="footnote">224</a>]</sup><sup> </sup>A • jellel záródó éleket <span class="strong"><strong>teljes él</strong></span>eknek (<span class="strong"><strong>complete edge</strong></span>s) nevezik. A</p><p><code class="code">[0, 2, <em><span class="remark">S</span></em> → <em><span class="remark">NP</span></em> • <em><span class="remark">VP</span></em>]</code></p><p>él szerint egy <span class="emphasis"><em>NP</em></span> lefedi a 0-tól 2-ig terjedő karaktersorozatot (az első két szó), és ha tudunk találni egy ezt követő <span class="emphasis"><em>VP</em></span>-t, akkor lenne egy <span class="emphasis"><em>S</em></span>-ünk. Az ilyen élek, ahol a pont a végük előtt van, úgynevezett befejezetlen (nem teljes) élek, és azt mondjuk, hogy az él egy <span class="emphasis"><em>VP</em></span>-t vár.</p><div class="figure"><a id="id759921"/><p class="title"><strong>22.6. ábra - A „The agent feels a breeze” mondat diagramjának egy részlete. Mind a hat csomópont látható, de csak három él szerepel azok közül, melyek teljes elemzést eredményeznének.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-06.png" alt="A „The agent feels a breeze” mondat diagramjának egy részlete. Mind a hat csomópont látható, de csak három él szerepel azok közül, melyek teljes elemzést eredményeznének."/></div></div></div><p>A 22.7. ábra a diagramelemző algoritmust szemlélteti. A lényege a fentről lefelé és a lentről felfelé legjobb tulajdonságainak ötvözése. A <code class="code">JÓSLÓ</code> eljárás fentről lefelé működik: olyan bejegyzéseket helyez el a diagramban, amelyek megmondják, hogy milyen szimbólumok milyen helyszínen elvártak. A <code class="code">SZKENNER</code> egy lentről felfelé eljárás, amely a szavakból indul ki, de egy szót csak egy meglevő diagrambejegyzés kiegészítésére használ fel. Hasonlóképpen a <code class="code">KITERJESZTŐ</code> a komponenseket lentről felfelé építi, de csak egy meglevő diagrambejegyzést egészít ki.</p><p>Egy trükköt alkalmaztunk a teljes algoritmus elindításához: hozzáadtunk egy [0, 0, <span class="emphasis"><em>S'</em></span> → • <span class="emphasis"><em>S</em></span>] élet a diagramhoz, ahol <span class="emphasis"><em>S</em></span> a nyelvtan kezdeti szimbóluma, <span class="emphasis"><em>S' </em></span>pedig egy általunk most kitalált új szimbólum. Az <code class="code">ÉL-HOZZÁAD</code> meghívása azt eredményezi, hogy a <code class="code">JÓSLÓ</code> éleket ad az olyan szabályokhoz, melyek <span class="emphasis"><em>S</em></span>-t eredményezhetnek, azaz [<span class="emphasis"><em>S</em></span> → <span class="emphasis"><em>NP VP</em></span>]. Ezek után megvizsgáljuk ezen szabály első alkotóelemét, <span class="emphasis"><em>NP</em></span>-t, és mindenféle módon olyan szabályokat adunk hozzá, melyek <span class="emphasis"><em>NP</em></span>-t eredményeznek. Végső soron a <code class="code">JÓSLÓ</code> fentről lefelé módon minden lehetséges élt hozzáad, ami felhasználható a végső <span class="emphasis"><em>S</em></span> megalkotásában.</p><div class="figure"><a id="id759995"/><p class="title"><strong>22.7. ábra - A diagramelemző algoritmus. <span class="emphasis"><em>S</em></span> a kezdő szimbólum és <span class="emphasis"><em>S' </em></span>egy új nem záró szimbólum, <span class="emphasis"><em>diagram</em></span>[<span class="emphasis"><em>j</em></span>] pedig azon élek listája, melyek a <span class="emphasis"><em>j</em></span> csomópontban végződnek. A görög ábécé betűi nulla vagy több szimbólumból álló füzérekre illeszkednek.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-07.png" alt="A diagramelemző algoritmus. S a kezdő szimbólum és S' egy új nem záró szimbólum, diagram[j] pedig azon élek listája, melyek a j csomópontban végződnek. A görög ábécé betűi nulla vagy több szimbólumból álló füzérekre illeszkednek."/></div></div></div><p>Amikor <span class="emphasis"><em>S'</em></span> jóslója készen van, belépünk egy ciklusba, amely meghívja a <code class="code">SZKENNER</code>-t a mondat minden egyes szavára. Ha a <span class="emphasis"><em>j</em></span> pozícióban álló szó egy <span class="emphasis"><em>B</em></span> kategória tagja, amit valamelyik él keres a <span class="emphasis"><em>j</em></span> pozícióban, akkor kiterjesztjük azt az élet megjelölve a szót, mint <span class="emphasis"><em>B</em></span> egy példányát. Vegyük észre, hogy a <code class="code">SZKENNER</code> minden egyes meghívása végződhet a <code class="code">JÓSLÓ</code> és a <code class="code">KITERJESZTŐ</code> rekurzív meghívásával, ily módon ötvözve a fentről lefelé és a lentről felfelé feldolgozást.</p><p>A másik lentről felfelé komponens, a <code class="code">KITERJESZTŐ</code><sup>[<a id="id760065" href="#ftn.id760065" class="footnote">225</a>]</sup> vesz egy teljes élt, amelynek bal oldalán <span class="emphasis"><em>B</em></span> van, és felhasználja a diagramban levő bármely nem teljes szabály kiterjesztésére, amely ott végződik, ahol a teljes él kezdődik, ha a nem teljes szabály egy <span class="emphasis"><em>B</em></span>-re vár.</p><p>A 22.8. és 22.9. ábrák mutatják az „I feel it” mondat (amely a „Do you feel a breeze?” kérdésre adott válasz) diagramját és elemzési lépéseit. Tizenhárom él (a–m jelekkel ellátva) szerepel a diagramon, melyek közül öt teljes (a diagram verticei csomópontjai felett) és nyolc befejezetlen (alattuk). Vegyük észre a <code class="code">JÓSLÓ</code>, <code class="code">SZKENNER</code> és <code class="code">KITERJESZTŐ</code> akciók ciklusát. Például a Jósló felhasználja azt a tényt, hogy az „a” él egy <span class="emphasis"><em>S</em></span>-t vár ahhoz, hogy megelőlegezze egy <span class="emphasis"><em>NP</em></span> („b” él) és egy <span class="emphasis"><em>Pronoun</em></span> („c” él) jóslatát. Ezek után a <code class="code">SZKENNER</code> felismeri, hogy van egy <span class="emphasis"><em>Pronoun</em></span> a megfelelő helyen („d” él), és a <code class="code">KITERJESZTŐ</code> kombinálja a „b” nem teljes élt a „d” teljes éllel, így előállítva egy új élt, „e”-t.</p><div class="figure"><a id="id760121"/><p class="title"><strong>22.8. ábra - Az „<sub>0</sub> I <sub>1</sub> feel <sub>2</sub> it <sub>3</sub>” mondat diagramelemzése. Az <span class="emphasis"><em>m</em></span>:<span class="emphasis"><em>S</em></span> jelölés azt jelenti, hogy az <span class="emphasis"><em>m</em></span> élnek egy <span class="emphasis"><em>S</em></span> áll a jobb oldalán, míg az <span class="emphasis"><em>f:VP/Verb</em></span> azt, hogy az <span class="emphasis"><em>f</em></span> élnek <span class="emphasis"><em>VP </em></span>van a bal oldalán, de egy <span class="emphasis"><em>Verb</em></span>-et vár. Öt teljes él van a csomópontok felett, és nyolc hiányos alattuk.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-08.png" alt="Az „0 I 1 feel 2 it 3” mondat diagramelemzése. Az m:S jelölés azt jelenti, hogy az m élnek egy S áll a jobb oldalán, míg az f:VP/Verb azt, hogy az f élnek VP van a bal oldalán, de egy Verb-et vár. Öt teljes él van a csomópontok felett, és nyolc hiányos alattuk."/></div></div></div><p>A diagramelemző algoritmus elkerüli az élek nagy halmazának építését, amit az egyszerű lentről felfelé eljárás végigvizsgált volna. Vegyük a „The ride the horse gave was wild” mondatot. Egy lentről felfelé elemzés megjelölné a „ride the horse”-t mint egy <span class="emphasis"><em>VP</em></span>-t, majd elvetné az elemzési fát, amint rájönne, hogy nem illeszkedik egy nagyobb <span class="emphasis"><em>S</em></span>-be. Azonban az ℰ<sub>0</sub> nem engedi meg, hogy egy <span class="emphasis"><em>VP</em></span> a „the”-t kövesse, így a diagramelemző algoritmus sosem jósol <span class="emphasis"><em>VP</em></span>-t ezen a ponton, így elkerüli ott a <span class="emphasis"><em>VP</em></span> szerkezet időpocsékoló építését. Azokat az algoritmusokat, melyek balról jobbra működnek, és elkerülik ezen lehetetlen szerkezetek felépítését, <span class="strong"><strong>balsarok-elemző</strong></span>knek (<span class="strong"><strong>left-corner parser</strong></span>s) nevezzük, mivel egy olyan elemzési fát építenek fel, amely a nyelvtan kezdő szimbólumával indul, és a mondat legszélén balra (a bal sarokban) álló szó felé terjeszkednek. Egy élt csak akkor adnak a diagramhoz, ha ezen elemzési fa kiterjesztését szolgálhatja (példaként lásd 22.10. ábra).</p><div class="figure"><a id="id760686"/><p class="title"><strong>22.9. ábra - Az „<sub>0</sub> I <sub>1</sub> feel <sub>2</sub> it <sub>3</sub>.” elemzési lépései. Az a–m élek mindegyikére megmutatjuk azt az eljárást, amit az él más, a diagramon már szereplő élekből történő származtatására használtunk. Bizonyos éleket a rövidség érdekében elhagytunk.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-09.png" alt="Az „0 I 1 feel 2 it 3.” elemzési lépései. Az a–m élek mindegyikére megmutatjuk azt az eljárást, amit az él más, a diagramon már szereplő élekből történő származtatására használtunk. Bizonyos éleket a rövidség érdekében elhagytunk."/></div></div></div><div class="figure"><a id="id760710"/><p class="title"><strong>22.10. ábra - Egy balsarok-elemző algoritmussal elkerülhető a „ride” szóval kezdődő <span class="emphasis"><em>VP</em></span> jóslása, de jósolni fog egy „was” szóval kezdődő <span class="emphasis"><em>VP</em></span>-t, mivel a nyelvtan egy <span class="emphasis"><em>NP</em></span>-t követő <span class="emphasis"><em>VP</em></span>-t vár. A „the horse gave” feletti háromszög azt jelenti, hogy a szavaknak van egy <span class="emphasis"><em>RelCause</em></span> elemzésük, amihez azonban közvetlenül további részek kapcsolódnak, amik nem láthatók.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/22-10.png" alt="Egy balsarok-elemző algoritmussal elkerülhető a „ride” szóval kezdődő VP jóslása, de jósolni fog egy „was” szóval kezdődő VP-t, mivel a nyelvtan egy NP-t követő VP-t vár. A „the horse gave” feletti háromszög azt jelenti, hogy a szavaknak van egy RelCause elemzésük, amihez azonban közvetlenül további részek kapcsolódnak, amik nem láthatók."/></div></div></div><p>A diagramelemző csak polinomiális idő- és tárigényű. <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>kn</em></span><sup>2</sup>)<span class="emphasis"><em> </em></span>helyet igényel az élek tárolására, ahol <span class="emphasis"><em>n </em></span>a mondatban levő szavak száma és <span class="emphasis"><em>k</em></span> egy, a nyelvtantól függő konstans. Amikor már nem tud több élt építeni, megáll, így tudjuk, hogy az algoritmus befejeződött (még akkor is, ha vannak bal-rekurzív szabályok). Valójában <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>3</sup>) időt igényel legrosszabb esetben, ami a legjobb, amit elérhetünk környezetfüggetlen nyelvtanokra. A <code class="code">DIAGRAMELEMZŐ</code> szűk keresztmetszete a <code class="code">KITERJESZTŐ</code>, amelynek meg kell próbálnia kiterjeszteni a <span class="emphasis"><em>j</em></span>-ben végződő <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) nem teljes él mindegyikét az ugyanott kezdődő <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) teljes él mindegyikével, <span class="emphasis"><em>j </em></span>lehetséges <span class="emphasis"><em>n</em></span> + 1 különböző értékére. Ezeket összeszorozva kapjuk <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>3</sup>)-at. Ez egyfajta paradoxont ad a számunkra: hogyan tud egy <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>3</sup>) algoritmus visszaadni egy választ, amely exponenciális számosságú elemzési fát tartalmazhat? Vegyünk egy példát: a</p><p>„Fall leaves fall and spring leaves spring”</p><p>mondat többértelmű, mivel minden egyes szó (az „and” kivételével) lehet főnév és ige is, valamint a „fall” és a „spring” lehet melléknév is. Ennek a mondatnak mindösszesen négy elemzése van:<sup>[<a id="id760828" href="#ftn.id760828" class="footnote">226</a>]</sup></p><p><code class="code">[<em><span class="remark">S</span></em>: [<em><span class="remark">S</span></em>: [<em><span class="remark">NP</span></em>: Fall leaves] fall] and [<em><span class="remark">S</span></em>: [<em><span class="remark">NP</span></em>: spring leaves] spring]</code></p><p><code class="code">[<em><span class="remark">S</span></em>: [<em><span class="remark">S</span></em>: [<em><span class="remark">NP</span></em>: Fall leaves] fall] and [<em><span class="remark">S</span></em>: spring [<em><span class="remark">VP</span></em>: leaves spring]]</code></p><p><code class="code">[<em><span class="remark">S</span></em>: [<em><span class="remark">S</span></em>: Fall [<em><span class="remark">VP</span></em>: Fall leaves] fall] and [<em><span class="remark">S</span></em>: [<em><span class="remark">NP</span></em>: spring leaves] spring]</code></p><p><code class="code">[<em><span class="remark">S</span></em>: [<em><span class="remark">S</span></em>: Fall [<em><span class="remark">VP</span></em>: Fall leaves] fall] and [<em><span class="remark">S</span></em>: spring [<em><span class="remark">VP</span></em>: leaves spring]]</code></p><p>Ha <span class="emphasis"><em>n</em></span> többértelmű összekapcsolt részmondatunk lett volna, akkor 2<sup>n</sup> módon választhatnánk elemzést a részmondatokra.<sup>[<a id="id760936" href="#ftn.id760936" class="footnote">227</a>]</sup> Hogyan kerüli el a diagramelemző az exponenciális feldolgozási időt? Két választ is adhatunk a kérdésre. Először is, a <code class="code">DIAGRAMELEMZŐ</code> algoritmus maga valójában egy <span class="emphasis"><em>felismerő,</em></span> nem egy elemző. Ha van egy [0, <span class="emphasis"><em>n</em></span>, <span class="emphasis"><em>S</em></span> → <span class="emphasis"><em>α </em></span>•] alakú teljes él a diagramon, akkor felismertünk egy <span class="emphasis"><em>S</em></span>-t. Az elemzési fa előállítását ebből az élből nem tekintjük a <code class="code">DIAGRAMELEMZŐ</code> feladatának, de elvégezhető. Vegyük észre, hogy a <code class="code">KIBŐVÍTŐ</code> utolsó sorában <span class="emphasis"><em>α</em></span>-t élek <span class="emphasis"><em>e<sub>B</sub></em></span> listájaként építjük fel, nemcsak kategória nevek listájaként. Így egy él elemzési fává történő átalakításához egyszerűen az összetevő éleket kell rekurzív módon végignézni, minden egyes [<span class="emphasis"><em>i</em></span>, <span class="emphasis"><em>j</em></span>, <span class="emphasis"><em>X</em></span> → <span class="emphasis"><em>α</em></span> •] élt egy [<span class="emphasis"><em>X </em></span>: <span class="emphasis"><em>α</em></span>] fává átalakítva. Ez egyenes/közvetlen módszer, de csak <span class="emphasis"><em>egy </em></span>elemzési fát ad.</p><p>A második válasz szerint ha minden lehetséges elemzést szeretnénk, akkor mélyebbre kell ásnunk a diagramban. Miközben az [<span class="emphasis"><em>i</em></span>, <span class="emphasis"><em>j</em></span>, <span class="emphasis"><em>X</em></span> → <span class="emphasis"><em>α</em></span> •] élt egy [<span class="emphasis"><em>X </em></span>: <span class="emphasis"><em>α</em></span>] fává átalakítjuk, azt is megvizsgáljuk, hogy van-e másik, [<span class="emphasis"><em>i</em></span>, <span class="emphasis"><em>j</em></span>, <span class="emphasis"><em>X</em></span> → <span class="emphasis"><em>β</em></span> •] alakú él. Amennyiben van, ezek az élek további elemzési fákat generálnak. Így kapjuk azt a választási lehetőséget, hogy mit is kezdjünk velük. Felsorolhatjuk az összes lehetőséget, ami azt jelenti, hogy a paradoxont feloldanánk, és exponenciálisan sok időre lenne szükségünk az összes elemzés felsorolásához. Vagy továbbvihetjük a rejtélyt egy kicsit és az elemzéseket egy <span class="strong"><strong>tömörített erdő</strong></span> (<span class="strong"><strong>packed forest</strong></span>) nevű struktúrával reprezentálhatjuk, amely a következőképpen néz ki:</p><p><span class="inlinemediaobject"><img src="math/mi-22-0001.gif" alt="Egy balsarok-elemző algoritmussal elkerülhető a „ride” szóval kezdődő VP jóslása, de jósolni fog egy „was” szóval kezdődő VP-t, mivel a nyelvtan egy NP-t követő VP-t vár. A „the horse gave” feletti háromszög azt jelenti, hogy a szavaknak van egy RelCause elemzésük, amihez azonban közvetlenül további részek kapcsolódnak, amik nem láthatók."/></span></p><p>A lényeg az, hogy minden csomópont lehet egy hagyományos elemzési fa csomópont, illetve csomópontok egy halmaza is. Ez lehetővé teszi számunkra, hogy exponenciális számú elemzést reprezentáljunk polinomiális időben és tárhelyen. Természetesen <span class="emphasis"><em>n</em></span> = 2 esetén nincs sok különbség 2<sup>n</sup> és 2<span class="emphasis"><em>n</em></span> között, de nagy <span class="emphasis"><em>n</em></span>-ekre egy ilyen reprezentáció jelentős megtakarítást eredményez. Sajnálatos módon ez az egyszerű tömörített erdő megközelítés nem kezeli az összes <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>!) lehetőséget a kapcsolódások összerendelésére. Maxwell és Kaplan (1995) megmutatja, hogy egy, az igazság-karbantartó rendszerek alapelveire épülő, összetettebb reprezentáció ezeket a fákat még jobban összetömörítheti.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id759435" href="#id759435" class="para">223</a>] </sup> Észrevehető, hogy a fentről lefelé és a lentről felfelé történő elemzés hasonló az előre-, illetve hátrafelé következtetéshez, amiket a 7. fejezetben írtunk le. Hamarosan látni fogjuk, hogy ez az analógia pontos.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id759861" href="#id759861" class="para">224</a>] </sup> A • miatt nevezik az éleket néha <span class="strong"><strong>pontozott szabály</strong></span>oknak (<span class="strong"><strong>dotted rule</strong></span>s).</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id760065" href="#id760065" class="para">225</a>] </sup> A <code class="code">KITERJESZTŐ</code> eljárásunkat tradicionálisan <code class="code">TELJESSÉ-TEVŐ</code>-nek hívták. Ez a név félrevezető, mivel az eljárás nem fejez be éleket: bemenetként vesz egy teljes élt, és kiterjeszt nem teljes éleket.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id760828" href="#id760828" class="para">226</a>] </sup> Az [<span class="emphasis"><em>S</em></span>: Fall [<span class="emphasis"><em>VP</em></span>: leaves fall]] elemzés megegyezik az „Autumn abandons autumn” mondattal.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id760936" href="#id760936" class="para">227</a>] </sup> Emellett a komponensek összekapcsolódásának <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>!) <span class="emphasis"><em>számú </em></span>értelmezése lenne – például (<span class="emphasis"><em>X</em></span> és (<span class="emphasis"><em>Y</em></span> és <span class="emphasis"><em>Z</em></span>)), illetve ((<span class="emphasis"><em>X</em></span> és <span class="emphasis"><em>Y</em></span>) és <span class="emphasis"><em>Z</em></span>). De ez már egy másik történet, amelyet Church és Patil (1982) igen jól mesél el.</p></div></div></div></body></html>
