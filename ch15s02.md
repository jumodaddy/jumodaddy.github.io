<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Következtetés időbeli modellekben"><div class="titlepage"><div><div><h1 class="title"><a id="id689314"/>Következtetés időbeli modellekben</h1></div></div></div><p>Egy általános időbeli modellstruktúra kidolgozása után, most már megfogalmazhatjuk a megoldandó alapvető következtetési feladatokat:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Szűrés</strong></span> (<span class="strong"><strong>filtering</strong></span>) vagy <span class="strong"><strong>ellenőrző megfigyelés</strong></span> (<span class="strong"><strong>monitoring</strong></span>). Ez a <span class="strong"><strong>bizonyossági </strong></span><span class="strong"><strong>állapot</strong></span> (<span class="strong"><strong>belief state</strong></span>) kiszámításának a feladata – ami a jelenlegi állapot feletti a posteriori eloszlás, az adott időpontig vett összes bizonyíték ismeretében. Azaz szeretnénk kiszámítani a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>t</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) mennyiséget, feltéve, hogy a bizonyítékok folyamatos sorozatban érkeznek kezdve a <span class="emphasis"><em>t </em></span>= 1 időponttól. Az esernyős példában ez az aznapi eső valószínűségének a kiszámítását jelentené, az esernyőhordozó eddigi összes megfigyelésének az ismeretében. A szűrés az, amit egy racionális ágensnek el kell végeznie ahhoz, hogy a jelenlegi állapotot követni tudja, és így racionális döntéseket hozhasson (lásd 17. fejezet). Kiderül, hogy majdnem azonos számítás szolgáltatja a bizonyítéksorozat megfigyelésének a <span class="strong"><strong>valószínűség</strong></span>ét (<span class="strong"><strong>likelihood</strong></span>), <span class="emphasis"><em>P</em></span>(<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>)-t.</p></li><li class="listitem"><p><span class="strong"><strong>Előrejelzés</strong></span> (<span class="strong"><strong>prediction</strong></span>). Ez egy <span class="emphasis"><em>jövőbeli</em></span> állapot feletti a posteriori<span class="emphasis"><em> </em></span>eloszlás kiszámításának a feladata, az adott időpontig vett összes bizonyíték ismeretében. Azaz, szeretnénk kiszámítani a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub><span class="emphasis"><em>t</em></span>+<span class="emphasis"><em>k</em></span></sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) mennyiséget valamely <span class="emphasis"><em>k </em></span>&gt; 0 esetén. Az esernyős példában ez jelentheti az eső valószínűségének a kiszámítását három napra előre, az esernyőhordozó eddigi összes megfigyelésének az ismeretében. Az előrejelzés hasznos a cselekedetek lehetséges sorozatainak a kiértékelésében.</p></li><li class="listitem"><p><span class="strong"><strong>Simítás</strong></span> (<span class="strong"><strong>smoothing</strong></span>) vagy <span class="strong"><strong>visszatekintés</strong></span> (<span class="strong"><strong>hindsight</strong></span>). Ez egy múltbeli állapot feletti a posteriori eloszlás kiszámításának a feladata, a jelen időpontig vett összes bizonyíték ismeretében. Azaz szeretnénk kiszámítani a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>k</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) mennyiséget valamely 0  ≤ <span class="emphasis"><em>k</em></span> &lt; <span class="emphasis"><em>t</em></span> esetén. Az esernyős példában ez jelentheti az eső valószínűségének a kiszámítását múlt szerdára, ha ismerjük az esernyőhordozónak a mai napig történő összes megfigyelését. A visszatekintés az állapotnak egy jobb becslését adja, mint ami akkor elérhető volt, mivel több bizonyítékot használ fel.</p></li><li class="listitem"><p><span class="strong"><strong>Legvalószínűbb magyarázat</strong></span> (<span class="strong"><strong>most likely explanation</strong></span>). A megfigyelések egy sorozatának ismeretében lehet, hogy szeretnénk megtalálni azt az állapotsorozatot, ami a leginkább valószínű, hogy az adott  megfigyeléseket generálta. Azaz szeretnénk kiszámítani az <span class="inlinemediaobject"><img src="math/mi-15-0002.gif" alt="Következtetés időbeli modellekben"/></span> <span class="emphasis"><em>P</em></span>(<span class="strong"><strong>x</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) értékét. Például ha az esernyő feltűnik az első három nap mindegyikén, és hiányzik a negyediken, akkor a legvalószínűbb magyarázat az, hogy az első három napon esett és a negyediken nem esett. Az erre a feladatra szolgáló algoritmusok számos alkalmazásban hasznosak, ideértve a beszédfelismerést – ahol a cél a szavak legvalószínűbb sorozatának a megtalálása hangok sorozatának ismeretében – és egy zajos csatornán továbbított bináris szekvenciák rekonstrukcióját.</p></li></ul></div><p>Ezeken a feladatokon túl szükség van még módszerekre az állapotátmenet- és érzékelő modellek megfigyelésekből<span class="emphasis"><em> </em></span>történő <span class="emphasis"><em>megtanulására</em></span>. Csakúgy, mint a statikus Bayes-hálóknál, a dinamikus Bayes-hálós tanulás elvégezhető mint a következtetés mellékterméke. A következtetés egy becslést ad arra, hogy milyen átmenetek következtek be valójában, és milyen állapotok generálták az érzékelők értékeit, és ezek a becslések felhasználhatók a modell frissítésére. A frissített modellek jobb becsléseket adnak, és a folyamat a konvergálásig iterálódik. A teljes folyamat a várhatóérték-maximálás vagy <span class="strong"><strong>EM algoritmus</strong></span> egy esete (lásd 20.3. alfejezet). Figyelemre méltó részlet, hogy a tanulás teljes simítós következtetést igényel szűrés helyett, mivel ez jobb becsléseket ad a folyamat állapotára. Lehet, hogy a szűréssel való tanulás nem konvergál helyesen; gondoljunk például a gyilkosságok felderítésének a megtanulására: a visszatekintés <span class="emphasis"><em>mindig</em></span> szükséges annak kikövetkeztetéséhez a megfigyelhető bizonyítékok alapján, hogy mi történt a gyilkosság helyszínén.</p><p>Az előző szakaszban felsorolt négy következtetési feladatot megoldó algoritmusok először leírhatók általános szinten, függetlenül az alkalmazott modell konkrét típusától. Az egyes modellekhez igazodó javításokat a következő fejezetekben ismertetjük.</p><div class="section" title="Szűrés és előrejelzés"><div class="titlepage"><div><div><h2 class="title"><a id="id690663"/>Szűrés és előrejelzés</h2></div></div></div><p>Kezdjük a szűréssel. Megmutatjuk, hogy ez menet közben egyszerűen, online módon elvégezhető: a <span class="emphasis"><em>t</em></span>-edik időpillanatig tartó szűrés eredményét ismerve, a <span class="emphasis"><em>t + </em></span>1-edik időpillanatra az eredmény könnyen kiszámítható az új <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1 </sub>bizonyítékból. Azaz</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em>+1</sub>) = <em><span class="remark">f</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>,<em><span class="remark"> P</span></em>(<em><span class="remark">X</span></em><sub>t</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>))</code></p><p>valamely <span class="emphasis"><em>f</em></span> függvénnyel. Ezt a folyamatot gyakran nevezik <span class="strong"><strong>rekurzív becslés</strong></span>nek (<span class="strong"><strong>recursive estimation</strong></span>). Tekinthetjük a számítást úgy, mint ami valójában két részből áll: elsőként a jelenlegi állapot eloszlását terjesztjük előre <span class="emphasis"><em>t</em></span>-ről <span class="emphasis"><em>t </em></span>+ 1-re; azután fogjuk frissíteni, felhasználva az új <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1 </sub>bizonyítékot. Ez a kétlépéses folyamat elég egyszerűen alakul:</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark"><em><span class="remark">X</span></em></span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em>+1</sub>) = <em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:t</sub>, <em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>)		(felosztva a bizonyítékot)</code></p><p><code class="code">	=<em><span class="remark"> </span></em>α <em><span class="remark">P</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">t+</span></em>1</sub>|<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>, <em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>) <em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>)	(a Bayes-szabályt használva)</code></p><p><code class="code">	=<em><span class="remark"> </span></em>α <em><span class="remark">P</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>) <em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub><em><span class="remark">t</span></em>+1</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>)	(a bizonyíték Markov-tulajdonsága miatt)</code></p><a id="ID_633_oldal"/><p>Itt és végig a fejezetben, az α egy normalizációs konstans, ami a valószínűségek 1-re összegzését biztosítja. A második tényező <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) reprezentálja a következő állapot egylépéses előrejelzését, és az első tényező ezt frissíti az új bizonyítékkal. Vegyük észre, hogy <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>|<span class="strong"><strong>X</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>) közvetlenül kinyerhető az érzékelő modellből. Most a jelenlegi <span class="bold"><strong>X<sub>t </sub></strong></span>állapotot feltételnek véve a következő állapot egylépéses előrejelzéséhez jutunk:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0003.gif" alt="Szűrés és előrejelzés"/></span> (kihasználva a Markov-tulajdonságot)(15.3)</p><p>Az összegzésen belül az első tényező egyszerűen az állapotátmenet-modell és a második a jelenlegi állapot eloszlása. Így megvan a kívánt rekurzív képlet. A szűrt <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>t</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) becslésre úgy gondolhatunk, mint egy <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>t</em></span> </sub>„üzenetre”, amit előre terjesztünk végig a sorozaton, minden átmenetnél az új megfigyeléssel módosítva és frissítve. A folyamat</p><p><code class="code"><em><span class="remark">f</span></em><sub>1:<em><span class="remark">t</span></em>+1 </sub>= α Előre(<em><span class="remark">f</span></em><sub>1:<em><span class="remark">t</span></em></sub>, <em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>)</code></p><p>ahol az <code class="code">ELŐRE</code> a (15.3) egyenlet által leírt frissítést hajtja végre.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Ha az összes állapotváltozó diszkrét, minden frissítés ideje állandó (azaz <span class="emphasis"><em>t</em></span>-től független), és a tárigény is állandó. (Ezek az állandók természetesen függnek az állapottér méretétől és a tárgyalt időbeli modell konkrét típusától.) <span class="emphasis"><em>A frissítés idő- és tárigényének állandónak kell lennie, ha egy korlátos memóriájú ágensnek követnie kell az aktuális állapot eloszlását a megfigyelések egy korlátlan sorozata esetén.</em></span></p></div><p>Mutassuk be a szűrési folyamatot két lépésen keresztül az alap esernyős példában (lásd 15.2. ábra). Feltesszük, hogy a biztonsági őrünknek van valamilyen a priori hite, hogy a 0. napon esett-e, éppen azelőtt, hogy a megfigyelések sorozata elkezdődik. Tegyük fel, hogy ez <span class="strong"><strong>P</strong></span>(<span class="emphasis"><em>R</em></span><sub>0</sub>) = 〈0,5, 0,5 〉. Most a két megfigyelést a következőképpen dolgozzuk fel:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Az 1. napon az esernyő feltűnik, így <span class="emphasis"><em>U</em></span><sub>1</sub> = <span class="emphasis"><em>igaz</em></span>. Az előrejelzés <span class="emphasis"><em>t</em></span> = 0-ról <span class="emphasis"><em>t</em></span> = 1-re</p></li></ul></div><p><span class="inlinemediaobject"><img src="math/mi-15-0004.gif" alt="Szűrés és előrejelzés"/></span></p><p>és a <span class="emphasis"><em>t</em></span> = 1-beli bizonyítékkal való frissítés azt adja, hogy</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>1</sub>|<em><span class="remark">u</span></em><sub>1</sub>) = α<em><span class="remark">P</span></em>(<em><span class="remark">u</span></em><sub>1</sub>|<em><span class="remark">R</span></em><sub>1</sub>) <em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>1</sub>) = α〈0,9, 0,2〉〈0,5, 0,5〉</code></p><p><code class="code">	= α〈0,45, 0,1〉 ≈ 〈0,818, 0,182〉</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A 2. napon az esernyő feltűnik, így <span class="emphasis"><em>U</em></span><sub>2 </sub>= <span class="emphasis"><em>igaz.</em></span> Az előrejelzés <span class="emphasis"><em>t </em></span>= 1-ről <span class="emphasis"><em>t </em></span>= 2-re</p></li></ul></div><p><span class="inlinemediaobject"><img src="math/mi-15-0005.gif" alt="Szűrés és előrejelzés"/></span></p><p>a <span class="emphasis"><em>t </em></span>= 2-beli bizonyítékkal való frissítés pedig azt adja, hogy</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>2</sub>|<em><span class="remark">u</span></em><sub>1</sub><em><span class="remark">, u</span></em><sub>2</sub>) = α<em><span class="remark">P</span></em>(<em><span class="remark">u</span></em><sub>2</sub>|<em><span class="remark">R</span></em><sub>2</sub>)<em><span class="remark"> P</span></em>(<em><span class="remark">R</span></em><sub>2</sub>|<em><span class="remark">u</span></em><sub>1</sub>) = α〈0,9, 0,2〉 〈0,627, 0,373〉</code></p><p><code class="code">	= α〈0,565, 0,075〉 ≈ 〈0,883, 0,117〉</code></p><p>Érzésünk szerint az eső valószínűsége azért növekedett az 1. napról a 2. napra, mert az eső folytatódik. A 15.2. (a) feladat ennek a tendenciának a további vizsgálatát kéri.</p><p>Az előrejelzés feladatát tekinthetjük egyszerűen szűrésnek új bizonyíték hozzáadása nélkül. Valójában a szűrési folyamat már magában foglal egy egylépéses előrejelzést és könnyen származtatható a következő rekurzív számítás a <span class="emphasis"><em>t </em></span>+ <span xml:lang="pt-BR" class="emphasis"><em>k </em></span>+ 1 állapot előrejelzésére a <span class="emphasis"><em>t </em></span>+ <span class="emphasis"><em>k</em></span> előrejelzéséből:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0007.gif" alt="Szűrés és előrejelzés"/></span></p><p>Természetesen ez a számítás csak az állapotátmenet-modellt tartalmazza és nem az érzékelő modellt.</p><p>Érdekes meggondolni, hogy mi történik, ahogy egyre távolabbra próbálunk előre jelezni a jövőben. A 15.2. (b) feladat megmutatja, hogy az eső előrejelzett eloszlása a 〈0,5, 0,5〉 fix ponthoz konvergál, ami után a továbbiakban állandó marad. Ez az állapotátmenet-modell által meghatározott Markov-folyamat <span class="strong"><strong>stacionárius eloszlás</strong></span>a (<span class="strong"><strong>st</strong></span><span class="strong"><strong>ationary distribution</strong></span>) (lásd még <a class="xref" href="ch14s05.md#ID_605_oldal">„Következtetés Markov-lánc szimulációval”</a> rész). Rengeteg ismeret gyűlt fel az ilyen eloszlások tulajdonságairól és a <span class="strong"><strong>keverési idő</strong></span>ről (<span class="strong"><strong>mixing time</strong></span>) – ami nagyjából a fix pont eléréséig eltelt idő. Gyakorlati szempontból ez bukásra ítél minden olyan kísérletet, ami a keverési idő kis hányadánál nagyobb számú lépés múlva kísérli meg az aktuális állapot előrejelzését. Minél bizonytalanabb az állapotátmenet-modell, annál rövidebb a keverési idő, és a jövő annál homályosabb.</p><p>A szűrésen és az előrejelzésen túl, felhasználhatjuk az előrehaladó rekurziót egy bizonyítéksorozat <span class="emphasis"><em>P</em></span>(<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) <span class="strong"><strong>valószínűség</strong></span>ének a kiszámítására is. Ez egy hasznos mennyiség, ha különböző időbeli modelleket szeretnénk összehasonlítani, amelyek ugyanazt a bizonyítéksorozatot állíthatták elő; például a 15.6. alfejezetben különböző szavakat hasonlítunk össze, amelyek ugyanazt a hangsort állíthatták elő. Ehhez a rekurzióhoz felhasználjuk az <span class="emphasis"><em><span xml:lang="hu" class="bold"><strong>ℓ</strong></span></em></span><sub>1:<span class="emphasis"><em>t</em></span></sub> = <span class="strong"><strong>P</strong></span>(<span class="bold"><strong>X<sub>t</sub>,</strong></span> <span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) valószínűségi (likelihood) üzenetet. Egyszerű feladat azt megmutatni, hogy</p><p><code class="code"><em><span class="remark"><em><span class="remark">ℓ</span></em></span></em><sub>1:<em><span class="remark">t</span></em>+1 </sub>= Előre(<em><span class="remark"><em><span class="remark">ℓ</span></em></span></em><sub>1:<em><span class="remark">t</span></em></sub>, <em><span class="remark">e</span></em><sub><em><span class="remark">t</span></em>+1</sub>)</code></p><p>Kiszámítva <span class="emphasis"><em><span class="strong"><strong>ℓ</strong></span></em></span><sub> 1:<span class="emphasis"><em>t</em></span></sub>-t, az aktuális valószínűséget az <span class="bold"><strong>X<sub>t </sub></strong></span>feletti összegzéssel kapjuk:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0008.gif" alt="Szűrés és előrejelzés"/></span></p></div><div class="section" title="Simítás"><div class="titlepage"><div><div><h2 class="title"><a id="id691450"/>Simítás</h2></div></div></div><p>Ahogy korábban meghatároztuk, a <span class="strong"><strong>simítás</strong></span> (<span class="strong"><strong>smoothing</strong></span>) múltbeli állapotok feletti eloszlás kiszámításának a folyamata a jelenig tartó bizonyítékok ismeretében; azaz <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>k</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) számítása valamely 0 ≤ <span xml:lang="it" class="emphasis"><em>k </em></span>&lt; <span class="emphasis"><em>t</em></span> esetén (lásd 15.3. ábra). Ez legkényelmesebben két részletben végezhető el – a bizonyíték <span class="emphasis"><em>k</em></span>-ig és a bizonyíték <span class="emphasis"><em>k </em></span>+ 1-től <span class="emphasis"><em>t</em></span>-ig,</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub>k</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">t</span></em></sub>) = <em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub>k</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">k</span></em></sub>, <em><span class="remark">e</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub>)</code></p><p><code class="code">	= α<em><span class="remark"> P</span></em>(<em><span class="remark">X</span></em><sub>k</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">k</span></em></sub>) <em><span class="remark">P</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub>|<em><span class="remark">X</span></em><sub>k</sub>, <em><span class="remark">e</span></em><sub>1:<em><span class="remark">k</span></em></sub>)	(a Bayes-szabályt használva)</code></p><p><code class="code">	= α <em><span class="remark">P</span></em>(<em><span class="remark">X</span></em><sub>k</sub>|<em><span class="remark">e</span></em><sub>1:<em><span class="remark">k</span></em></sub>) <em><span class="remark">P</span></em>(<em><span class="remark">e</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub>|<em><span class="remark">X</span></em><sub>k</sub>)	(a feltételes függetlenséget használva)</code></p><p><code class="code">= α <em><span class="remark">f</span></em><sub>1:<em><span class="remark">k</span></em></sub> <em><span class="remark">b</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub>						(15.6)</code></p><p>ahol definiáltuk<span class="strong"><strong> </strong></span>a <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>k</em></span>+1:<span class="emphasis"><em>t </em></span></sub>= <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>k</em></span>+1:<span class="emphasis"><em>t</em></span></sub>|<span class="strong"><strong>X</strong></span><sub>k</sub>) „visszafelé” üzenetet, analóg módon az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>k</em></span></sub> előre üzenethez. Az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>k</em></span></sub> előre üzenetet előre szűréssel lehet kiszámolni 1-től <span class="emphasis"><em>k</em></span>-ig, a (15.3) egyenlet alapján. A <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>k</em></span>+1:<span class="emphasis"><em>t</em></span></sub><span class="emphasis"><em><sub> </sub></em></span>visszafelé üzenetről pedig kiderül, hogy egy egyszerű rekurzív folyamattal kiszámítható, ami <span class="emphasis"><em>t</em></span>-től visszafelé halad:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0056.gif" alt="Simítás"/></span></p><p>ahol az utolsó lépés az <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>k</em></span>+1</sub> és az <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>k</em></span>+2:<span class="emphasis"><em>t</em></span></sub> feltételes függetlenségéből következik az <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>k</em></span>+1</sub> melletti feltétellel. Az összegzésben a három tényezőből az első és a harmadik közvetlenül a modellből megkapható, a második pedig a „rekurzív hívás”. Az üzenetjelölést használva kapjuk, hogy </p><p><code class="code"><em><span class="remark">b</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub> = Hátra(<em><span class="remark">b</span></em><sub><em><span class="remark">k</span></em>+2:<em><span class="remark">t</span></em></sub>, <em><span class="remark">e</span></em><sub><em><span class="remark">k</span></em>+1:<em><span class="remark">t</span></em></sub>)</code></p><p>ahol a <code class="code">HÁTRA</code> a (15.7) egyenlet által leírt frissítést hajtja végre. Ahogy az előrefelé rekurziónál, az egyes frissítésekhez szükséges idő- és tárigény állandó, és így <span class="emphasis"><em>t</em></span>-től független itt is.</p><div class="figure"><a id="id691844"/><p class="title"><strong>15.3. ábra - A simítás egy múltbeli <span class="emphasis"><em>k</em></span> időpontban az állapot a posteriori <span class="strong">P</span>(<span class="strong">X</span><sub>k</sub>|<span class="strong">e</span><sub>1<span class="emphasis"><em>:t</em></span></sub>) eloszlását számítja ki egy teljes, 1-től <span class="emphasis"><em>t</em></span>-ig terjedő megfigyelés sorozat ismeretében</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-03.png" alt="A simítás egy múltbeli k időpontban az állapot a posteriori P(Xk|e1:t) eloszlását számítja ki egy teljes, 1-től t-ig terjedő megfigyelés sorozat ismeretében"/></div></div></div><p>Most láthatjuk, hogy a (15.6) egyenlet<span class="emphasis"><em> </em></span>mindkét tényezője kiszámítható időbeli rekurzióval, az egyik előrefelé fut 1-től <span class="emphasis"><em>k</em></span>-ig, és a szűrés (15.3) egyenletét használja, a másik visszafelé fut <span class="emphasis"><em>t</em></span>-től <span class="emphasis"><em>k</em></span>+1-ig, és a (15.7) egyenletet használja. Figyeljünk arra, hogy a viszszafelé fázist <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>t</em></span>+1:<span class="emphasis"><em>t</em></span> </sub>= <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1:<span class="emphasis"><em>t</em></span></sub>|<span class="strong"><strong>X</strong></span><sub>t</sub>) = <span class="strong"><strong>1</strong></span>-gyel inicializáljuk, ahol <span class="strong"><strong>1 </strong></span>egy egyesekből álló vektor. (Mivel <span class="strong"><strong>e</strong></span><sub><span class="emphasis"><em>t</em></span>+1:<span class="emphasis"><em>t</em></span></sub> egy üres sorozat, a megfigyelésének valószínűsége 1.)</p><p>Alkalmazzuk most ezt az algoritmust az esernyős példára, kiszámítva az eső valószínűségének simított becslését <span class="emphasis"><em>t </em></span>= 1-nél, az első és második nap megfigyeléseinek ismeretében. A (15.6) egyenlet szerint ezt az adja meg, hogy</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>1</sub>|<em><span class="remark">u</span></em><sub>1</sub>, <em><span class="remark">u</span></em><sub>2</sub>) =<em><span class="remark"> </span></em>α <em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>1</sub>|<em><span class="remark">u</span></em><sub>1</sub>) <em><span class="remark">P</span></em>(<em><span class="remark">u</span></em><sub>2</sub>|<em><span class="remark">R</span></em><sub>1</sub>)					(15.8)</code></p><p>A korábban leírt előrefelé szűrési folyamatból már tudjuk, hogy az első tényező 〈0,818, 0,182〉. A második tényezőt a (15.7) egyenletbeli visszafelé rekurziót alkalmazva számíthatjuk ki:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0010.gif" alt="A simítás egy múltbeli k időpontban az állapot a posteriori P(Xk|e1:t) eloszlását számítja ki egy teljes, 1-től t-ig terjedő megfigyelés sorozat ismeretében"/></span></p><p>Ezt visszahelyettesítve a (15.8) egyenletbe azt kapjuk, hogy a simított becslés az esőre az 1. napon</p><p><code class="code"><em><span class="remark">P</span></em>(<em><span class="remark">R</span></em><sub>1</sub>|<em><span class="remark">u</span></em><sub>1</sub><em><span class="remark">, u</span></em><sub>2</sub>) = α 〈0,818, 0,182〉 × 〈0,69, 0,41〉 ≈ 〈0,883, 0,117〉 </code></p><p>Így ebben az esetben a simított becslés nagyobb, mint a szűrt becslés (0,818). Ennek oka az, hogy az esernyő a 2. napon valószínűbbé teszi, hogy esett a 2. napon, és mivel az eső tartósan szokott esni, ez még valószínűbbé teszi, hogy esett az 1. napon.</p><p>Mind az előrefelé, mind a visszafelé haladó rekurzió lépésenként állandó időt igényel; így a simítás időkomplexitása <span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span> </sub>bizonyíték esetén <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>t</em></span>). Ez egy konkrét <span class="emphasis"><em>k</em></span> időlépésbeli simítás komplexitása. Ha a teljes szekvenciát szeretnénk simítani, nyilvánvaló módszer, hogy egyszerűen az egész simítási folyamatot lefuttatjuk minden egyes simítandó időpillanatra. Ez <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>t</em></span><sup>2</sup>) időkomplexitást eredményez. Jobb megközelítés a dinamikai programozás nagyon egyszerű alkalmazásával <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>t</em></span>)-re csökkenti a komplexitást. A megoldás kulcsa megjelent az esernyős példa előző elemzésében, ahol az előrefelé szűrés folyamatának eredményeit újra fel tudtuk használni. A lineáris idejű algoritmus kulcsa így az előrefelé szűrés eredményeinek a tárolása az egész sorozatnál. Aztán a visszafelé rekurziót futtatjuk <span class="emphasis"><em>t</em></span>-től 1-ig, kiszámítva a szűrt becslést minden <span class="emphasis"><em>k</em></span> lépésnél a kiszámolt <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>k</em></span>+1:<span class="emphasis"><em>t</em></span></sub><span class="emphasis"><em><sub> </sub></em></span>visszafelé üzenetből és a tárolt <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>k</em></span><span class="strong"><strong> </strong></span></sub>előrefelé üzenetből. Az algoritmus, amit találóan <span class="strong"><strong>előre-hátra algoritmus</strong></span>nak (<span class="strong"><strong>forward-backward algorithm</strong></span>) neveznek, a 15.4. ábrán látható.</p><div class="figure"><a id="id692149"/><p class="title"><strong>15.4. ábra - Az előre-hátra algoritmus, ami állapotok egy sorozatának az a posteriori valószínűségeit számítja ki adott megfigyelési sorozat ismeretében. Az <code class="code">ELŐRE</code> és a <code class="code">HÁTRA</code> műveleteket rendre a (15.3) és (15.7) egyenletek definiálják.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-04.png" alt="Az előre-hátra algoritmus, ami állapotok egy sorozatának az a posteriori valószínűségeit számítja ki adott megfigyelési sorozat ismeretében. Az ELŐRE és a HÁTRA műveleteket rendre a (15.3) és (15.7) egyenletek definiálják."/></div></div></div><p>A figyelmes olvasó észrevehette, hogy a 15.3. ábrán látható Bayes-hálóstruktúra egy polifa (polytree) a 14. fejezet szóhasználatában. Ez azt jelenti, hogy a csoportosító algoritmus egy nyilvánvaló alkalmazása szintén lineáris idejű algoritmust eredményez, ami a teljes sorozatra kiszámítja a simított becslést. Mára már világossá vált, hogy az előre-hátra algoritmus valójában a csoportosító eljárásokban használt polifa terjesztési algoritmusnak egy speciális esete (bár a kettőt egymástól függetlenül fejlesztették ki).</p><p>Az előre-hátra algoritmus alkotja a gerincét azon számítási módszereknek, amelyeket számos zajos megfigyelések sorozatával foglalkozó alkalmazásban használnak, a beszédfelismeréstől a repülőgépek radarkövetéséig. Ahogy leírtuk, két gyakorlati hátránya van. Az első, hogy a tárigénye túl nagy lehet azoknál az alkalmazásoknál, ahol az állapottér nagy, és a sorozatok hosszúak, mivel <span class="emphasis"><em>O</em></span>(|<span xml:lang="it" class="bold"><strong>f</strong></span>|<span class="emphasis"><em>t</em></span>) méretű tárat használ, ahol |<span xml:lang="it" class="bold"><strong>f</strong></span>|<span class="emphasis"><em> </em></span>az előrefelé üzenet reprezentációjának a mérete. A tárigény <span class="emphasis"><em>O</em></span>(|<span xml:lang="it" class="bold"><strong>f</strong></span>|log<span class="emphasis"><em> t</em></span>)-re csökkenthető az időkomplexitásnak egy log <span class="emphasis"><em>t</em></span> tényezővel történő egyidejű megnövelése árán, ahogy a 15.3. feladat mutatja. Bizonyos esetekben (lásd 15.3. alfejezet) egy állandó tárigényű algoritmus használható időbüntetés nélkül.</p><p>Az alapalgoritmus második hátránya, hogy a folyamatos (online) működéshez módosítást igényel. Ekkor ugyanis a korábbi időpontokhoz simított becsléseket kell kiszámítanunk, amint folyamatosan új megfigyelések érkeznek a sorozat végéhez. A leggyakoribb követelmény az <span class="strong"><strong>állandó időkülönbségű simítás</strong></span> (<span class="strong"><strong>fixed-lag smoothing</strong></span>), ami a <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>t–d</sub>|<span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) simított becslés kiszámítását jelenti egy rögzített <span class="emphasis"><em>d</em></span>-re. Azaz a simítást a jelenlegi <span class="emphasis"><em>t</em></span> időpillanat előtt <span class="emphasis"><em>d</em></span> lépéssel lévő időpontra végezzük el; <span class="emphasis"><em>t</em></span> növekedését a simításnak is követnie kell. Nyilvánvaló, hogy lefuttathatjuk az előre-hátra algoritmust a <span class="emphasis"><em>d</em></span> lépéses „ablakban”, amint egy új bizonyíték adódik, de ez nem tűnik hatékonynak. A 15.3. alfejezetben látni fogjuk, hogy az állandó időkülönbségű simításnál egy frissítés bizonyos esetekben állandó idő alatt megtehető, függetlenül a <span class="emphasis"><em>d</em></span> időkülönbségtől.</p></div><div class="section" title="A legvalószínűbb sorozat megtalálása"><div class="titlepage"><div><div><h2 class="title"><a id="id692265"/>A legvalószínűbb sorozat megtalálása</h2></div></div></div><a id="ID_638_oldal"/><p>Tegyük fel, hogy a biztonsági őr esernyősorozata a munkája első öt napjában az [<span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>hamis</em></span>, <span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>igaz</em></span>]. Mi a legvalószínűbb időjárás-sorozat, ami ezt megmagyarázza? Az esernyő hiánya a 3. napon azt jelenti, hogy nem esett, vagy azt, hogy az igazgató elfelejtette elhozni? Ha a 3. napon nem esett, talán a 4. napon sem esik (mivel az időjárás nem változik gyorsan), de ekkor az igazgató puszta óvatosságból hozta az esernyőt. Összességében 2<sup>5</sup> lehetséges időjárás-sorozatot választhatunk. Létezik-e módszer a legvalószínűbb sorozat megkeresésére, az összes felsorolása nélkül?</p><p>Az egyik megközelítés, amit kipróbálhatunk a következő lineáris idejű algoritmus: használjuk a simító algoritmust, hogy megtaláljuk az időjárás a posteriori eloszlását minden időpillanatban; majd állítsuk elő a sorozatot minden egyes lépésnél az a posteriori szerinti legvalószínűbb időjárást felhasználva. Egy ilyen megközelítést kötelező gyanakvással kell fogadnia az olvasónak, mivel a szűrés által kiszámított a posteriori eloszlások az <span class="emphasis"><em>egyes</em></span> időpontok feletti eloszlások, ezzel szemben a legvalószínűbb <span class="emphasis"><em>sorozat</em></span> megtalálásához az összes időpont feletti <span class="emphasis"><em>együttes</em></span> valószínűségeket kell figyelembe venni. Az eredmények valójában nagyon különbözők lehetnek (lásd 15.4. feladat).</p><p>Lineáris idejű algoritmus azonban <span class="emphasis"><em>létezik</em></span> a legvalószínűbb sorozat megtalálására, de kicsit több gondolkozást igényel. Ugyanazon a Markov-tulajdonságon alapul, mint ami hatékony algoritmusokat eredményezett a szűrésre és a simításra. A problémáról való gondolkodás legkönnyebb módja, hogy ha minden sorozatot egy <span class="emphasis"><em>útvonalnak</em></span> tekintünk egy gráfban, aminek a csomópontjai az egyes időpillanatokban a lehetséges <span class="emphasis"><em>állapotok</em></span>. Egy ilyen gráf látható az esernyős problémára a 15.5. (a) ábrán. Most gondoljuk meg a gráfon keresztül vezető legvalószínűbb út megkeresésének a problémáját, ahol egy út valószínűsége (a likelihood érték) az útvonal menti átmenetek valószínűségeinek és az egyes állapotokban adott megfigyelések valószínűségeinek a szorzata. Koncentráljunk most azokra az útvonalakra, amelyek elérik az <span class="emphasis"><em>Eső</em></span><sub>5 </sub>= <span class="emphasis"><em>igaz</em></span> állapotot. A Markov-tulajdonság miatt fennáll, hogy az <span class="emphasis"><em>Eső</em></span><sub>5 </sub>= <span class="emphasis"><em>igaz</em></span> állapotba vezető legvalószínűbb útvonal tartalmazza azt a legvalószínűbb útvonalat, amely valamelyik 4. időpontbeli állapotba vezet, és amit egy átmenet követ az <span class="emphasis"><em>Eső</em></span><sub>5 </sub>= <span class="emphasis"><em>igaz</em></span>-ba; a 4. időpontbeli állapot pedig, ami része lesz az <span class="emphasis"><em>Eső</em></span><sub>5 </sub>= <span class="emphasis"><em>igaz-</em></span>ba vezető útnak, az az állapot, amelyik maximalizálja ennek az útvonalnak a valószínűségét.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Másképpen fogalmazva, van egy <span class="emphasis"><em>rekurzív kapcsolat az</em></span> <span class="strong"><strong>x</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub> <span class="emphasis"><em>állapotokba vezető legvalószínűbb útvonalak és az </em></span><span class="bold"><strong>x<sub>t </sub>állapotokba vezető legvalószínűbb útvonalak között</strong></span>. Ez a kapcsolat olyan egyenletként írható fel, amely az útvonalak valószínűségeit kapcsolja össze:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0011.gif" alt="A legvalószínűbb sorozat megtalálása"/></span></p></div><p>A (15.9) egyenlet <span class="emphasis"><em>megegyezik</em></span> a szűrés (15.3) egyenletével, azzal a kivétellel, hogy</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>= <span class="strong"><strong>P</strong></span>(<span class="strong"><strong>X</strong></span><sub>t</sub><span class="strong"><strong>e</strong></span><sub>1:<span class="emphasis"><em>t</em></span></sub>) előre üzenet helyett a következő üzenet szerepel:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0012.gif" alt="A legvalószínűbb sorozat megtalálása"/></span></p></li></ol></div><p>ami az <span class="strong"><strong>x</strong></span><sub>t</sub> állapotba vezető legvalószínűbb út valószínűségeit adja meg; és</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>a (15.3) egyenletbeli <span class="strong"><strong>x</strong></span><sub>t</sub> feletti összegzés helyett a (15.9) egyenletben az <span class="strong"><strong>x</strong></span><sub>t</sub> feletti maximalizálás szerepel.</p></li></ol></div><p class="Tartalom3">Így a legvalószínűbb állapotsorozat kiszámítása hasonló a szűréshez: előrefelé végigfut a sorozaton, minden időpontban kiszámítva az <span class="strong"><strong>m</strong></span> üzeneteket a (15.9) egyenlet szerint. A számítás menetét a 15.5. (b) ábra mutatja. Végül ez kiadja az <span class="emphasis"><em>összes</em></span> végső állapothoz vezető legvalószínűbb útvonal valószínűségét. Így már könnyen kiválasztható a teljes hosszúságú legvalószínűbb sorozat (a vastagon szedettel kiemelt végső állapottól). Az aktuális sorozat azonosításához – szemben azzal, amikor csak a valószínűségét számítjuk ki – az algoritmusnak minden állapotból mutatókat kell nyilvántartania a legjobb hozzá vezető állapothoz (vastagon szedettel látható); a sorozat a mutatóknak a legjobb végső állapottól való visszafelé követésével határozható meg.</p><div class="figure"><a id="id692494"/><p class="title"><strong>15.5. ábra - (a) Az <span class="emphasis"><em>Eső<sub>t</sub></em></span> lehetséges állapotsorozatait tekinthetjük egy átvezető útnak egy gráfon, aminek csomópontjai a lehetséges állapotok az egyes időpontokban. (Az állapotokat négyzetes csomópont jelzi, hogy félreérthetetlenül megkülönböztessük őket egy Bayes-háló csomópontjaitól.) (b) A Viterbi-algoritmus működése az [<span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>hamis</em></span>, <span class="emphasis"><em>igaz</em></span>, <span class="emphasis"><em>igaz</em></span>] megfigyelési sorozatra. Minden <span class="emphasis"><em>t</em></span> időpontra feltüntettük az <span class="strong">m</span><sub>1:<span class="emphasis"><em>t</em></span></sub> üzenet értékeit, ami minden egyes <span class="emphasis"><em>t</em></span> időpontbeli állapothoz megadja a legjobb, benne végződő sorozat valószínűségét. Minden egyes állapothoz egy vastag nyíl is vezet, ami a legjobb elődjét jelzi, a megelőző sorozat valószínűségének és az átmenet valószínűségének a szorzata szerint. A vastag nyilak visszafelé követése az <span class="strong">m</span><sub>1:5</sub>-beni legvalószínűbb állapotból pedig megadja a legvalószínűbb sorozatot.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-05.png" alt="(a) Az Esőt lehetséges állapotsorozatait tekinthetjük egy átvezető útnak egy gráfon, aminek csomópontjai a lehetséges állapotok az egyes időpontokban. (Az állapotokat négyzetes csomópont jelzi, hogy félreérthetetlenül megkülönböztessük őket egy Bayes-háló csomópontjaitól.) (b) A Viterbi-algoritmus működése az [igaz, igaz, hamis, igaz, igaz] megfigyelési sorozatra. Minden t időpontra feltüntettük az m1:t üzenet értékeit, ami minden egyes t időpontbeli állapothoz megadja a legjobb, benne végződő sorozat valószínűségét. Minden egyes állapothoz egy vastag nyíl is vezet, ami a legjobb elődjét jelzi, a megelőző sorozat valószínűségének és az átmenet valószínűségének a szorzata szerint. A vastag nyilak visszafelé követése az m1:5-beni legvalószínűbb állapotból pedig megadja a legvalószínűbb sorozatot."/></div></div></div><p>Az előzőleg leírt algoritmust <span class="strong"><strong>Viterbi-algoritmus</strong></span>nak nevezik a megalkotója után. Hasonlóan a szűrési algoritmushoz, ennek a komplexitása is lineáris <span class="emphasis"><em>t</em></span>-ben, a sorozat hosszában. Azonban eltérően a szűréstől, a tárigénye szintén lineáris <span class="emphasis"><em>t</em></span>-ben. Ez azért van így, mert a Viterbi-algoritmusban mutatókkal kell nyilvántartani az egyes állapotokhoz vezető legjobb sorozatot.</p></div></div></body></html>
