<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Tervkészítés állapottér-kereséssel"><div class="titlepage"><div><div><h1 class="title"><a id="id641013"/>Tervkészítés állapottér-kereséssel</h1></div></div></div><p class="2">Most fordítsuk figyelmünket a tervkészítő algoritmusok felé. A legkézenfekvőbb megközelítés az állapottér-keresés. Mivel a tervkészítési problémák cselekvéseinek leírása tartalmazza az előfeltételeket és a következményeket, a keresés mindkét irányban végrehajtható: vagy előrefelé egy kiindulási állapotból, vagy visszafelé a céltól, amint azt a 11.5. ábra is mutatja. Mindezeken túl felhasználhatjuk az explicit cselekvés- és célreprezentációkat, hogy automatikusan hatékony heurisztikákat származtassunk.</p><div class="section" title="Előrefelé keresés az állapottérben"><div class="titlepage"><div><div><h2 class="title"><a id="id641020"/>Előrefelé keresés az állapottérben</h2></div></div></div><p class="3">Ez előrefelé kereséssel történő tervkészítés hasonlít a 3. fejezetben bemutatott problémamegoldó megközelítéshez. Ezt progresszív tervkészítésnek nevezzük, mert előrefelé haladva dolgozik. </p><p class="Tartalom3">A feladat kiinduló állapotából indulva végignézzük a lehetséges cselekvéssorozatokat, amíg olyat nem találunk, ami a célállapothoz vezet. A tervkészítési probléma állapottér-keresési problémaként formalizálva a következő:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A keresés <span class="strong"><strong>kiindulási állapot</strong></span>a (<span class="strong"><strong>initial state</strong></span>) megegyezik a tervkészítési probléma kiindulási állapotával. Általánosságban minden állapot pozitív alapliterálok egy halmaza; az itt nem szereplő literálok hamisak.</p></li><li class="listitem"><p>Egy állapotban minden olyan <span class="strong"><strong>cselekvés</strong></span> (<span class="strong"><strong>action</strong></span>) alkalmazható, aminek az előfeltételei teljesülnek. A cselekvés végrehajtása után következő állapotot úgy állítjuk elő, hogy a következményrész pozitív literáljait hozzáadjuk, negatív literáljait pedig töröljük. (Elsőrendű logika esetén az előfeltételekből az egyesítőt alkalmazni kell a következményliterálokra.) Megjegyezzük, hogy annak következményeként, hogy egy explicit cselekvés reprezentációt használunk, egyetlen állapotátmenet-függvény működik az összes tervkészítő problémára.</p></li><li class="listitem"><p>A <span class="strong"><strong>célteszt</strong></span> (<span class="strong"><strong>goal test</strong></span>) ellenőrzi, hogy az adott állapot kielégíti-e a tervkészítési probléma célját.</p></li><li class="listitem"><p>A <span class="strong"><strong>lépésköltség</strong></span> (<span class="strong"><strong>step cost</strong></span>) minden cselekvésre tipikusan 1. Habár könnyű lenne a különböző cselekvésekhez különböző költségeket hozzárendelni, ezt a <code class="code">STRIPS</code> tervkészítőkben nagyon ritkán alkalmazzák.</p></li></ul></div><div class="figure"><a id="id641092"/><p class="title"><strong>11.5. ábra - A tervkészítés két megközelítése. (a) Előrefelé (progresszív) állapottér-keresés, a kiinduló állapotból indulva és a probléma cselekvéseit használva halad a cél felé. (b) Visszafelé (regressziós) állapottér-keresés: valószínűségi állapot keresés (lásd <a class="xref" href="ch03s06.md#ID_124_oldal">„Szenzor nélküli problémák”</a> részben) a célállapot(ok)ból indulva a cselekvések inverzét alkalmazva keresi visszafelé a kezdeti állapotot.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/11-05.png" alt="A tervkészítés két megközelítése. (a) Előrefelé (progresszív) állapottér-keresés, a kiinduló állapotból indulva és a probléma cselekvéseit használva halad a cél felé. (b) Visszafelé (regressziós) állapottér-keresés: valószínűségi állapot keresés (lásd részben) a célállapot(ok)ból indulva a cselekvések inverzét alkalmazva keresi visszafelé a kezdeti állapotot."/></div></div></div><p class="Képalá">Emlékezzünk vissza, hogy a függvényszimbólumok hiányában a tervkészítési probléma állapottere véges, ezért teljes gráf keresési algoritmusok, mint például az A* keresés, egyben teljes tervkészítő algoritmusok is.</p><p class="Tartalom3">A tervkészítők kutatásának korai napjaitól (kb. 1961-től) egészen mostanáig (kb. 1998-ig) az a feltételezés élt, hogy az előrefelé kereső algoritmusok nem eléggé hatékonyak a gyakorlati alkalmazásra. Ma már, tekintsünk csak vissza a 11.1. alfejezetre, ezt nem nehéz megindokolni. Először is az előrefelé keresés nem foglalkozik a lényegtelen cselekvések problémájával, mivel minden állapotban minden alkalmazható cselekvést figyelembe vesz. Másodszor pedig ez a megközelítés gyorsan elakad egy jó heurisztika nélkül. Vegyük például a légi csomagszállítási problémát 10 repülőtérrel, egyenként 5-5 repülővel és 20 darab csomaggal. A cél, hogy az <span class="emphasis"><em>A</em></span> repülőtér összes terhét a <span class="emphasis"><em>B</em></span> repülőtérre szállítsuk. Van egy egyszerű megoldása a feladatnak: tegyük be mind a 20 csomagot az egyik <span class="emphasis"><em>A</em></span>-beli repülőgépbe, ezzel repüljünk <span class="emphasis"><em>B</em></span>-be, és ott rakodjunk ki. A megoldás megkeresése ellenben nagyon nehéz lehet, hiszen az átlagos elágazási faktor óriási: mind az 50 repülő 9 másik reptérre tud repülni, míg mind a 200 csomag kirakható (ha be volt rakva), vagy berakható a reptér bármelyik repülőjébe. Átlagosan mondjuk 1000 lehetséges cselekvés hajtható végre, így a keresési fában a kézenfekvő megoldás mélységéig közel 1000<sup>41</sup> csomópont van. Ebből nyilvánvaló, hogy egy megfelelő heurisztikára lesz szükség, hogy ezt a keresést hatékonnyá tegyük. A hátrafelé keresés áttekintése után néhány lehetséges heurisztikát mutatunk be.</p></div><div class="section" title="Hátrafelé keresés az állapottérben"><div class="titlepage"><div><div><h2 class="title"><a id="id641130"/>Hátrafelé keresés az állapottérben</h2></div></div></div><p class="3">Az állapottérben történő hátrafelé keresést a kétirányú keresés egy részeként a 3. fejezetben röviden már bemutattuk. Ott megjegyeztük, hogy a hátrafelé keresés megvalósítása nagyon nehéz lehet, ha a célállapotokat az explicit megadás helyett megkötésekkel határozzuk meg. Nevezetesen nem mindig nyilvánvaló, hogy hogyan generáljuk le a célállapotok halmazának a lehetséges <span class="strong"><strong>elődállapot</strong></span>ait (<span class="strong"><strong>predecessor</strong></span>s). Látjuk majd, hogy a <code class="code">STRIPS</code> reprezentáció esetén ez meglehetősen egyszerű, mert az állapothalmazokat azokkal a literálokkal írhatjuk le, amelyeknek igaz értékűeknek kell lenni az adott állapotokban.</p><p class="Tartalom3">A hátrafelé keresés fő előnye az, hogy lehetővé teszi számunkra, hogy csak a <span class="strong"><strong>releváns</strong></span> (<span class="strong"><strong>relevant</strong></span>) cselekvéseket vegyük figyelembe. Egy cselekvés releváns egy konjunktív cél szempontjából, ha eléri a cél egy konjunktját. Például a 10-repülőteres légi csomagszállítási problémánk esetében a cél az, hogy a 20 csomag a <span class="emphasis"><em>B</em></span> repülőtéren legyen, vagy pontosabban </p><p><code class="code"><em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">B</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">B</span></em>) ∧ … ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>20</sub>, <em><span class="remark">B</span></em>)</code></p><p>Vegyük az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>B</em></span>) literált. Hátrafelé dolgozva, olyan cselekvéseket kereshetünk, melyeknek ez a következménye. Ilyen csak egy van: <span class="emphasis"><em>Kirakodás</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>B</em></span>), ahol a <span class="emphasis"><em>p</em></span> repülőgép meghatározatlan. </p><p>Vegyük észre, hogy számos <span class="emphasis"><em>irreleváns</em></span> cselekvés is van, ami szintén a célállapotra vezet. Például elrepíthetünk egy üres gépet a <span class="emphasis"><em>JFK</em></span> repülőtérről (John Fitzgerald Kennedy repülőtér New Yorkban) az <span class="emphasis"><em>SFO</em></span>-ra (San Francisco repülőtere), ami a célállapothoz vezet egy olyan elődállapotból, melyben a repülőgép a <span class="emphasis"><em>JFK</em></span>-n van, és minden célfeltétel teljesül. Egy hátrafelé keresés, ami megengedi a hatástalan cselekvéseket még teljes, de sokkal kevésbé hatékony. Ha létezik megoldás, akkor azt egy olyan hátrafelé keresés is megtalálja, amely csak releváns cselekvéseket enged meg. A hátrafelé keresés szűkítése a releváns cselekvésekre, gyakran jóval alacsonyabb elágazási tényezőt eredményez, mint az előrefelé keresés. Például a légi szállítási problémánk esetén a kiindulási állapotból előrefelé közel 1000 cselekvés hajtható végre, míg a célból visszafelé indulva mindössze 20.</p><p>A visszafelé keresést <span class="strong"><strong>regresszió</strong></span>s (<span class="strong"><strong>regression</strong></span>) tervkészítésnek is nevezik. A regressziós keresés meghatározó kérdése a következő: melyek azok az állapotok, amelyekből egy adott cselekvés a célhoz vezet? Ezen állapotok leírásának számítását a cél adott állapoton keresztüli <span class="strong"><strong>regresszálás</strong></span>ának (<span class="strong"><strong>regressing</strong></span>) nevezzük. Hogy lássuk ennek menetét, vegyük a légi szállítási feladatot. Adott a cél az</p><p><code class="code"><em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">B</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">B</span></em>) ∧ … ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>20</sub>, <em><span class="remark">B</span></em>)</code></p><p>és a releváns cselekvés<span class="emphasis"><em> a Kirakodás</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>B</em></span>), ami az első literált adja. A cselekvés csak akkor működik, ha az előfeltételei teljesülnek. Ebből kifolyólag az elődállapotnak tartalmaznia kell a <span class="emphasis"><em>Benne</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>p</em></span>) ∧ <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>p</em></span>, <span class="emphasis"><em>B</em></span>) előfeltételeket. Mindezeken túl az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>B</em></span>) részcél nem lehet igaz a megelőző állapotban.<sup>[<a id="id641383" href="#ftn.id641383" class="footnote">114</a>]</sup> Így a megelőző állapot leírása az alábbi:</p><p><code class="code"><em><span class="remark">Benne</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">p</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">p</span></em>, <em><span class="remark">B</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">B</span></em>) ∧ … ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>20</sub>, <em><span class="remark">B</span></em>)</code></p><p>Ennek tetejébe, ha elvárjuk, hogy egy cselekvés kielégítsen egy literált, azt is biztosítanunk kell, hogy nem <span class="emphasis"><em>ront el</em></span> egy másikat. Az olyan cselekvést, ami megfelel ennek az elvárásnak <span class="strong"><strong>konzisztens</strong></span>nek (<span class="strong"><strong>consistent</strong></span>) nevezzük. Például a <span class="emphasis"><em>Berakodás</em></span>(<span class="emphasis"><em>C</em></span><sub>2</sub>, <span class="emphasis"><em>p</em></span>) cselekvés nem lenne konzisztens az aktuális céllal, mert negálja az <span class="emphasis"><em>Ott</em></span>(<span class="emphasis"><em>C</em></span><sub>2</sub>, <span class="emphasis"><em>B</em></span>) literált.</p><p>Most, hogy a relevanciát és a konzisztenciát definiáltuk, megadhatunk egy általános módszert a hátrafelé keresés elődállapotának kereséséhez. Adott egy <span class="emphasis"><em>G</em></span> cél leírása. Legyen az <span class="emphasis"><em>A</em></span> cselekvés releváns és konzisztens. A megfelelő elődállapot a következő:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Az <span class="emphasis"><em>A</em></span> minden pozitív következményét, ami szerepel <span class="emphasis"><em>G</em></span>-ben, töröljük.</p></li><li class="listitem"><p>Az <span class="emphasis"><em>A</em></span> minden, még nem szereplő előfeltételét hozzáadjuk.</p></li></ul></div><p>A standard keresési algoritmusok bármelyike felhasználható a keresésre. A leállási feltétel, hogy a generált elődállapot leírását a keresés kiindulási állapota kielégítse. Az elsőrendű esetben, ehhez néhány változó behelyettesítésére is szükség lehet az elődállapotának leírásában. Például az előző bekezdés elődállapotának leírását a</p><p><code class="code"><em><span class="remark">Benne</span></em>(<em><span class="remark">C</span></em><sub>1</sub>, <em><span class="remark">P</span></em><sub>12</sub>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">P</span></em><sub>12</sub>, <em><span class="remark">B</span></em>) ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>2</sub>, <em><span class="remark">B</span></em>) ∧ … ∧ <em><span class="remark">Ott</span></em>(<em><span class="remark">C</span></em><sub>20</sub>, <em><span class="remark">B</span></em>)</code></p><p>kiindulási állapot a {<span class="emphasis"><em>p</em></span>/<span class="emphasis"><em>P</em></span><sub>12</sub>} behelyettesítéssel teljesíti. A behelyettesítéseket arra a cselekvésre kell végrehajtani, ami az állapottól a célhoz vezet, így eredményezve a [<span class="emphasis"><em>Kirakodás</em></span>(<span class="emphasis"><em>C</em></span><sub>1</sub>, <span class="emphasis"><em>P</em></span><sub>12</sub>, <span class="emphasis"><em>B</em></span>)] megoldást.</p></div><div class="section" title="Állapottér-keresési heurisztikák"><div class="titlepage"><div><div><h2 class="title"><a id="id641610"/>Állapottér-keresési heurisztikák</h2></div></div></div><p class="3">Sem az előre-, sem pedig a hátrafelé keresés nem hatékony egy jó heurisztika nélkül. Emlékezzünk vissza a 4. fejezetből, hogy egy heurisztikus függvény egy állapot célállapottól való távolságát becsli; a <code class="code">STRIPS</code> esetén minden cselekvés költsége 1, így a távolság az alkalmazandó cselekvések száma. Az alapötlet, hogy nézzük a cselekvés következményeit és a célokat, és becsüljük meg, hogy hány lépésre van szükség a célok elérésére. A pontos szám meghatározása NP-teljes probléma, de a legtöbb esetben találhatók kellően pontos becslők, melyek nem nagyon számításigényesek. Szintén képesek lehetünk egy <span class="strong"><strong>elfogadható</strong></span> (<span class="strong"><strong>admissable</strong></span>) heurisztika származtatására, azaz olyanra, ami nem becsül túl. Ez az A* kereséssel együtt használható  optimális megoldások megkeresésére.</p><p class="Tartalom3">Két megközelítést lehet kipróbálni. Az egyik, hogy a megadott feladatleírásból egy <span class="strong"><strong>relaxált problémá</strong></span>t (<span class="strong"><strong>relaxed problem</strong></span>) származtatunk, ahogy azt a 4. fejezetben bemutattuk. A relaxált problémára (ami várhatóan könnyen megoldható) adott optimális megoldás költsége elfogadható heurisztikát ad az eredeti problémára. A második megközelítés során feltételezzük, hogy a tiszta „oszd meg és uralkodj” algoritmus működni fog. Ezt nevezzük a <span class="strong"><strong>részcélfüggetlenség</strong></span> (<span class="strong"><strong>subgoal independence</strong></span>) feltételezésnek: a részcélok konjunkciójának megoldási költségét, az egymástól <span class="emphasis"><em>függetlenül</em></span> megoldott részcélok költségeinek összegével becsüljük. A részcélfüggetlenség feltételezés lehet optimista vagy pesszimista. Akkor optimista, hogyha vannak negatív kölcsönhatások a részcélokhoz készített résztervek között (például amikor az egyik részterv egy cselekvése töröl egy célt, melyet egy másik részterv ért el). Akkor pesszimista és egyben elfogadhatatlan is, ha a résztervek redundáns cselekvéseket tartalmaznak (például két cselekvés eggyel helyettesíthető az összefésült tervben).</p><p>Vizsgáljuk meg, hogyan származtathatunk relaxált tervkészítési problémákat. Mivel az előfeltételek és a következmények explicit megadásai rendelkezésre állnak, az eljárás ezeket a reprezentációkat módosítja. (Vessük össze ezt a megközelítést a keresési feladatokkal, ahol az állapotátmenet-függvény egy fekete doboz.) A legegyszerűbb ötlet, hogy lazítsuk a problémát úgy, hogy <span class="emphasis"><em>eltávolítjuk az összes előfeltételt</em></span> a cselekvésekből. Ekkor minden cselekvés mindig alkalmazhatóvá válik, és minden literál elérhető egy lépésben (ha van alkalmazható cselekvés, egyébként a cél elérése lehetetlen). Úgy tűnhet, ez azt jelenti, hogy a célok konjunkciójához vezető lépésszám azonos a kielégítetlen célliterálok számával, de nem egészen; (1) lehet két cselekvés, melyek kölcsönösen törlik a másik által teljesített célliterált, (2) néhány cselekvés több célt is elérhet. Ha kombináljuk a relaxált problémát és a részcél függetlenségi feltételezést, mindkét problémát kiküszöböltnek vehetjük, és az előálló heurisztika pontosan a még kielégítetlen célok száma. </p><p>Sokszor pontosabb heurisztika nyerhető, ha legalább a több célt kielégítő cselekvések pozitív kölcsönhatásait figyelembe vesszük. Először tovább relaxáljuk a problémát azáltal, hogy <span class="emphasis"><em>eltávolítjuk a negatív következményeket</em></span> (lásd 11.6. feladat). Ezután kiszámítjuk, hogy mennyi az a minimális cselekvésszám, melyek pozitív következményeinek uniója kielégíti a célt. Vegyük például a</p><p><code class="code"><em><span class="remark">Cél</span></em>(<em><span class="remark">A</span></em> ∧ <em><span class="remark">B </span></em>∧ <em><span class="remark">C</span></em>)</code></p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">X</span></em>, Következmény:<em><span class="remark"> A</span></em> ∧ <em><span class="remark">P</span></em>)</code></p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Y</span></em>, Következmény:<em><span class="remark"> B </span></em>∧ <em><span class="remark">C </span></em>∧ <em><span class="remark">Q</span></em>)</code></p><p><code class="code"><em><span class="remark">Cselekvés</span></em>(<em><span class="remark">Z</span></em>, Következmény:<em><span class="remark"> B</span></em> ∧ <em><span class="remark">P </span></em>∧ <em><span class="remark">Q</span></em>)</code></p><p>A minimális halmaz az {<span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>} cselekvés, ami az {<span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>C</em></span>} célt kielégíti, így a fedőhalmaz-heurisztika szerinti költség 2. Ez javít a részcél függetlenség feltételezésen, ami 3-as költséget adna. Egyetlen apró probléma van: a fedőhalmaz probléma NP-teljes. Az egyszerű fedőhalmaz-keresési algoritmus garantáltan visszaad egy értéket, ami egy log<span class="emphasis"><em> n</em></span>-es faktor pontossággal az igazi minimumérték, ahol <span class="emphasis"><em>n</em></span> a cél literáljainak száma, és a gyakorlatban rendszerint ennél sokkal pontosabb. Sajnos a mohó algoritmus elveszíti a heurisztika elfogadhatóságának garanciáját.</p><p>Az is lehetséges, hogy a relaxált problémát a negatív következmények eltávolításával állítjuk elő anélkül, hogy az előfeltételeket elhagynánk. Ez annyit tesz, hogy ha egy cselekvés következménye <span class="emphasis"><em>A </em></span>∧ ¬<span class="emphasis"><em>B</em></span> az eredeti problémában, akkor <span class="emphasis"><em>A</em></span> a relaxált problémában. Ez annyit tesz, hogy nem kell foglalkoznunk a résztervek közötti negatív kölcsönhatásokkal, mert egyetlen cselekvés sem törölhet egy másik által előállított literált. Az így előálló relaxált feladat megoldásának költsége az <span class="strong"><strong>üres-törlési-lista</strong></span> (<span class="strong"><strong>empty-delete-list</strong></span>) heurisztikát adja. A heurisztika meglehetősen pontos, de kiszámítása egy (egyszerű) tervkészítő algoritmus futtatását igényli. A gyakorlatban a relaxált probléma megoldása elég gyors ahhoz, hogy megérje alkalmazni.</p><p>Az itt bemutatott heurisztika mind a progresszív (előrefelé), mind pedig a regresszív (hátrafelé) irányba használható. A könyv írásának pillanatában az üres-törlési-lista heurisztikát használó előrefelé keresők a listavezetők. Ez valószínűleg változik, ahogy újabb heurisztikák és keresési technikák jelennek meg. Mivel a tervkészítés exponenciális komplexitású,<sup>[<a id="id641796" href="#ftn.id641796" class="footnote">115</a>]</sup> nincs olyan algoritmus, amely minden problémára hatékony lesz, de számos gyakorlati feladat oldható meg ezen fejezet heurisztikáival – sokkal több, mint ami néhány éve megoldható volt.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id641383" href="#id641383" class="para">114</a>] </sup> Ha a részcél igaz lenne az elődállapotban, akkor a cselekvés még mindig a célállapothoz vezetne. Ellenben az ilyen cselekvések hatástalanok (irrelevánsak), mivel nem <span class="emphasis"><em>teszik</em></span> igazzá a célt.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id641796" href="#id641796" class="para">115</a>] </sup> Technikailag a <code class="code">STRIPS</code>-alapú tervkészítés PSPACE-teljes, kivéve, ha a cselekvéseknek csak pozitív előfeltételei vannak egy következmény literállal (Bylander, 1994).</p></div></div></div></body></html>
