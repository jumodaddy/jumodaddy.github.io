<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Az ítéletkalkulus következtetési mintái"><div class="titlepage"><div><div><h1 class="title"><a id="id582971"/>Az ítéletkalkulus következtetési mintái</h1></div></div></div><a id="ID_265_oldal"/><p class="2">Ez az alfejezet végigveszi a következtetés standard mintáit, amelyek alkalmazhatók arra, hogy következmények láncolatait vezethessük le, amelyek elvezetnek a kívánt célhoz. Ezeket a következtetési mintákat <span class="strong"><strong>következtetési szabály</strong></span>oknak (<span class="strong"><strong>inference rules</strong></span>) hívjuk. A legjobban ismert szabály a <span class="strong"><strong>Modus Ponens</strong></span> és a következőképpen írható le:</p><p><span class="inlinemediaobject"><img src="math/mi-07-0008.gif" alt="Az ítéletkalkulus következtetési mintái"/></span></p><p>A jelölés azt jelenti, hogy ha bármikor adott egy <span class="emphasis"><em>α ⇒ β</em></span> formájú mondat és adott egy <span class="emphasis"><em>α</em></span>, akkor a <span class="emphasis"><em>β</em></span> mondat ebből következik. Például a (<span class="emphasis"><em>WumpusElőrefelé</em></span> ∧ <span class="emphasis"><em>WumpusÉl</em></span>) ⇒ <span class="emphasis"><em>Lövés </em></span>és a<span class="emphasis"><em> </em></span>(<span class="emphasis"><em>WumpusElőrefelé</em></span> ∧ <span class="emphasis"><em>WumpusÉl</em></span>) adott, akkor a <span class="emphasis"><em>Lövés</em></span> kikövetkeztethető.</p><p>Egy másik hasznos következtetési szabály az <span class="strong"><strong>És-kiküszöbölés</strong></span> (<span class="strong"><strong>And-Elimination</strong></span>), ami azt mondja ki, hogy egy konjunkcióból bármely konjunkt kikövetkeztethető:</p><p><span class="inlinemediaobject"><img src="math/mi-07-0009.gif" alt="Az ítéletkalkulus következtetési mintái"/></span></p><p>Például abból, hogy (<span class="emphasis"><em>WumpusElőrefelé</em></span> ∧ <span class="emphasis"><em>WumpusÉl</em></span>) a <span class="emphasis"><em>WumpusÉl</em></span> kikövetkeztethető.</p><p>Tekintettel az <span class="emphasis"><em>α</em></span> és β<span class="emphasis"><em> </em></span>lehetséges igazságértékeire, könnyen megmutatható, hogy a Modus Ponens és az És-kiküszöbölés helyes egyszer és mindenkorra. Ezek a szabályok felhasználhatók bármely konkrét esetben, ahol alkalmazhatók, helyes következtetéseket eredményezve anélkül, hogy fel kellett volna sorolnunk a modelleket.</p><p>A 7.11. ábrán található összes logikai ekvivalencia használható következtetési szabályként. Például az ekvivalencia kiküszöbölés két következtetési szabályt eredményez:</p><p><span class="inlinemediaobject"><img src="math/mi-07-0010.gif" alt="Az ítéletkalkulus következtetési mintái"/></span></p><p>Nem minden következtetési szabály működik mindkét irányban, mint ezek. Például nem futtathatjuk a Modus Ponenst ellenkező irányban, hogy megkapjuk <span class="emphasis"><em>α </em></span>⇒<span class="emphasis"><em> β</em></span>-t és <span class="emphasis"><em>α</em></span>-t a <span class="emphasis"><em>β</em></span>-ból.</p><p>Nézzük meg, hogyan használhatjuk ezeket a következtetési szabályokat és ekvivalenciákat a wumpus világban. Az <span class="emphasis"><em>Sz</em></span><sub>1</sub>, ..., <span class="emphasis"><em>Sz</em></span><sub>5</sub> szabályokból álló tudásbázisból indulunk ki, és megmutatjuk, hogy hogyan bizonyíthatjuk a ¬<span class="emphasis"><em>C</em></span><sub>1,2</sub>-t azaz, hogy nincs csapda az [1, 2]-ben. Először alkalmazzuk az ekvivalencia kiküszöbölést <span class="emphasis"><em>Sz</em></span><sub>2</sub>-re, és így kapjuk, hogy </p><p><code class="code"><em><span class="remark">Sz</span></em><sub>6</sub>: (<em><span class="remark">S</span></em><sub>1,1</sub><em><span class="remark"> </span></em>⇒<em><span class="remark"> </span></em>(<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>)) ∧ ((<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ⇒ <em><span class="remark">S</span></em><sub>1,1</sub>)<em><span class="remark"> </span></em></code></p><p>Ezután alkalmazzuk az És-kiküszöbölést az <span class="emphasis"><em>Sz</em></span><sub>6</sub>-ra, és így kapjuk, hogy</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>7</sub>: ((<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ⇒ <em><span class="remark">S</span></em><sub>1,1</sub>) </code></p><p>A kontrapozíció logikai ekvivalenciát alkalmazva:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>8</sub>: (¬<em><span class="remark">S</span></em><sub>1,1</sub> ⇒ ¬(<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>))</code></p><p>Most alkalmazhatjuk a Modus Ponenst az <span class="emphasis"><em>Sz</em></span><sub>8</sub>-ra és az <span class="emphasis"><em>Sz</em></span><sub>4</sub> érzetre (például a ←<span class="emphasis"><em>S</em></span><sub>1,1</sub>) és így kapjuk: </p><p><code class="code"><em><span class="remark">Sz</span></em><sub>9</sub>: ¬(<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) </code></p><p>Végül alkalmazzuk a De Morgan-szabályt, amely a konklúziót adja:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>10</sub>: ¬<em><span class="remark">C</span></em><sub>1,2</sub> ∧ ¬<em><span class="remark">C</span></em><sub>2,1</sub> </code></p><p>Tehát sem az [1, 2], sem a [2, 1] négyzet nem tartalmaz csapdát. </p><p>Az előző levezetést – következtetési szabályok egy sorozatát – <span class="strong"><strong>bizonyítás</strong></span>nak (<span class="strong"><strong>proof</strong></span>) nevezzük. A bizonyítás megtalálása pontosan olyan, mint megoldást találni egy keresési problémára. Valójában ha a következtetési szabályok összes lehetséges alkalmazásának generálására egy új állapotátmenet-függvényt definiálnánk, akkor minden, a 3. és 4. fejezetbeli kereső algoritmust felhasználhatnánk a bizonyítás megtalálására. A bizonyítás keresése tehát egy alternatívája a modellek felsorolásának. A keresés haladhat előrefelé a kezdeti tudásbázisból kiindulva, alkalmazva a következtetési szabályokat a célmondat levezetéséhez, vagy mehet visszafelé a célmondatból, megpróbálva megtalálni a következtetési szabályoknak olyan láncolatát, amely a kiindulási tudásbázisra alkalmazható szabályokból indul. A fejezetben később bemutatunk két olyan algoritmuscsaládot, amelyek ezeket a technikákat használják. </p><a id="ID_267_oldal"/><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Az a tény, hogy a következtetés az ítéletlogikában NP-teljes, azt sugallja, hogy a legrosszabb esetet tekintve a bizonyítások keresése sem hatékonyabb a modellek felsorolásánál. Számos gyakorlati esetben azonban, <span class="emphasis"><em>α bizonyítás megtalálása sokkal hatékonyabb lehet, egyszerűen azért, mert képes figyelmen kívül hagyni az irreleváns állításokat, függetlenül attól, hogy hány van belőlük</em></span>. Például az előző bizonyítás, amely elvezetett a ¬<span class="emphasis"><em>C</em></span><sub>1,2</sub> ∧ ¬<span class="emphasis"><em>C</em></span><sub>2,1</sub> mondathoz, nem említi az <span class="emphasis"><em>S</em></span><sub>2,1</sub>, <span class="emphasis"><em>C</em></span><sub>1,1</sub>, <span class="emphasis"><em>C</em></span><sub>2,2</sub> vagy a <span class="emphasis"><em>C</em></span><sub>1,2</sub> állításokat. Ezeket azért lehet figyelmen kívül hagyni, mert a <span class="emphasis"><em>C</em></span><sub>1,2</sub> célállítás csak az <span class="emphasis"><em>Sz</em></span><sub>2</sub>-ben jelenik meg, az <span class="emphasis"><em>Sz</em></span><sub>2</sub>-ben szereplő egyéb állítások pedig csak az <span class="emphasis"><em>Sz</em></span><sub>2</sub>-ben és az <span class="emphasis"><em>Sz</em></span><sub>4</sub>-ben, így az <span class="emphasis"><em>Sz</em></span><sub>1</sub>, <span class="emphasis"><em>Sz</em></span><sub>3 </sub>és <span class="emphasis"><em>Sz</em></span><sub>5</sub> szabályoknak nincs kihatásuk a bizonyításra. Ugyanez maradna a helyzet, ha még millió szabályt hozzáadnánk a tudásbázishoz, miközben az igazságtábla algoritmust ezzel ellentétben elárasztaná a modellek exponenciális robbanása. </p></div><p>A logikai rendszereknek ez a tulajdonsága valójában egy sokkal alapvetőbb jellegzetességükből, a <span class="strong"><strong>monotonitás</strong></span>ból (<span class="strong"><strong>monotonicity</strong></span>) következik. A monotonitás azt mondja ki, hogy a vonzatmondatok halmaza csak bővülhet, ha a tudásbázishoz információt adunk hozzá.<sup>[<a id="id583439" href="#ftn.id583439" class="footnote">69</a>]</sup><sup> </sup></p><p><code class="code">ha 	<em><span class="remark">TB </span></em>⊨<em><span class="remark"> α	</span></em>    akkor      <em><span class="remark">TB </span></em>∧<em><span class="remark"> β </span></em>⊨<em><span class="remark"> α</span></em></code></p><p>Például feltételezzük azt, hogy a tudásbázis tartalmaz egy új <span class="emphasis"><em>β</em></span>  állítást, amely azt mondja ki, hogy pontosan 8 csapda van a világban. Ez a tudás segítheti az ágenst további konklúziók levezetésében, de nem teheti érvénytelenné egyik korábban kikövetkeztetett <span class="emphasis"><em>α</em></span> konklúziót sem – így azt a konklúziót sem, hogy nincsen csapda az [1, 2]-ben. A monotonitás azt jelenti, hogy a következtetési szabályok bármikor alkalmazhatók, ha a megfelelő premisszák megtalálhatók a tudásbázisban – a szabály konklúziójának következnie kell, <span class="emphasis"><em>függetlenül attól, hogy mi más is van még a tudásbázisban</em></span>.</p><div class="section" title="Rezolúció"><div class="titlepage"><div><div><h2 class="title"><a id="id583489"/>Rezolúció</h2></div></div></div><a id="ID_268_oldal"/><p class="3">Megmutattuk, hogy az eddig ismertetett következtetési szabályok helyesek, de nem tárgyaltuk az ezeket használó következtetési algoritmusok <span class="emphasis"><em>teljességének</em></span> kérdését. A keresési algoritmusok, mint az iteratívan mélyülő keresés <a class="xref" href="ch03s04.md#ID_118_oldal">„Iteratívan mélyülő mélységi keresés”</a> részben teljesek abban az értelemben, hogy meg fogják találni az elérendő célt. Ha azonban a rendelkezésre álló szabályok hiányosak, akkor a cél nem érhető el – nem létezik olyan bizonyítás, amely csak ezeket a szabályokat használja. Például ha kivennénk az ekvivalencia kiküszöbölés szabályt, az előző fejezetbeli bizonyítás nem futna végig. Ez a fejezet egyetlen következtetési szabályt mutat be, a <span class="strong"><strong>rezolúció</strong></span>t (<span class="strong"><strong>resolution</strong></span>), amelynek alkalmazása, párosítva bármelyik teljes keresési módszerrel, egy teljes következtetési algoritmust eredményez. </p><p>Először a rezolúciós szabály egy egyszerű változatát fogjuk használni a wumpus világban. Nézzük meg a 7.4. (a) ábrához vezető lépéseket: az ágens visszafordul a [2,  1]-ből az [1,  1]-be, és innen megy az [1, 2]-be, ahol szellőt érez, de bűzt nem. A következő tényeket adjuk hozzá a tudásbázishoz:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>11</sub>: ¬<em><span class="remark">S</span></em><sub>1,2</sub></code></p><p><code class="code"><em><span class="remark">Sz</span></em><sub>12</sub>: <em><span class="remark">S</span></em><sub>1,2</sub> ⇔ (<em><span class="remark">C</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>2,2</sub> ∨ <em><span class="remark">C</span></em><sub>1,3</sub>) </code></p><p>Ugyanazzal a folyamattal, amely az <span class="emphasis"><em>Sz</em></span><sub>10</sub>-hez vezetett korábban, most le tudjuk vezetni, hogy nincs csapda a [2, 2]-ben és az [1,  3]-ban (emlékezzünk, hogy már tudjuk, hogy az [1, 1] csapdamentes):</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>13</sub>: ¬<em><span class="remark">C</span></em><sub>2,2</sub></code></p><p><code class="code"><em><span class="remark">Sz</span></em><sub>14</sub>: ¬<em><span class="remark">C</span></em><sub>1,3</sub></code></p><p>Az <span class="emphasis"><em>Sz</em></span><sub>3</sub>-ra is alkalmazhatjuk az ekvivalencia kiküszöbölést, amelyet egy Modus Ponens követ az <span class="emphasis"><em>Sz</em></span><sub>5</sub>-re, hogy megkapjuk azt a tényt, hogy csapda van az [1, 1], a [2,  2] vagy a [3, 1] négyzetekben:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>15</sub>: <em><span class="remark">C</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>2,2</sub> ∨ <em><span class="remark">C</span></em><sub>3,1 </sub></code></p><p>Most következik a rezolúció szabály első alkalmazása: a ¬<span class="emphasis"><em>C</em></span><sub>2,2<span class="emphasis"><em> </em></span></sub>literál az <span class="emphasis"><em>Sz</em></span><sub>13</sub>-ban <span class="emphasis"><em>rezolvál</em></span> a <span class="emphasis"><em>C</em></span><sub>2,2<span class="emphasis"><em> </em></span></sub>literállal az <span class="emphasis"><em>Sz</em></span><sub>15</sub>-ben, amely ezt adja:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>16</sub>: <em><span class="remark">C</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>3,1 </sub></code></p><p>Magyarul, ha van egy csapda az [1, 1], [2, 2], [3, 1] négyzetek egyikében, és ez a csapda nem a [2, 2]-ben van, akkor ez az [1, 1]-ben vagy a [3, 1]-ben van. Hasonlóan a ¬<span class="emphasis"><em>C</em></span><sub>1,1 </sub>literál az <span class="emphasis"><em>Sz</em></span><sub>1</sub>-ben rezolvál a <span class="emphasis"><em>C</em></span><sub>1,1<span class="emphasis"><em> </em></span></sub>literállal az <span class="emphasis"><em>Sz</em></span><sub>16</sub>-ban, amiből adódik:</p><p><code class="code"><em><span class="remark">Sz</span></em><sub>17</sub>: <em><span class="remark">C</span></em><sub>3,1 </sub></code></p><p>Tehát, ha van egy csapda az [1, 1]-ben vagy a [3, 1]-ben, és ez a csapda nem az [1, 1]-ben van, akkor ez a [3, 1]-ben van. Ez az utolsó két következtetési lépés példa az <span class="strong"><strong>egységrezolúció</strong></span> (<span class="strong"><strong>unit resolution</strong></span>) következtetési szabályra,</p><p><span class="inlinemediaobject"><img src="math/mi-07-0011.gif" alt="Rezolúció"/></span></p><p>ahol <span class="emphasis"><em>ℓ</em></span> egy literál, <span class="emphasis"><em>ℓ<sub>i</sub></em></span> és <span class="emphasis"><em>m</em></span> pedig <span class="strong"><strong>kiegészítő literál</strong></span>ok (<span class="strong"><strong>complementary literal</strong></span>s) (például az egyik negáltja a másiknak). Tehát az egységrezolúció vesz egy <span class="strong"><strong>klóz</strong></span>t (<span class="strong"><strong>clause</strong></span>) – literálok diszjunkcióját – meg egy literált, és létrehoz egy új klózt. Vegyük észre, hogy egy egyedi literált tekinthetünk egy literál diszjunkciójának, amit szoktak <span class="strong"><strong>egységklóz</strong></span>nak (<span class="strong"><strong>un</strong></span><span class="strong"><strong>it clause</strong></span>) is nevezni.</p><p>Az egységrezolúció szabálya általánosítható teljes <span class="strong"><strong>rezolúció</strong></span>s (<span class="strong"><strong>resolution</strong></span>) szabállyá,</p><p><span class="inlinemediaobject"><img src="math/mi-07-0012.gif" alt="Rezolúció"/></span></p><p>ahol <span class="emphasis"><em>ℓ<sub>i</sub></em></span> és <span class="emphasis"><em>m<sub>j</sub></em></span> kiegészítő literálok. Ha csak kettő hosszúságú klózokkal foglalkozunk, akkor ezt írhatjuk:</p><p><span class="inlinemediaobject"><img src="math/mi-07-0013.gif" alt="Rezolúció"/></span></p><p>Azaz a rezolúció vesz két klózt, és létrehoz egy új klózt, amely tartalmaz minden literált az eredeti két klózból, kivéve a kiegészítő literálokat. Például:</p><p><span class="inlinemediaobject"><img src="math/mi-07-0014.gif" alt="Rezolúció"/></span></p><p>Van még egy technikai aspektusa a rezolúciós szabálynak: az eredményklóznak minden literálnak csak egy példányát kell tartalmaznia.<sup>[<a id="id583860" href="#ftn.id583860" class="footnote">70</a>]</sup><sup> </sup>A literálok többszörös példányainak kivonását <span class="strong"><strong>faktorálás</strong></span> (<span class="strong"><strong>factoring</strong></span>) hívják. Például ha rezolváljuk az (<span class="emphasis"><em>A </em></span>∨ <span class="emphasis"><em>B</em></span>)-t a (<span class="emphasis"><em>A </em></span>∨ ¬<span class="emphasis"><em>B</em></span>)-vel, akkor (<span class="emphasis"><em>A </em></span>∨ <span class="emphasis"><em>A</em></span>)-t kapunk, amelyet redukálhatunk egyszerűen <span class="emphasis"><em>A</em></span>-ra.</p><p class="index">A rezolúciós szabály <span class="emphasis"><em>helyes</em></span>sége egyszerűen belátható, ha megvizsgáljuk az <span class="emphasis"><em>l<sub>i</sub></em></span> literált. Ha <span class="emphasis"><em>l<sub>i</sub></em></span> igaz, akkor <span class="emphasis"><em>m<sub>j </sub></em></span>hamis, és így <span class="emphasis"><em>m</em></span><sub>1</sub> ∨…∨ <span class="emphasis"><em>m</em></span><sub><span class="emphasis"><em>j</em></span>–l</sub> ∨ <span class="emphasis"><em>m</em></span><sub><span class="emphasis"><em>j</em></span>+l</sub> ∨…∨ <span class="emphasis"><em>m<sub>n</sub></em></span>-nek igaznak kell lennie, mert <span class="emphasis"><em>m</em></span><sub>1</sub><span class="emphasis"><em> </em></span>∨…∨ <span class="emphasis"><em>m<sub>n</sub></em></span> adott. Ha <span class="emphasis"><em>ℓ<sub>i</sub></em></span> hamis, akkor <span class="emphasis"><em>ℓ</em></span><sub>1</sub> ∨…∨ <span class="emphasis"><em>ℓ</em></span><sub><span class="emphasis"><em>i</em></span>–l</sub> ∨ <span class="emphasis"><em>ℓ</em></span><sub><span class="emphasis"><em>i</em></span>+l</sub> ∨…∨ <span class="emphasis"><em>ℓ<sub>k</sub></em></span> igaz kell, hogy legyen, mivel <span class="emphasis"><em>ℓ<sub>i</sub> </em></span>∨…∨ <span class="emphasis"><em>ℓ<sub>k  </sub></em></span>adott. Így <span class="emphasis"><em>ℓ<sub>i</sub></em></span> akár igaz, akár hamis, az egyik vagy a másik konklúzió áll, pontosan úgy, ahogy a szabály ezt kimondja.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Ami még meglepőbb a rezolúciós szabállyal kapcsolatban, hogy a rezolúció alapjául szolgál <span class="emphasis"><em>teljes</em></span> következtetési algoritmusok egy családjának. <span class="emphasis"><em>Bármely teljes keresési algoritmus, a rezolúciós szabályt alkalmazva, az ítéletlogikában képes levezetni bármilyen konklúziót, amely vonzata a tudásbázisnak. </em></span>Egy figyelmeztetés: a rezolúció csak egy speciális értelemben teljes. Ha adott, hogy <span class="emphasis"><em>A</em></span> igaz, akkor nem tudjuk a rezolúciót arra használni, hogy levezessük az <span class="emphasis"><em>A </em></span>∨ <span class="emphasis"><em>B</em></span> konzekvenciát. Azonban tudjuk arra használni a rezolúciót, hogy megválaszoljuk azt a kérdést, hogy <span class="emphasis"><em>A </em></span>∨ <span class="emphasis"><em>B</em></span> igaz-e. Ezt <span class="strong"><strong>megcáfolási teljesség</strong></span>nek (<span class="strong"><strong>refutation completeness</strong></span>) nevezik, ami azt jelenti, hogy a rezolúció mindig használható arra, hogy megerősítsünk vagy megcáfoljunk egy mondatot, de nem alkalmazható az igaz mondatok felsorolására. A következő két alfejezet azt magyarázza el, hogy a rezolúció hogyan oldja ezt meg.</p></div><div class="section" title="Konjunktív normál forma"><div class="titlepage"><div><div><h3 class="title"><a id="id584064"/>Konjunktív normál forma</h3></div></div></div><a id="ID_269_oldal"/><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p class="4 cím">A rezolúciós szabály csak literálok diszjunkcióira alkalmazható, így úgy tűnhet, hogy ez csak olyan tudásbázis és lekérdezés esetében érdekes, amelyek ilyen diszjunkciókat tartalmaznak. Akkor hogyan vezet ez egy teljes következtetési eljáráshoz az egész ítéletkalkulus számára? A válasz az, hogy <span class="emphasis"><em>minden ítéletkalkulus mondat logikailag ekvivalens literálok diszjunkcióinak konjunkcióival. </em></span>Egy mondatot, amelyet literálok diszjunkcióinak konjunkcióival fejezünk ki, <span class="strong"><strong>konjunktív normál formá</strong></span>júnak (<span class="strong"><strong>conjunctive normal form</strong></span>) vagy <span class="strong"><strong>CNF</strong></span> formájúnak nevezünk. A későbbiekben az is hasznos lesz, ha ennek egy korlátosabb családját, a <span class="bold"><strong><span class="emphasis"><em>k</em></span>-CNF</strong></span> mondatokat tekintjük. Egy mondat a <span class="emphasis"><em>k</em></span>-CNF-be tartozik, ha pontosan <span class="emphasis"><em>k</em></span> literál van a klózokban.</p></div><p><code class="code"> (<em><span class="remark">ℓ</span></em><sub> l, l</sub> ∨…∨ <em><span class="remark">ℓ</span></em><sub> 1, <em><span class="remark">k</span></em></sub>) ∧…∧ (<em><span class="remark"> ℓ</span></em><sub><em><span class="remark"> n</span></em>, l</sub> ∨…∨ <em><span class="remark">ℓ</span></em><sub><em><span class="remark"> n</span></em>, <em><span class="remark">k</span></em></sub>)</code></p><p>Ki fog derülni, hogy minden mondat transzformálható 3-CNF mondattá úgy, hogy azonos marad a modellek halmaza. </p><p>Ahelyett hogy bizonyítanánk ezeket a kijelentéseket (lásd 7.10. feladat), leírunk egy egyszerű konvertáló eljárást. Az eljárást az <span class="emphasis"><em>Sz</em></span><sub>2</sub> szabály, az <span class="emphasis"><em>S</em></span><sub>1,1</sub> ⇔ (<span class="emphasis"><em>C</em></span><sub>1,2</sub> ∨ <span class="emphasis"><em>C</em></span><sub>2,1</sub>) mondat CNF-re konvertálásával illusztráljuk. A lépések a következők:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Küszöböljük ki a ⇔ összekötőjelet, helyettesítve az <span class="emphasis"><em>α</em></span> ⇔ <span class="emphasis"><em>β</em></span>-t (<span class="emphasis"><em>α </em></span>⇒ <span class="emphasis"><em>β</em></span>) ∧ (<span class="emphasis"><em>β</em></span>⇒ <span class="emphasis"><em>α</em></span>)-vel:</p></li></ol></div><p><code class="code">	(<em><span class="remark">S</span></em><sub>1,1</sub> ⇒ (<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>)) ∧ ((<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ⇒ <em><span class="remark">S</span></em><sub>1,1</sub>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Kiküszöböljük az ⇒ összekötőjelet, kicserélve  α⇒ <span class="emphasis"><em>β</em></span>t ¬α  ∨ <span class="emphasis"><em>β</em></span>-ra:</p></li></ol></div><p><code class="code">	(¬<em><span class="remark">S</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ∧ (¬ (<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ∨ <em><span class="remark">S</span></em><sub>1,1</sub>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">A CNF megkívánja, hogy a ¬ csak literálokra vonatkozzon, így most „a-t beljebb mozgatjuk” a következő 7.11. ábrán felírt ekvivalenciák ismételt alkalmazásával:</p></li></ol></div><p><code class="code">	¬(¬<em><span class="remark">α</span></em>) ≡ <em><span class="remark">β </span></em>   		kettős negáció kiküszöbölés</code></p><p><code class="code">	¬(<em><span class="remark">α </span></em>∧ <em><span class="remark">β</span></em>)  ≡ (¬<em><span class="remark">α </span></em> ∨ ¬<em><span class="remark">β</span></em>)	De Morgan</code></p><p><code class="code">	¬(<em><span class="remark">α</span></em> ∨ <em><span class="remark">β</span></em>) ≡ (¬<em><span class="remark">α</span></em> ∧ ¬<em><span class="remark">β </span></em>)	De Morgan</code></p><p>A példában csak az utolsó szabály alkalmazására van szükségünk:</p><p><code class="code">	(¬ <em><span class="remark">S</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ∧ ((¬<em><span class="remark">C</span></em><sub>1,2</sub> ∧ ¬<em><span class="remark">C</span></em><sub>2,1</sub>) ∨ <em><span class="remark">S</span></em><sub>1,1</sub>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Most van egy mondatunk, amelyben egymásba ágyazott ∧ és ∨ operátorok vannak alkalmazva a literálokra. A 7.11. ábrán bevezetett disztributivitás szabályt alkalmazzuk a ∨ operátorokra az ∧ felett mindenhol, ahol lehetséges.</p></li></ol></div><p><code class="code">	(¬<em><span class="remark">S</span></em><sub>1,1</sub> ∨ <em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>) ∧ (¬<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">S</span></em><sub>1,1</sub>) ∧ (¬<em><span class="remark">C</span></em><sub>2,1</sub> ∨ <em><span class="remark">S</span></em><sub>1,1</sub>)</code></p><p>Az eredeti mondat most már CNF-ben van, három klóz konjunkciójaként. Bár sokkal nehezebb olvasni ezt a formát, de használható a rezolúciós eljárás bemeneteként.</p></div><div class="section" title="A rezolúció algoritmus"><div class="titlepage"><div><div><h3 class="title"><a id="id584455"/>A rezolúció algoritmus </h3></div></div></div><p class="4 cím">A rezolúción alapuló következtetési eljárások az ellentmondásokra vezető bizonyítások elvén működnek, ahogy azt a 7.4. alfejezet végén tárgyaltuk. Tehát annak megmutatásához, hogy ΤΒ ⊨<span class="emphasis"><em> α</em></span>, azt mutatjuk meg, hogy a (<span class="emphasis"><em>TB</em></span> ∧ ¬<span class="emphasis"><em>α</em></span>) kielégíthetetlen. Ezt az ellentmondás bizonyításával végezzük el. </p><p>A rezolúció algoritmust mutatja a 7.12. ábra. Először a (<span class="emphasis"><em>TB</em></span> ∧ ¬<span class="emphasis"><em>α</em></span>)-t konvertáljuk CNF formára. Majd a rezolúciós szabályt alkalmazzuk a létrejövő klózokra. Minden egyes párt, amely kiegészítő literálokat tartalmaz, rezolválunk, hogy egy új klózt hozzunk létre, amelyet hozzáadunk a halmazhoz, ha még nem volt jelen. A folyamat addig folytatódik, amíg a következő két dolog közül valamelyik meg nem történik:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">nincs több új klóz, amit hozzá lehet adni, ilyen esetben <span class="emphasis"><em>α</em></span> nem vonzza maga után <span class="emphasis"><em>β</em></span>-t.</p></li><li class="listitem"><p class="List Paragraph">	a rezolúció alkalmazása egy <span class="emphasis"><em>üres</em></span> klózra vezet, amely esetben <span class="emphasis"><em>α</em></span> -nak vonzata <span class="emphasis"><em>β</em></span> .</p></li></ul></div><p>Az üres klóz – egy diszjunkt nélküli diszjunkció – ekvivalens a <span class="emphasis"><em>Hamis</em></span> értékkel, mert a diszjunkció akkor igaz csak, ha legalább az egyik diszjunkt igaz. ∨gy is beláthatjuk, hogy az üres klóz ellentmondást reprezentál, hogy megfigyeljük azt, hogy az üres klóz két kiegészítő egységklóz, mint amilyen az <span class="emphasis"><em>S</em></span> és ¬<span class="emphasis"><em>S</em></span>, rezolválásából származik. </p><div class="figure"><a id="id584528"/><p class="title"><strong>7.12. ábra - Egy egyszerű rezolúciós algoritmus az ítéletkalkulushoz. Az IK-<code class="code">REZOLVÁLÁS</code> a két bemenetként megkapott állítás rezolválásából származó összes lehetséges klóz halmazát adja vissza.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-12.png" alt="Egy egyszerű rezolúciós algoritmus az ítéletkalkulushoz. Az IK-REZOLVÁLÁS a két bemenetként megkapott állítás rezolválásából származó összes lehetséges klóz halmazát adja vissza."/></div></div></div><p>Alkalmazzuk a rezolúciós eljárást egy nagyon egyszerű következtetésre a wumpus világban. Amikor az ágens az [1,1]-ben van, akkor nincs szellő, tehát nincs csapda a szomszédos négyzetekben. Az ennek megfelelő tudásbázis:</p><p><code class="code"><em><span class="remark">TB </span></em>=<em><span class="remark"> Sz</span></em><sub>2</sub> ∧ <em><span class="remark">Sz</span></em><sub>4</sub> = (<em><span class="remark">S</span></em><sub>1,1</sub> ⇔ (<em><span class="remark">C</span></em><sub>1,2</sub> ∨ <em><span class="remark">C</span></em><sub>2,1</sub>)) ∧ ¬<em><span class="remark">S</span></em><sub>1,1</sub></code></p><p>és mi bizonyítani szeretnénk <span class="emphasis"><em>α</em></span>-t, ami mondjuk ¬<span class="emphasis"><em>C</em></span><sub>1,2</sub>. Amikor konvertáljuk a (<span class="emphasis"><em>TB </em></span>∧ ¬α)-t CNF formára, akkor a 7.13. ábra felső részén látható klózokat kapjuk. Az ábra második sora mutatja az összes klózt, amit az első sor párjainak rezolválásából kaptunk. És akkor, amikor a <span class="emphasis"><em>C</em></span><sub>1,2</sub>-t rezolváljuk ¬<span class="emphasis"><em>C</em></span><sub>1,2</sub>-vel megkapjuk az üres klózt, amit egy kis négyzet jelöl. A 7.13. ábra megvizsgálása azt mutatja, hogy számos rezolúciós lépés felesleges. Például az <span class="emphasis"><em>S</em></span><sub>1,1</sub> ∨ ¬<span class="emphasis"><em>S</em></span><sub>1,1</sub> ∨ <span class="emphasis"><em>C</em></span><sub>1,2</sub> ekvivalens az <span class="emphasis"><em>Igaz </em></span>∨ <span class="emphasis"><em>C</em></span><sub>1,2</sub>-vel, ami ekvivalens az <span class="emphasis"><em>Igaz</em></span>zal. Levezetni, hogy az <span class="emphasis"><em>Igaz</em></span> az igaz, nem igazán hasznos. Így bármely olyan klóz, amelyben két kiegészítő klóz szerepel, figyelmen kívül hagyható.</p><div class="figure"><a id="id586104"/><p class="title"><strong>7.12. ábra - Az <code class="code">IK-REZOLÚCIÓ</code> algoritmus részleges alkalmazása egy egyszerű wumpus világbeli következtetésre. A felső sor első négy klóza alapján származtatjuk a ¬<span class="emphasis"><em>P</em></span><sub>1,2</sub>-t.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-12.png" alt="Az IK-REZOLÚCIÓ algoritmus részleges alkalmazása egy egyszerű wumpus világbeli következtetésre. A felső sor első négy klóza alapján származtatjuk a ¬P1,2-t."/></div></div></div></div><div class="section" title="A rezolúció teljessége"><div class="titlepage"><div><div><h3 class="title"><a id="id586123"/>A rezolúció teljessége</h3></div></div></div><p class="4 cím">Hogy befejezzük a rezolúció tárgyalását, most megmutatjuk, hogy az <code class="code">IK-REZOLÚCIÓ</code> algoritmus teljes. Ahhoz, hogy ezt megtehessük, hasznos bevezetni az <span class="emphasis"><em>S</em></span> klózok halmazának <span class="strong"><strong>rezolúciós lezárt</strong></span>ját (<span class="strong"><strong>resolution closure</strong></span>), <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S</em></span>)-t, ami az összes olyan klóz halmaza, amely levezethető a rezolúció ismételt alkalmazásaival az <span class="emphasis"><em>S</em></span> halmazbeli elemekből és ezek leszármazottaiból. Az <code class="code">IK-REZOLÚCIÓ</code> a rezolúciós lezárás halmaz elemeit sorolja fel a <span class="emphasis"><em>klózok</em></span> változóban. Könnyű belátni, hogy <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S</em></span>)-nek végesnek kell lennie, mert véges sok különböző klózt lehetséges konstruálni az <span class="emphasis"><em>P</em></span><sub>1</sub>, …,<span class="emphasis"><em> P<sub>k</sub></em></span> szimbólumokból, amelyek elemei <span class="emphasis"><em>S</em></span>-nek. (Vegyük észre, hogy ez nem volna igaz a faktorálási lépés nélkül, amely megszünteti a literálok többszöröződését.) Így az <code class="code">IK-REZOLÚCIÓ</code> mindig terminálódik.</p><a id="ID_272_oldal"/><p>Az ítéletlogikában a rezolúció teljességi tételét <span class="strong"><strong>alap rezolúciós tétel</strong></span>nek (<span class="strong"><strong>ground resolution theorem</strong></span>) nevezzük. </p><p>Ha klózok egy halmaza kielégíthetetlen, akkor ezeknek a klózoknak a rezolúciós lezártja tartalmazza az üres klózt.</p><p>A tételt az ellentétjének demonstrálásával bizonyítjuk: ha az <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S</em></span>) lezártja nem tartalmaz üres halmazt, akkor <span class="emphasis"><em>S</em></span> kielégíthető. Valójában egy modellt konstruálunk <span class="emphasis"><em>S</em></span>-nek a megfelelő <span class="emphasis"><em>P</em></span><sub>1</sub>, …, <span class="emphasis"><em>P<sub>k</sub></em></span> igazság értékekkel. A konstrukciós eljárás a következő: </p><p>Minden <span class="emphasis"><em>i-</em></span>re 1-től <span class="emphasis"><em>k</em></span>-ig,</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Ha létezik egy klóz <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S</em></span>)-ben, amely tartalmazza a ¬<span class="emphasis"><em>P<sub>i</sub></em></span> literált úgy, hogy minden más literál hamis a választott <span class="emphasis"><em>P</em></span><sub>1</sub>, …, <span class="emphasis"><em>P</em></span><sub><span class="emphasis"><em>i</em></span>–1</sub> hozzárendelés szerint, akkor rendeljünk <span class="emphasis"><em>hamis</em></span> értéket <span class="emphasis"><em>P<sub>i</sub></em></span>-hez.</p></li><li class="listitem"><p class="List Paragraph">	Egyébként rendeljünk <span class="emphasis"><em>igaz</em></span> értéket <span class="emphasis"><em>P<sub>i</sub></em></span>-hez.</p></li></ul></div><p>Az maradt hátra, hogy megmutassuk, hogy ez a <span class="emphasis"><em>P</em></span><sub>1</sub>, …, <span class="emphasis"><em>P<sub>k</sub></em></span> hozzárendelés modellje <span class="emphasis"><em>S</em></span>-nek, feltéve, hogy <span class="emphasis"><em>RC</em></span>(<span class="emphasis"><em>S</em></span>) zárt a rezolúcióra, és nem tartalmazza az üres klózt. Ennek bizonyítását meghagyjuk feladatnak.</p></div></div><div class="section" title="Előre- és hátrafelé láncolás"><div class="titlepage"><div><div><h2 class="title"><a id="id586333"/>Előre- és hátrafelé láncolás</h2></div></div></div><a id="ID_273_oldal"/><p class="3">A rezolúciót a teljesség tulajdonsága igen fontos következtetési módszerré teszi. Számos gyakorlati esetben azonban, a rezolúció teljes erejére nincs szükség. A valósvilág-beli tudásbázisok gyakran a klózoknak csak egy, <span class="strong"><strong>Horn-klóz</strong></span>nak (<span class="strong"><strong>Horn claus</strong></span>e) nevezett korlátosabb fajtáját tartalmazzák. A Horn-klóz literálok olyan diszjunkciója, amelyek közül legfeljebb egy pozitív. Például a (¬<span class="emphasis"><em>P</em></span><sub>1,1</sub> ∨ ¬<span class="emphasis"><em>Szellő </em></span>∨ <span class="emphasis"><em>S</em></span><sub>1,1</sub>) klóz, ahol <span class="emphasis"><em>P</em></span><sub>1,1</sub><span class="emphasis"><em> </em></span>jelenti, hogy az ágens pozíciója az [1, 1], egy Horn-klóz, míg az (<span class="emphasis"><em>S</em></span><sub>1,1</sub> ∨ <span class="emphasis"><em>C</em></span><sub>1,2</sub> ∨ <span class="emphasis"><em>C</em></span><sub>2,1</sub>)<span class="emphasis"><em> </em></span>nem az. </p><p>A korlátozás, hogy csak egy pozitív literál lehet, egy kissé önkényesnek és érdektelennek tűnhet, de valójában nagyon fontos, három ok miatt is:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Minden Horn-klóz felírható egy implikációként is, amelynek premisszája pozitív literálok konjunkciója, és konklúziója egyetlen pozitív literál (lásd 7.12. feladat). Például a (<span class="emphasis"><em>P</em></span><sub>1,1 </sub>∨ <span class="emphasis"><em>Szellő </em></span>∨<span class="emphasis"><em> S</em></span><sub>1,1</sub>) Horn-klóz átírható a (<span class="emphasis"><em>P</em></span><sub>1,1</sub><span class="emphasis"><em> </em></span>∧ <span class="emphasis"><em>Szellő</em></span>) ⇒ <span class="emphasis"><em>S</em></span><sub>1,1 </sub> implikációra. Ebben az utóbbi formájában sokkal könnyebb olvasni a mondatot: azt mondja ki, hogyha az ágens az [1, 1]-ben van, és szellő érzékelhető ott, akkor az [1, 1] szellős. Számos területen az emberek számára könnyű a tudást ilyen mondatok formájában olvasni és leírni.</p><p>A Horn-klózokat, mint amilyen az előbbi, vagyis amelyben <span class="emphasis"><em>pontosan</em></span> egy pozitív literál van, <span class="strong"><strong>határozott klóz</strong></span>oknak (<span class="strong"><strong>definite clause</strong></span>s) nevezik. A pozitív literál a <span class="strong"><strong>fej</strong></span> (<span class="strong"><strong>head</strong></span>), míg a negatív literálok alkotják a klóz <span class="strong"><strong>test</strong></span>ét (<span class="strong"><strong>body</strong></span>). Egy negatív literálok nélküli határozott klóz egyszerűen kijelent egy adott állítást, amit gyakran <span class="strong"><strong>tény</strong></span>nek (<span class="strong"><strong>fact</strong></span>) neveznek. A határozott klózok formálják a <span class="strong"><strong>logikai programozás</strong></span> (<span class="strong"><strong>logic programming</strong></span>) alapját, amelyet a 9. fejezetben tárgyalunk. Egy pozitív literálok nélküli Horn-klóz felírható, mint egy olyan implikáció, amelynek a konklúziója a <span class="emphasis"><em>Hamis</em></span> literál. Például a (¬<span class="emphasis"><em>W</em></span><sub>1,1</sub> ∨ ¬<span class="emphasis"><em>W</em></span><sub>1,2</sub>) klóz – a wumpus nem lehet mind az [1, 1], mind az [1, 2] mezőben, ekvivalens a <span class="emphasis"><em>W</em></span><sub>1,1</sub> ∧ <span class="emphasis"><em>W</em></span><sub>1,2</sub> ⇒<span class="emphasis"><em> Hamis</em></span> mondattal. Az ilyen mondatokat <span class="strong"><strong>integritás kényszer</strong></span>eknek (<span class="strong"><strong>integrity constraint</strong></span>s) nevezzük az adatbázis-kezelés területén, ahol adathibák jelzésére használják. A következőkben bemutatásra kerülő algoritmusokban az egyszerűség kedvéért feltételezzük, hogy a tudásbázis csak határozott klózokat tartalmaz, és nincsenek benne integritáskényszerek. Azt mondjuk, hogy ezek a tudásbázisok Horn-formában vannak.</p></li><li class="listitem"><p class="List Paragraph">A Horn-klózokon történő következtetés történhet az <span class="strong"><strong>előrefelé láncolás</strong></span> (<span class="strong"><strong>forward chaining</strong></span>) vagy a<span class="strong"><strong> hátrafelé láncolás</strong></span> (<span class="strong"><strong>backward chaining</strong></span>) algoritmusokkal, amelyeket a következőkben elmagyarázunk. Mindkét algoritmus igen természetes, a következtetési lépések nyilvánvalóak és egyszerűen követhetőek az emberek számára. </p></li><li class="listitem"><p class="List Paragraph">A maga után vonzás kérdésének eldöntéséhez szükséges idő lineárisan függ a tudásbázis méretétől.</p></li></ol></div><div class="figure"><a id="id586568"/><p class="title"><strong>7.14. ábra - Előrefelé láncolás algoritmus az ítéletkalkulus számára. Az <span class="emphasis"><em>agenda</em></span> tartalmazza azokat a  szimbólumokat, amelyek ismerten igazak, de még nem „dolgozták fel” őket. A <span class="emphasis"><em>számol</em></span> tábla követi, hogy az egyes implikációknak hány premisszája ismeretlen. Ha az agendáról egy új <span class="emphasis"><em>p</em></span> szimbólumot feldolgozunk, minden olyan implikáció számlálója csökken eggyel, amelynek premisszájában <span class="emphasis"><em>p</em></span> megjelenik. (Ez megoldható konstans időben, ha a <span class="emphasis"><em>TB</em></span> megfelelően indexelt.) Ha a számláló eléri a nullát, azaz az implikáció minden premisszája ismert, akkor az implikáció konklúzióját hozzá lehet adni az agendához. Végül szükségünk van arra, hogy kövessük melyik szimbólumot dolgoztuk már fel; egy kikövetkeztetett szimbólumot nem kell hozzáadni az agendához, ha azt már korábban sikeresen feldolgoztuk. Így elkerülhető a redundáns munka, és megakadályozza a végtelen ciklusok kialakulását, amelyet olyan implikációk okozhatnak, mint a <span class="emphasis"><em>P</em></span> ⇒ <span class="emphasis"><em>Q</em></span> és <span class="emphasis"><em>Q</em></span> ⇒ <span class="emphasis"><em>P</em></span>.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-14.png" alt="Előrefelé láncolás algoritmus az ítéletkalkulus számára. Az agenda tartalmazza azokat a szimbólumokat, amelyek ismerten igazak, de még nem „dolgozták fel” őket. A számol tábla követi, hogy az egyes implikációknak hány premisszája ismeretlen. Ha az agendáról egy új p szimbólumot feldolgozunk, minden olyan implikáció számlálója csökken eggyel, amelynek premisszájában p megjelenik. (Ez megoldható konstans időben, ha a TB megfelelően indexelt.) Ha a számláló eléri a nullát, azaz az implikáció minden premisszája ismert, akkor az implikáció konklúzióját hozzá lehet adni az agendához. Végül szükségünk van arra, hogy kövessük melyik szimbólumot dolgoztuk már fel; egy kikövetkeztetett szimbólumot nem kell hozzáadni az agendához, ha azt már korábban sikeresen feldolgoztuk. Így elkerülhető a redundáns munka, és megakadályozza a végtelen ciklusok kialakulását, amelyet olyan implikációk okozhatnak, mint a P ⇒ Q és Q ⇒ P."/></div></div></div><p>Ez az utolsó tény egy kellemes meglepetés. Azt jelenti, hogy a logikai következtetés nagyon olcsó számos, a gyakorlatban előforduló ítéletkalkulus tudásbázis esetében. </p><a id="ID_274_oldal"/><p class="Képalá">Az <code class="code">IK-EL-VONZAT? </code> (<span class="emphasis"><em>TB</em></span>,<span class="emphasis"><em> q</em></span>) előrefelé láncolási algoritmus meghatározza, hogy egy <span class="emphasis"><em>q</em></span> ítéletkalkulus szimbólum – a lekérdezés – vonzata-e egy Horn-klózokat tartalmazó tudásbázisnak. Az algoritmus a tudásbázisban található ismert tényekből (pozitív literálok) indul ki. Ha egy implikáció minden premisszája ismert, akkor a konklúzióját hozzáadjuk az ismert tények halmazához. Például, ha ismert a <span class="emphasis"><em>P</em></span><sub>1,1</sub>, és a<span class="emphasis"><em> Szellő</em></span> és a (<span class="emphasis"><em>P</em></span><sub>1,1</sub><span class="emphasis"><em> </em></span>∧ <span class="emphasis"><em>Szellő</em></span>) ⇒<span class="emphasis"><em> S</em></span><sub>1,1</sub> a tudásbázisban van, akkor <span class="emphasis"><em>S</em></span><sub>1,1</sub>-t hozzáadhatjuk ehhez. Ez a folyamat folytatódik, amíg vagy a <span class="emphasis"><em>q</em></span> lekérdezést hozzá tudjuk adni az ismert tények halmazához, vagy már nem tudunk további következtetést végezni. A részletes algoritmust a 7.14. ábra mutatja, a legfontosabb tulajdonság, amire emlékeznünk kell, hogy ez lineáris időben fut.</p><p>Az algoritmust a legjobban úgy érthetjük meg, ha megnézünk egy példát és egy hozzá tartozó ábrát. A 7.15. (a) ábra egy egyszerű Horn-klózokból álló tudásbázist mutat be, amely az <span class="emphasis"><em>A</em></span> és <span class="emphasis"><em>B</em></span> ismert tényeket tartalmazza. A 7.15. (b) ábra ugyanezt a tudásbázist egy <span class="strong"><strong>ÉS-VAGY gráf</strong></span>ként (<span class="strong"><strong>AND-OR graph</strong></span>) ábrázolja. Az ÉS-VAGY gráfokban a konjunkciókat ívekkel összefogott kapcsolatok – minden egyes kapcsolatot bizonyítani kell – jelölik, míg a diszjunkciókat ívek nélkül összefutó kapcsolatok – elég valamelyik kapcsolatot bizonyítani – jelölik. Könnyű áttekinteni, hogyan is működik az előrefelé láncolás a gráfon. Az ismert levelek (itt <span class="emphasis"><em>A</em></span> és <span class="emphasis"><em>B</em></span>) adottak, és a következtetés addig halad felfelé a gráfon, amíg lehetséges. Bárhol megjelenik egy konjunkció a folyamatban, a továbbterjesztés megáll addig, amíg az összes konjunkt ismertté nem válik, majd ezután halad tovább. Javasoljuk az olvasónak, hogy vegye át részletesen a példát. </p><div class="figure"><a id="id586698"/><p class="title"><strong>7.15. ábra - (a) Egyszerű Horn-klózokból álló tudásbázis. (b) Ugyanez a tudásbázis ÉS-VAGY gráfként.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/07-15.png" alt="(a) Egyszerű Horn-klózokból álló tudásbázis. (b) Ugyanez a tudásbázis ÉS-VAGY gráfként."/></div></div></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p class="Képalá">Könnyű belátni, hogy az előrefelé láncolás <span class="strong"><strong>helyes</strong></span>: minden következtetés valójában a Modus Ponens egy alkalmazása. Az előrefelé láncolás <span class="strong"><strong>teljes</strong></span> is: minden vonzat atomi mondatot vezet le. A legegyszerűbben úgy érthetjük meg ezt, ha a <span class="emphasis"><em>kikövetkeztetett</em></span> állapot tábla végső állapotát tekintjük (miután az algoritmus elért egy <span class="strong"><strong>fix pont</strong></span>ot (<span class="strong"><strong>fixed point</strong></span>), ahol már újabb következtetés nem lehetséges). A tábla <span class="emphasis"><em>igaz</em></span> értéket tartalmaz minden, a folyamat során kikövetkeztetett szimbólumra, és<span class="emphasis"><em> hamis</em></span> értéket a többi szimbólumra. A táblát úgy tekinthetjük, mint egy logikai modellt, ráadásul <span class="emphasis"><em>minden határozott klóz az eredeti TB-ben igaz ebben a modellben</em></span>. Ennek belátására feltételezzükaz ellenkezőjét, nevezetesen, hogy valamely <span class="emphasis"><em>a</em></span><sub>1</sub> ∧ … ∧ <span class="emphasis"><em>a<sub>k</sub></em></span> ⇒ <span class="emphasis"><em>β</em></span> klóz hamis a modellben. Ez azt jelenti, hogy <span class="emphasis"><em>a</em></span><sub>1 </sub>∧ … ∧ <span class="emphasis"><em>a<sub>k</sub></em></span>-nak igaznak, míg <span class="emphasis"><em>β</em></span>-nek hamisnak kell lennie a modellben. Ez viszont ellentmond annak a feltételezésünknek, hogy az algoritmus elérte a fix pontot! Így levonhatjuk azt a következtetést, hogy a kikövetkeztetett atomi mondatok halmaza a fix pontban az eredeti <span class="emphasis"><em>TB</em></span> egy modelljét definiálja. Ezenkívül, bármely <span class="emphasis"><em>q</em></span> atomi mondatnak, amely vonzata a <span class="emphasis"><em>TB</em></span>-nek, igaznak kell lennie ennek minden modelljében, így ebben az említett modellben is. Ennélfogva az algoritmusnak ki kell következtetnie minden <span class="emphasis"><em>q</em></span> vonzat mondatot.</p></div><p>Az előrefelé láncolás egy példája az általános <span class="strong"><strong>adatvezérelt</strong></span>nek (<span class="strong"><strong>data-driven</strong></span>) nevezett következtetési elvnek, amely olyan következtetéseket jelent, ahol a figyelem fókusza kezdetben az ismert adatokon van. Ez a megközelítés alkalmazható az ágenseknél a bejövő érzetekből történő következtetések levezetésére, gyakran anélkül is, hogy valamilyen kérdés lebegne a szemünk előtt. Például a wumpus ágens <code class="code">KIJELENT</code>-heti az érzeteit a tudásbázisnak, felhasználva egy inkrementális előrefelé következtető algoritmust, amelyben új tényeket lehet felvenni egy előjegyzési listára, hogy további következtetés inicializálódjon. A mindennapi életben, jelentős számban fordul elő adatvezérelt következtetés, amikor új információk érkeznek. Például ha bent vagyok a szobában és hallom, hogy elkezd esni, akkor felmerülhet bennem, hogy a tervezett kirándulás elmarad. Ugyanakkor az valószínűleg nem fog megfordulni a fejemben, hogy a szomszéd kertjében a legnagyobb rózsa tizenhetedik szirma nedves lesz. Az emberek óvatos kontroll alatt tartják az előrefelé láncolást, nehogy elárasszák őket az irreleváns következmények.</p><p>A visszafelé láncolás algoritmus, ahogy azt a neve is sugallja, visszafelé működik a lekérdezésből indulva. Ha a <span class="emphasis"><em>q</em></span> lekérdezésről tudjuk, hogy igaz, akkor nem szükséges további munka. Egyébként az algoritmus megtalál minden olyan implikációt a tudásbázisban, amelynek a következménye <span class="emphasis"><em>q</em></span>. Ha valamelyik ilyen implikációnak az összes premisszáját be lehet bizonyítani (visszafelé láncolással), akkor <span class="emphasis"><em>q</em></span> igaz. Amikor a 7.15. ábrán a <span class="emphasis"><em>Q</em></span> lekérdezésre alkalmazzuk a módszert, akkor ez az ábrán követve vissza, lefelé működik, addig, amíg el nem éri az ismert tények halmazát, ami a bizonyítás alapja. A részletes algoritmust meghagyjuk feladatnak, és mint az előrefelé láncolásnál, egy hatékony implementáció itt is lineáris időben működik. </p><p>A visszafelé láncolás a <span class="strong"><strong>célorientált következtetés</strong></span> (<span class="strong"><strong>goal-oriented reasoning</strong></span>) egy formája. Hasznos-e megválaszolni olyan kérdéseket, mint hogy „Mit tegyek most?”, vagy hogy „Hol vannak a kulcsaim?”. Gyakran a visszafelé láncolás költsége <span class="emphasis"><em>sokkal kisebb,</em></span> mint a tudásbázis méretétől lineárisan függő költség, mert a folyamat csak releváns tényeket érint. Általánosságban, egy ágensnek meg kell osztania a munkát az előrefelé és hátrafelé láncolás között, korlátozva az előrefelé következtetés alkalmazását azokra a tényekre, amelyek valószínűleg relevánsak azon lekérdezésekhez, amelyeket az ágens visszafelé láncolással fog megoldani. </p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id583439" href="#id583439" class="para">69</a>] </sup> A <span class="strong"><strong>nemmonoton logiká</strong></span>k (<span class="strong"><strong>nonmonotonic logic</strong></span>s), amelyek megszegik a monotonitás tulajdonságot, az emberi érvelésnek azt a szokványos tulajdonságát jelenítik meg, amikor valaki meggondolja magát. Ezeket a 10.7. alfejezetben tárgyaljuk.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id583860" href="#id583860" class="para">70</a>] </sup> Ha a klózt literálok halmazának tekintjük, akkor ezt a korlátozást automatikusan figyelembe vettük. A halmaz jelölést alkalmazva a klózokra a rezolúciós szabály sokkal tisztább lesz egy újabb jelölés bevezetésének árán.</p></div></div></div></body></html>
