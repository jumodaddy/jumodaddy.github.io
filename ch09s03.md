<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Előrefelé láncolás"><div class="titlepage"><div><div><h1 class="title"><a id="id607726"/>Előrefelé láncolás</h1></div></div></div><p>Az ítéletlogikai határozott klózokra már megadtunk egy előrefelé láncolási algoritmust a 7.5. alfejezetben. A gondolat egyszerű: kezdjük a tudásbázisban szereplő atomi mondatokkal, és alkalmazzuk a Modus Ponenst előrefelé haladva, új atomi mondatokat hozzáadva, egészen addig, amíg további következtetések már nem végezhetők. Most megmutatjuk, hogyan alkalmazzuk az algoritmust az elsőrendű határozott klózokra, és hogyan valósíthatjuk ezt meg hatékonyan. A határozott klózok, mint például a  <span class="emphasis"><em>Helyzet</em></span> ⇒ <span class="emphasis"><em>Válasz </em></span>különösen hasznosak az olyan rendszerek számára, amelyek újonnan érkezett információk alapján végeznek következtetéseket válaszként. Számos rendszert tervezhetünk ilyen módon, és ezekben az esetekben az előrefelé láncolással történő következtetés sokkal hatékonyabb lehet, mint a rezolúciós tételbizonyítás. Ebből az következik, hogy gyakran érdemes megpróbálni olyan tudásbázist építeni, amely csak határozott klózokat használ, és így elkerülhetjük a rezolúcióval járó nehézségeket.</p><div class="section" title="Elsőrendű határozott klózok"><div class="titlepage"><div><div><h2 class="title"><a id="id607739"/>Elsőrendű határozott klózok</h2></div></div></div><p>Az elsőrendű határozott klózok nagyon emlékeztetnek az ítéletlogikai határozott klózokra (<a class="xref" href="ch07s04.md#ID_272_oldal">„A rezolúció teljessége”</a>részben). Az ilyen klózok olyan literálok diszjunkciói, amelyek közül <span class="emphasis"><em>pontosan egy diszjunkt pozitív. </em></span>Egy határozott klóz vagy egy atomi mondat, vagy egy implikáció, amelynek a feltétel része pozitív literálok konjunkciója, és amelynek következménye egyetlen pozitív literál. A következő mondatok elsőrendű határozott klózok:</p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Mohó</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>)</code></p><p><code class="code"><em><span class="remark">Mohó</span></em>(<em><span class="remark">y</span></em>)</code></p><p>Eltérően az ítéletlogikai literáloktól, az elsőrendű literálok tartalmazhatnak változókat, amely esetben a változókat univerzális kvantorral ellátottnak tételezzük fel. (A határozott klózok írásánál általában elhagyjuk az univerzális kvantorokat.) A határozott klóz egy megfelelő normál forma, hogy az általánosított Modus Ponensszel alkalmazhassuk. Nem minden tudásbázist lehet átalakítani határozott klózok halmazává, az egyetlen pozitív literális korlátja miatt, de sokat igen. Gondoljuk át a következő problémát:</p><p><span class="strong"><strong>A törvény kimondja, hogy bűntény az, ha egy amerikai polgár fegyvert ad el egy Amerikával ellenséges nemzetnek. A Nono ország, amely ellensége Amerikának, fel van szerelve rakétákkal, és ezeket a rakétákat mind West ezredes adta el, aki amerikai.</strong></span></p><p>Be fogjuk bizonyítani, hogy West bűnöző. Először leírjuk a tényeinket elsőrendű határozott klózokként. A következő alfejezet fogja bemutatni, hogy az előrefelé láncolás algoritmus hogyan oldja meg a problémát.</p><p> „…bűntény az, ha egy amerikai polgár fegyvert ad el egy Amerikával ellenséges nemzetnek”:</p><p><code class="code"><em><span class="remark">Amerikai</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">y</span></em>) ∧ <em><span class="remark">Ellenséges</span></em>(<em><span class="remark">z</span></em>) ∧ <em><span class="remark">Elad</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>) ⇒ <em><span class="remark">Bűnöző</span></em>(<em><span class="remark">x</span></em>)	(9.3)</code></p><p>„Nono… fel van szerelve rakétákkal.” Azt a mondatot, hogy ∃<span class="emphasis"><em>x Birtokol</em></span>(<span class="emphasis"><em>Nono</em></span>,<span class="emphasis"><em> x</em></span>)<span class="emphasis"><em> </em></span>∧<span class="emphasis"><em> Rakéta</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>átalakítjuk két határozott klózzá Egzisztenciális Eliminációval, egy új konstans, az <span class="emphasis"><em>M</em></span><sub>1</sub><span class="emphasis"><em> </em></span>bevezetésével:</p><p><code class="code"><em><span class="remark">Birtokol</span></em>(<em><span class="remark">Nono</span></em>, <em><span class="remark">M</span></em><sub>1</sub>)						(9.4)</code></p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">M</span></em><sub>1</sub>)<em><span class="remark">							</span></em>(9.5)</code></p><p>„És ezeket a rakétákat mind West ezredes adta el”:</p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Birtokol</span></em>(<em><span class="remark">Nono</span></em>, <em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Elad</span></em>(<em><span class="remark">West</span></em>, <em><span class="remark">x</span></em>,<em><span class="remark"> Nono</span></em>)			(9.6)</code></p><p>Tudnunk kell még, hogy a rakéták fegyverek:</p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">x</span></em>)						(9.7)</code></p><p>és hogy Amerika ellensége „ellenségesnek” számít:</p><p><code class="code"><em><span class="remark">Ellensége</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Amerika</span></em>) ⇒ <em><span class="remark">Ellenséges</span></em>(<em><span class="remark">x</span></em>)					(9.8)</code></p><p>„West ezredes…, aki amerikai”:</p><p><code class="code"><em><span class="remark">Amerikai</span></em>(<em><span class="remark">West</span></em>)							(9.9)</code></p><p>„Nono ország, amely ellensége Amerikának…”</p><p><code class="code"><em><span class="remark">Ellensége</span></em>(<em><span class="remark">Nono</span></em>, <em><span class="remark">Amerika</span></em>)						(9.10)</code></p><p>A tudásbázis nem tartalmaz függvényszimbólumokat, és így egy példája a <span class="strong"><strong>Datalog</strong></span> (<span class="strong"><strong>Datalog</strong></span>) tudásbázisok osztályának – ami függvényszimbólumok nélküli elsőrendű határozott klózok halmaza. Látni fogjuk, hogy a függvényszimbólumok hiánya sokkal könnyebbé teszi a következtetést.</p></div><div class="section" title="Egy egyszerű előrefelé láncolási algoritmus"><div class="titlepage"><div><div><h2 class="title"><a id="id608046"/>Egy egyszerű előrefelé láncolási algoritmus</h2></div></div></div><p>Az első előrefelé láncolási algoritmus, amit megvizsgálunk, nagyon egyszerű lesz, amint azt láthatjuk a 9.3. ábrán. Az algoritmus az ismert tényekből kiindulva végrehajtja az összes olyan szabályt, amelynek premisszái ki vannak elégítve, és ezek következményeit hozzáadja az ismert tényekhez. Ez az eljárás addig ismétlődik, amíg a kérdést meg nem válaszoltuk (feltételezve, hogy csak egy válaszra van szükségünk), vagy amikor már nem tudunk új tényeket a tudásbázishoz hozzáadni. Vegyük észre, hogy egy tény nem számít „újnak”, ha csak <span class="strong"><strong>átnevezés</strong></span>e (<span class="strong"><strong>rename</strong></span>) egy már ismert ténynek. Egy mondat átnevezése egy másiknak, ha az alkalmazott változók neveitől eltekintve megegyeznek. Például a <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> Fagylalt</em></span>)<span class="emphasis"><em> </em></span>és a <span class="emphasis"><em>Szereti</em></span>(<span class="emphasis"><em>y</em></span>,<span class="emphasis"><em> Fagylalt</em></span>) mondatok egymás átnevezésének számítanak, mert csak az <span class="emphasis"><em>x </em></span>és az <span class="emphasis"><em>y </em></span>választásában különböznek. A két mondat jelentése megegyezik: mindenki szereti a fagylaltot.</p><p>Az előző bűntényproblémánkat fogjuk felhasználni az ERL-EL-<code class="code">KÉRDEZ</code> algoritmus bemutatásához. Az implikációs mondatok a (9.3), (9.6), (9.7) és a (9.8). Két iterációs lépés szükséges:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Az első iterációban a (9.3) szabály nem elégítette ki a premisszákat.</p></li></ul></div><p>	A (9.6) szabályt kielégíti az {x/<span class="emphasis"><em>M</em></span><sub>1</sub>} és az <span class="emphasis"><em>Elad</em></span>(<span class="emphasis"><em>West</em></span>,<span class="emphasis"><em> M</em></span><sub>1</sub>, <span class="emphasis"><em>Nono</em></span>) hozzáadása.</p><p>	A (9.7) szabályt kielégíti az {<span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>M</em></span><sub>1</sub>} és a <span class="emphasis"><em>Fegyver</em></span>(<span class="emphasis"><em>M</em></span><sub>1</sub>) hozzáadása.</p><p>	A (9.8) szabályt kielégíti az {<span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>Nono</em></span>} és az <span class="emphasis"><em>Ellenséges</em></span>(<span class="emphasis"><em>Nono</em></span>)<span class="emphasis"><em> </em></span>hozzáadása.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">A második iterációban a (9.3) szabályt kielégíti az {<span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>West</em></span>,<span class="emphasis"><em> y</em></span>/<span class="emphasis"><em>M</em></span><sub>1</sub>,<span class="emphasis"><em> z</em></span>/<span class="emphasis"><em>Nono</em></span>),<span class="emphasis"><em> </em></span>és hozzáadjuk azt, hogy: <span class="emphasis"><em>Bűnöző</em></span>(<span class="emphasis"><em>West</em></span>)<span class="emphasis"><em>.</em></span></p></li></ul></div><div class="figure"><a id="id608222"/><p class="title"><strong>9.3. ábra - Egy koncepcionálisan egyszerű, de kevéssé hatékony előrefelé láncolási algoritmus. Minden egyes iterációban hozzáadja a <span class="emphasis"><em>TB</em></span>-hez az összes atomi mondatot, amelyet egy lépésben az implikációs mondatokból és a <span class="emphasis"><em>TB</em></span>-ben már meglévő atomi mondatokból kikövetkeztethetünk.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-03.png" alt="Egy koncepcionálisan egyszerű, de kevéssé hatékony előrefelé láncolási algoritmus. Minden egyes iterációban hozzáadja a TB-hez az összes atomi mondatot, amelyet egy lépésben az implikációs mondatokból és a TB-ben már meglévő atomi mondatokból kikövetkeztethetünk."/></div></div></div><div class="figure"><a id="id608238"/><p class="title"><strong>9.4. ábra - Az előrefelé láncolás algoritmus által generált bizonyítási fa a bűntény példára. A kiinduló tények az alsó sorban jelennek meg, az első iterációban kikövetkeztetett tények a középső sorban, míg a második iterációban kikövetkeztetett tények a legfelső sorban.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-04.png" alt="Az előrefelé láncolás algoritmus által generált bizonyítási fa a bűntény példára. A kiinduló tények az alsó sorban jelennek meg, az első iterációban kikövetkeztetett tények a középső sorban, míg a második iterációban kikövetkeztetett tények a legfelső sorban."/></div></div></div><p>A 9.4. ábra bemutatja a generált bizonyítási fát. Vegyük észre, hogy új következtetések már nem lehetségesek ezen a ponton, mivel minden mondatot, amelyet kikövetkeztethetnénk az előrefelé láncolással, már explicit módon tartalmaz a <span class="emphasis"><em>TB. </em></span>Egy ilyen tudásbázist a következtetési folyamat <span class="strong"><strong>fix pont</strong></span>jának (<span class="strong"><strong>fixed point</strong></span>) nevezzük. Az elsőrendű határozott klózok előrefelé láncolásával létrehozott fix pontok hasonlítanak az ítéletlogikai előrefelé láncolással (<a class="xref" href="ch07s04.md#ID_273_oldal">„Előre- és hátrafelé láncolás”</a>részben) generáltakhoz. A leglényegesebb különbség az, hogy egy elsőrendű fix pont tartalmazhat univerzális kvantorral ellátott atomi mondatokat.</p><p>A ERL-EL-<code class="code">KÉRDEZ</code>-t könnyű kielemezni. Először is megállapítható, hogy az eljárás <span class="strong"><strong>helyes</strong></span> (<span class="strong"><strong>sound</strong></span>), mivel minden következtetés csak az általánosított Modus Ponens alkalmazása, amelyről már igazoltuk, hogy helyes. Másodszor, <span class="strong"><strong>teljes</strong></span> (<span class="strong"><strong>complete</strong></span>) a határozott klózokat tartalmazó tudásbázisokra, ami azt jelenti, hogy képes minden olyan lekérdezést megválaszolni, amely következik bármely határozott kózokból álló tudásbázisból. A Datalog tudásbázisok esetére, amelyek nem tartalmaznak függvényszimbólumokat, a teljesség bizonyítása meglehetősen egyszerű. Először megszámoljuk a <span class="emphasis"><em>TB</em></span>-hez hozzáadható tényeket, amely szám meghatározza az iterációk maximális számát. Legyen a <span class="emphasis"><em>k </em></span>ez a maximális érték (argumentumok száma) az adott predikátumokra, <span class="emphasis"><em>p </em></span>a predikátumok száma és <span class="emphasis"><em>n</em></span> a konstansszimbólumok száma. Egyértelmű, hogy nem lehet <span class="emphasis"><em>pn<sup>k</sup></em></span> különböző alapténynél több, tehát ennyi iteráció után az algoritmus el fog érni egy fix pontot. Ezután már az ítéletlogikai előrefelé láncolás bizonyításánál leírtakhoz nagyon hasonlóan érvelhetünk (<a class="xref" href="ch07s04.md#ID_273_oldal">„Előre- és hátrafelé láncolás”</a>részben.) Az ítéletlogikai teljes eljárás átalakítását egy elsőrendű teljes eljárássá a 9.5. alfejezetben mutatjuk majd meg.</p><p>Függvényszimbólumokat is tartalmazó általános határozott klózok esetében az ERL-EL-<code class="code">KÉRDEZ</code> végtelen számú új tényt generálhat, így ilyenkor óvatosabbnak kell lennünk. Ha egy lekérdezésre adható válaszmondat levezethető a <span class="emphasis"><em>TB</em></span>-ből, akkor Herbrand tételét kell alkalmaznunk, hogy biztosítsuk, hogy az algoritmus megtalál egy bizonyítást (lásd a 9.5. alfejezetet a rezolúciós esetre). Ha a lekérdezésre nincs válasz, akkor az algoritmus néhány esetben nem tud leállni. Például ha a tudásbázis a Peano-axiómákat tartalmazza, </p><p><code class="code"><em><span class="remark">TermSzám</span></em>(0)</code></p><p><code class="code">∀<em><span class="remark">n TermSzám</span></em>(<em><span class="remark">n</span></em>)<em><span class="remark"> </span></em>⇒ <em><span class="remark">TermSzám</span></em>(<em><span class="remark">S</span></em>(<em><span class="remark">n</span></em>))</code></p><p>akkor az előrefelé láncolás hozzáadja a <span class="emphasis"><em>TermSzám</em></span>(<span class="emphasis"><em>S</em></span>(0)), <span class="emphasis"><em>TermSzám</em></span>(<span class="emphasis"><em>S</em></span>(<span class="emphasis"><em>S</em></span>(0))), <span class="emphasis"><em>TermSzám</em></span>(<span class="emphasis"><em>S</em></span>(<span class="emphasis"><em>S</em></span>(<span class="emphasis"><em>S</em></span>(0)))) mondatokat és így tovább. Általánosságban ezt a problémát nem lehet kikerülni. Hasonlóan, mint az általános elsőrendű logikában, a határozott klózokkal való következtetés félig eldönthető.</p></div><div class="section" title="Hatékony előrefelé láncolás"><div class="titlepage"><div><div><h2 class="title"><a id="id608392"/>Hatékony előrefelé láncolás</h2></div></div></div><p>A 9.3. ábrán látható előrefelé láncolási algoritmust inkább a megértés megkönnyítése céljából mutattuk be, és nem mint egy hatékonyan végrehajtható algoritmust. A komplexitásnak  három lehetséges forrása van. Először is, az algoritmus „belső hurka” elvégzi az összes lehetséges egyesítés megtalálását, ahol egy szabály premisszája egyesíthető a <span class="emphasis"><em>TB</em></span> egy alkalmas tényhalmazával. Ezt gyakran <span class="strong"><strong>mintaillesztés</strong></span>nek (<span class="strong"><strong>pattern matc</strong></span><span class="strong"><strong>hing</strong></span>) nevezzük, és igen költséges lépés. Másodszor, az algoritmus újra ellenőriz minden szabályt minden iterációban, hogy megvizsgálja, hogy a premisszák ki vannak-e elégítve, még olyankor is, amikor nagyon kevés változtatást végzünk a tudásbázisban az egyes ciklusokban. Végül, az algoritmus számos olyan tényt is generálhat, melyek irrelevánsak a cél szempontjából. Mindhárom problémaforrást meg fogjuk vizsgálni.</p><div class="section" title="Szabályok illesztése az ismert tényekhez"><div class="titlepage"><div><div><h3 class="title"><a id="id608415"/>Szabályok illesztése az ismert tényekhez</h3></div></div></div><p>A szabályok premisszáinak a <span class="emphasis"><em>TB</em></span> tényeihez történő illesztése egyszerű problémának tűnhet. Például tételezzük fel, hogy a következő szabályt akarjuk alkalmazni:</p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">x</span></em>)</code></p><p>Ezután meg kell találnunk az összes tényt, amely egyesíthető a <span class="emphasis"><em>Rakéta</em></span>(<span class="emphasis"><em>x</em></span>)-szel. Egy megfelelően indexelt tudásbázisban ez elvégezhető a tények számával lineáris időben. Vizsgáljunk meg egy szabályt, mint amilyen például a:</p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Birtokol</span></em>(<em><span class="remark">Nono</span></em>, <em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Elad</span></em>(<em><span class="remark">West</span></em>,<em><span class="remark"> x</span></em>,<em><span class="remark"> Nono</span></em>)</code></p><p>Itt is megkereshetjük a Nono által birtokolt összes objektumot objektumonként konstans idő alatt. Ezután minden egyes objektumra meg tudjuk vizsgálni, hogy az rakéta-e.</p><p>Amennyiben a tudásbázis sok Nono által birtokolt objektumot tartalmaz és nagyon kevés rakétát, akkor azonban célszerűbb lenne először az összes rakétát megkeresni, és aztán ellenőrizni, hogy azokat Nono birtokolja-e. Ez a <span class="strong"><strong>konjunkt sorrendezés</strong></span> (<span class="strong"><strong>conjunct ordering</strong></span>) probléma: találjunk egy olyan sorrendet, amely a szabály premissza részének konjunktjait megoldja úgy, hogy ezzel a teljes költséget minimalizáljuk. Megmutatható, hogy az optimális sorrend megtalálása önmagában is NP-nehéz, de egy jó heurisztika elérhető. Például ilyen a <span class="strong"><strong>legkorlátozottabb változó</strong></span> (<span class="strong"><strong>most constrained variable</strong></span>) heurisztikája, amelyet az 5. fejezetben a kényszerkielégítési problémákra használtunk. Ez azt a logikát követi, hogy rendezzük sorba a konjunktokat úgy, hogy először a rakétákat keressük, ha kevesebb rakéta van, mint Nono által birtokolt objektum.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A kapcsolat a mintaillesztés és a kényszer kielégítése között valójában nagyon szoros. Bármelyik konjunktot úgy tekinthetünk, mint az általa tartalmazott változók korlátozását – például, a <span class="emphasis"><em>Rakéta</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>egy unáris korlátozás az <span class="emphasis"><em>x</em></span>-en. Ezt a gondolatot kiterjesztve, <span class="emphasis"><em>minden véges tárgyterületű kényszerkielégítési problémát kifejezhetünk egyszeri határozott klózként, néhány társított alapténnyel kiegészítve. </em></span>Vizsgáljuk meg az 5.1. ábrán látható térképszínezési problémát, amelyet a 9.5. (a) ábrán újra bemutatunk. Egy ezzel megegyező formulát adtunk meg egy határozott klóz formájában a 9.5. (b) ábrán. Világos, hogy a <span class="emphasis"><em>Színezhető</em></span>()<span class="emphasis"><em> </em></span>konklúzió csak akkor kikövetkeztethető, ha a kényszerkielégítési problémának van egy megoldása. Mivel a kényszerkielégítési problémák általában magukba foglalják a 3SAT problémákat különleges esetekként, levonhatjuk azt a következtetést, hogy <span class="emphasis"><em>egy határozott klóz illesztése egy tényhalmazhoz NP-nehéz.</em></span></p></div><div class="figure"><a id="id608544"/><p class="title"><strong>9.5. ábra - (a) Ausztrália térképének kiszínezését bemutató kényszergráf (5.1. ábra). (b) A térképszínező kényszerkielégítési probléma egy határozott klózzal reprezentálva. Vegyük észre, hogy a változók tárgyterülete a <code class="code">KÜL</code>-re megadott alaptények konstansai által implicit módon definiáltak.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-05.png" alt="(a) Ausztrália térképének kiszínezését bemutató kényszergráf (5.1. ábra). (b) A térképszínező kényszerkielégítési probléma egy határozott klózzal reprezentálva. Vegyük észre, hogy a változók tárgyterülete a KÜL-re megadott alaptények konstansai által implicit módon definiáltak."/></div></div></div><p>Elég elkeserítőnek tűnhet, hogy az előrefelé láncolás tartalmaz egy NP-nehéz illesztési problémát a belső hurokban. Három módja van annak, hogy felvidítsuk magunkat:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Emlékezhetünk arra, hogy a legtöbb szabály a valódi tudásbázisokban kisméretű és egyszerű (mint a bűntény példa szabályai), és nem nagy és komplex (mint a 9.5. ábrán látható kényszerproblémánál). Az adatbázisok területén fel szokták tételezni, hogy mind a szabályok mérete, mind a predikátumok argumantumszáma egy konstanssal megadható korlát alatt marad, és így csak az <span class="strong"><strong>adatkomplexitás</strong></span> (<span class="strong"><strong>data complexity</strong></span>) miatt kell aggódni – vagyis a következtetés komplexitása miatt, ami az adatbázisban lévő alaptények számának függvénye. Könnyű megmutatni, hogy az előrefelé láncolás adatkomplexitása polinomiális.</p></li><li class="listitem"><p class="List Paragraph">Tekinthetjük a szabályok azon csoportját, amelyekre az illesztés hatékony tud lenni. Alapjában véve minden Datalog klózt tekinthetünk úgy, mint ami egy kényszerkielégítési problémát határoz meg, így az illesztés kivitelezhető akkor, ha a megfelelő kényszerkielégítési probléma is nyomon követhető. Az 5. fejezet leírja a kényszerkielégítési problémák néhány praktikusan megoldható családját. Például ha a kényszergráf (egy olyan gráf, amelynek a csomópontjai változók és az élei kényszerek) fát formáz, akkor a kényszerkielégítési probléma lineáris időben megoldható. Pontosan ugyanez a szabály áll fenn a szabályillesztésre. Például ha eltávolítjuk Dél-Ausztráliát a 9.5. ábráról, akkor az új klóz a következő lesz:</p></li></ul></div><p><code class="code"><em><span class="remark">	Kül</span></em>(<em><span class="remark">nya</span></em>,<em><span class="remark"> ét</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Kül</span></em>(<em><span class="remark">ét</span></em>,<em><span class="remark"> q</span></em>) ∧ <em><span class="remark">Kül</span></em>(<em><span class="remark">q</span></em>,<em><span class="remark"> údw</span></em>) ∧ <em><span class="remark">Kül</span></em>(<em><span class="remark">údw</span></em>,<em><span class="remark"> v</span></em>) ⇒ <em><span class="remark">Színezhető</span></em>()</code></p><p>	Ez megfelel az 5.11. ábrán bemutatott redukált kényszerkielégítési problémának. A faszerkezetű kényszerkielégítési problémák megoldására használt algoritmusokat közvetlenül alkalmazhatjuk a szabályillesztés problémájára.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">És végül dolgozhatunk azon, hogy megszüntessük a felesleges szabályillesztési kísérleteket az előrefelé láncolási algoritmusban, amely a következő alfejezet témája lesz.</p></li></ul></div></div><div class="section" title="Inkrementális előrefelé láncolás"><div class="titlepage"><div><div><h3 class="title"><a id="id608646"/>Inkrementális előrefelé láncolás</h3></div></div></div><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Amikor a bűntény példán bemutattuk az előrefelé láncolás működését, akkor csaltunk, nevezetesen abban, hogy kihagytunk néhány szabályillesztést, amelyet a 9.3. ábrán bemutatott algoritmus elvégzett. Például a második iterációban a:</p><p><code class="code"><em><span class="remark">Rakéta</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">x</span></em>)</code></p><p>szabály (ismét) illeszthető a <span class="emphasis"><em>Rakéta</em></span>(<span class="emphasis"><em>M</em></span><sub>1</sub>)<span class="emphasis"><em>-</em></span>hez, és természetesen a <span class="emphasis"><em>Fegyver</em></span>(<span class="emphasis"><em>M</em></span><sub>1</sub>) konklúziót már ismerjük, így semmi sem történik. Az ilyen felesleges szabályillesztést elkerülhetjük, ha figyelembe vesszük a következő megfigyelést: <span class="emphasis"><em>Minden, α t-edik iterációban kikövetkeztethető új tény levezetéséhez szükséges legalább egy, α t</em></span> – 1<span class="emphasis"><em> ciklusban kikövetkeztetett új tény felhasználása. </em></span>Ez azért igaz, mert bármely olyan következtetés, amely nem igényel egy új tényt a <span class="emphasis"><em> t</em></span> – 1<span class="emphasis"><em> </em></span>ciklusból, már elvégezhető lett volna a <span class="emphasis"><em>t</em></span> – 1<span class="emphasis"><em> </em></span>ciklusban.</p></div><p>Ez a megfigyelés természetes módon elvezet minket egy inkrementális előrefelé láncolási algoritmushoz, ahol a <span class="emphasis"><em>t </em></span>ciklusban csak akkor ellenőrzünk egy szabályt, ha annak premisszája tartalmaz egy <span class="emphasis"><em>p<sub>i</sub> </em></span>konjunktot, amely egyesíthető egy <span class="emphasis"><em>p′<sub>i</sub> </em></span>ténnyel, és amelyre újonnan következtettünk a <span class="emphasis"><em>t</em></span> – 1<span class="emphasis"><em> </em></span>ciklusban. A szabályillesztő lépés aztán rögzíti a <span class="emphasis"><em>p<sub>i</sub></em></span>-t, hogy illeszkedjen a <span class="emphasis"><em>p</em></span>′<sub>i</sub>-hez, de lehetővé teszi, hogy a szabály többi konjunktja illeszkedjen bármely megelőző ciklus tényeihez. Ez az algoritmus pontosan ugyanazokat a tényeket generálja minden egyes ciklusban, mint amelyeket a 9.3. ábrán látható algoritmus, de annál sokkal hatékonyabb.</p><p>Megfelelő indexeléssel könnyű megtalálni azokat a szabályokat, amelyeket egy adott tény kielégíthetővé tehet. Valójában számos rendszer egy ilyen frissítési módban működik, ahol az előrefelé láncolás minden egyes olyan tényre aktualizálódik, amelyet <code class="code">KIJELENT</code>-ettünk a rendszernek. A következtetések sorban végigveszik a szabályok halmazát, amíg el nem érik a fix pontot, és ez a folyamat a következő új ténynél újra kezdődik.</p><p>A tudásbázisban lévő szabályoknak tipikusan csak egy kis töredékét eredményezi egy adott tény hozzáadása. Ez azt jelenti, hogy jelentős mennyiségű felesleges munkát végzünk néhány ki nem elégített premisszát is tartalmazó részleges illesztések ismételt létrehozásával. A bűntény példánk túl kicsi ahhoz, hogy ezt megfelelően bemutassuk, de vegyük észre, hogy egy részleges illesztést az első ciklusban már létrehoztunk az:</p><p><code class="code"><em><span class="remark">Amerikai</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Fegyver</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Elad</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>,<em><span class="remark"> z</span></em>) ∧ <em><span class="remark">Ellenséges</span></em>(<em><span class="remark">z</span></em>)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Bűnöző</span></em>(<em><span class="remark">x</span></em>)</code></p><p>szabály és az <span class="emphasis"><em>Amerikai</em></span>(<span class="emphasis"><em>West</em></span>) tény között<span class="emphasis"><em>. </em></span>Ezt a részleges illesztést aztán kiselejtezzük, de újraépítjük a második ciklusban is (amikor a szabály sikeres). Hatékonyabb lenne megőrizni, és fokozatosan kiegészíteni újabb részleges illesztésekkel, amikor az új tények beérkeznek, ahelyett hogy kiselejteznénk őket.</p><p>A <span class="strong"><strong>rete</strong></span> algoritmus<sup>[<a id="id609557" href="#ftn.id609557" class="footnote">89</a>]</sup> volt az első, amely alaposan foglalkozott ezzel a problémával. Az algoritmus feldolgozza a tudásbázis szabályait, hogy létrehozzon egy adatfolyam-hálózatot, amelyben minden csomópont egy literál egy szabály premissza részéből. Változó lekötések áramlanak a hálózaton, megszűrve azokat, amelyek nem illeszkednek egy literálhoz. Ha egy szabályban két literálnak ugyanaz a változója – például <span class="emphasis"><em>Elad</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> y</em></span>,<span class="emphasis"><em> z</em></span>) ∧<span class="emphasis"><em> Ellenséges</em></span>(<span class="emphasis"><em>z</em></span>)<span class="emphasis"><em> </em></span>a bűnöző példában –, akkor a literálokhoz tartozó lekötések egy egyenlőségi csomóponton mennek keresztül. Egy változó lekötésnek, amely elér egy csomópontot egy<span class="emphasis"><em> n</em></span> argumentumú literálnál úgy, mint az <span class="emphasis"><em>Elad</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> y</em></span>,<span class="emphasis"><em> z</em></span>),<span class="emphasis"><em> </em></span>várakoznia kell, mielőtt a folyamat újra kezdődne, amíg a többi változóhoz tartozó lekötéseket is létrehozzuk. Egy adott pontban a rete háló állapota megadja a szabályok összes, addig elvégzett részleges illesztéseit, és így elkerülhető a jelentős újraszámolás.</p><p>A rete hálók, és más, hatékonyságot növelő fejlesztések mindig is jelentős szerepet játszottak az úgynevezett <span class="strong"><strong>produkciós rendszer</strong></span>ekben (<span class="strong"><strong>production system</strong></span>s), amelyek az első széles körben használt előrefelé láncolási rendszerek voltak.<sup>[<a id="id609622" href="#ftn.id609622" class="footnote">90</a>]</sup> Az <code class="code">XCON</code> szakértői rendszer (eredetileg R1-nek hívták, McDermott, 1982) egy produkciós rendszer felépítését felhasználva készült. Az <code class="code">XCON</code> néhány ezer szabályt tartalmazott számítógép-tartozékok konfigurációinak megtervezésére a DEC cég vásárlóinak számára. Ez volt az egyik első igazi kereskedelmi siker a szakértő rendszerek feltörekvő piacán. Sok más hasonló rendszer épült ugyanezt a technológiát felhasználva, amelyet be is építettek egy általános célú programozási nyelvbe, az <code class="code">OPS</code>-5-be. </p><p>A produkciós rendszerek a <span class="strong"><strong>kognitív architektúrá</strong></span>kban (<span class="strong"><strong>cognitive architecture</strong></span>s), mint például az ACT (Anderson, 1983) vagy a <code class="code">SOAR</code> (Laird és társai, 1987), is népszerűek. A kognitív architektúrák az emberi gondolkodás modelljei. Az ilyen rendszerekben a rendszer „munkamemóriája” az ember rövid távú memóriáját modellezi, és a produkált következmények a hosszú távú memória részei. A működés minden egyes ciklusában a produkciókat a tények munkamemóriájához illesztik. Egy olyan következmény, amelynek feltételeit kielégítik, hozzátehet és kitörölhet tényeket a működő memóriából. Az adatbázisokkal ellentétben a produkciós rendszerekben gyakran sok szabály és viszonylag kevés tény van. Megfelelően optimalizált illesztési technológiával néhány modern rendszer képes valós időben működni több mint egymillió szabállyal is.</p></div><div class="section" title="Irreleváns tények"><div class="titlepage"><div><div><h3 class="title"><a id="id609664"/>Irreleváns tények</h3></div></div></div><p>Úgy tűnik, hogy a rossz hatékonyság problémájának az utolsó forrása az előrefelé láncolásban a megközelítésből fakad, ez már az ítéletlogikai kontextusban is felmerült. (lásd 7.5. alfejezet). Az előrefelé láncolás az ismert tényeken alapuló összes lehetséges következtetést elvégzi, <span class="emphasis"><em>akkor is, ha azok irrelevánsak az elérendő célhoz. </em></span>A bűntény példánkban nem voltak olyan szabályok, amelyek irreleváns konklúziókat vontak volna maguk után, így az irányítottság hiánya nem jelentett problémát. Más esetekben (például ha több szabályunk van, amelyek leírják az amerikaiak étkezési szokásait és a rakéták árát is), a ERL-EL-<code class="code">KÉRDEZ</code> számos irreleváns konklúziót fog generálni.</p><p>Az irreleváns konklúziók elkerülésének egy lehetséges módja a hátrafelé láncolás használata, amint az a 9.4. alfejezetben látható lesz. Másik megoldás, hogy az előrefelé láncolást a kiválogatott szabályok egy részhalmazára korlátozzuk. Ezt a megközelítést az ítéletlogikai kontextusban már tárgyaltuk. Egy harmadik megközelítést használnak a deduktív adatbázisok területén, ahol az előrefelé láncolás elterjedt eszköznek számít. Az alapötlet az, hogy írjuk át a szabályhalmazt felhasználva a célállítást, hogy aztán csak releváns változó kapcsolatokat – amelyek az úgynevezett <span class="strong"><strong>mágikus halmaz</strong></span>hoz (<span class="strong"><strong>magic set</strong></span>) tartoznak – vegyük figyelembe az előrefelé következtetésben. Például ha a cél állítás a <span class="emphasis"><em>Bűnöző</em></span>(<span class="emphasis"><em>West</em></span>)<span class="emphasis"><em>, </em></span>akkor a szabályt, amely a <span class="emphasis"><em>Bűnöző</em></span>(<span class="emphasis"><em>x</em></span>)-re következtet<span class="emphasis"><em>, </em></span>át kell írni úgy, hogy tartalmazzon egy további konjunktot, amely korlátozza az <span class="emphasis"><em>x </em></span>értékét:</p><p><code class="code"><em><span class="remark">Mágikus</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Amerikai</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧ <em><span class="remark">Fegyver</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Elad</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> y</span></em>,<em><span class="remark"> z</span></em>) ∧ <em><span class="remark">Ellenséges</span></em>(<em><span class="remark">z</span></em>) ⇒<em><span class="remark"> Bűnöző</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em></code></p><p>A <span class="emphasis"><em>Mágikus</em></span>(<span class="emphasis"><em>West</em></span>)<span class="emphasis"><em> </em></span>tény is hozzáadódik a <span class="emphasis"><em>TB</em></span>-hez. Ily módon, még akkor is, ha a tudásbázis amerikaiak millióiról tartalmaz is adatokat, csak West ezredest fogjuk figyelembe venni az előrefelé láncolási folyamatban. A mágikus halmazok definiálásának és a tudásbázis átírásának teljes folyamata túl összetett ahhoz, hogy most itt részletezzük, de az alapötlet egyfajta „generikus” hátrafelé való következtetés elvégzése a célból kiindulva azért, hogy megtaláljuk, mely változókapcsolatokat kell korlátozni. A mágikus halmaz megközelítést egy hibrid algoritmusnak tekinthetjük az előrefelé következtetés és a hátrafelé haladó előfeldolgozó folyamat között.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id609557" href="#id609557" class="para">89</a>] </sup> A rete hálót jelent latinul, angol kiejtésben (riti) a „treaty”-vel rímel.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id609622" href="#id609622" class="para">90</a>] </sup> A <span class="strong"><strong>produkció</strong></span> kifejezés a <span class="strong"><strong>produkciós rendszer</strong></span>ekben egy feltétel–cselekvés szabályt jelent.</p></div></div></div></body></html>
