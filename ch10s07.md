<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Következtetés alapértelmezett információval"><div class="titlepage"><div><div><h1 class="title"><a id="id632408"/>Következtetés alapértelmezett információval</h1></div></div></div><p>Az előbbi alfejezetben láttunk egy egyszerű példát egy alapértelmezett státussal rendelkező állításra: „az embereknek két lába van”. Ezt az alapértelmezett értéket specifikusabb információval, mint például „a Kékszakállúnak egy lába van”, felülírhatjuk. Láttuk, hogy a szemantikus háló öröklődési mechanizmusa az alapértelmezett értékek felülírását egyszerű és természetes módon oldja meg. Ebben a részben az alapértelmezett értékeket mélyebben tanulmányozzuk annak érdekében, hogy az alapértelmezett értékek <span class="emphasis"><em>szemantikáját</em></span> alaposabban megértsük, és ne szorítkozzunk csupán a procedurális mechanizmus megadására.</p><a id="ID_425_oldal"/><div class="section" title="Nyitott és zárt világok"><div class="titlepage"><div><div><h2 class="title"><a id="id632420"/>Nyitott és zárt világok</h2></div></div></div><p>Tegyük fel, hogy egyetemen a számítástudományi tanszék hirdetőtábláját nézzük, és azt az üzenetet látjuk, hogy: „Az alábbi tantárgyakat fel lehet venni: SZT 101, SZT 102, SZT 106 és VIM 101.” Próbáljuk most megválaszolni, vajon hány tárgyat lehet felvenni? Ha a válasza az, hogy „négy”, ez megegyezik egy tipikus adatbázis válaszával. Ha adott egy relációs adatbázisa:</p><p><code class="code"><em><span class="remark">Tantárgy</span></em>(<em><span class="remark">SZT</span></em>, 101), <em><span class="remark">Tantárgy</span></em>(<em><span class="remark">SZT</span></em>, 102), <em><span class="remark">Tantárgy</span></em>(<em><span class="remark">SZT</span></em>, 106),</code></p><p><code class="code"><em><span class="remark">Tantárgy</span></em>(<em><span class="remark">VIM</span></em>, 101)					(10.2)</code></p><p>négy állítás megfelelőjével, a count * from Tantárgy SQL-felkérés 4-es válasszal tér vissza. Másfelől egy elsőrendű logikai rendszer válasza az lenne, hogy „egy és végtelen között valahány”, és nem „négy”. Ennek magyarázata, hogy a <span class="emphasis"><em>Tantárgy</em></span> állítás nem zárja ki, hogy más, nem említett tantárgyakat is fel lehessen venni, és azt sem, hogy az említett tantárgyak mind különbözők.</p><p>A példa mutatja, hogy az adatbázisok és az emberi kommunikáció konvenciója az elsőrendű logikától legalább két aspektusban különbözik. Először, az adatbázisok (és az emberek) feltételezik, hogy a megadott információ <span class="emphasis"><em>teljes</em></span>, vagyis hogy az igazként ki nem jelentett rögzített atomi formulákról feltételezhetjük, hogy hamisak. Ez az ún. <span class="strong"><strong>zárt világ feltételezés</strong></span> (<span class="strong"><strong>closed-world assumption</strong></span>, <span class="strong"><strong>CWA</strong></span>). Másodszor, elfogadjuk általában, hogy különböző nevek különböző objektumokat jelentenek. Ez az ún. <span class="strong"><strong>egyedi elnevezések feltételezés</strong></span> (<span class="strong"><strong>unique names assumption</strong></span>, <span class="strong"><strong>UNA</strong></span>), amit a cselekvés-nevek kontextusában először a 10.3. alfejezetben vezettünk be.</p><p>Az elsőrendű logika e konvenciókhoz nem folyamodik, így precízebbnek kell lennie. Hogy kijelentsük, <span class="emphasis"><em>csak</em></span> négy különböző tantárgyat lehet választani, azt kellene írni, hogy:</p><p><code class="code"><em><span class="remark">Tantárgy</span></em>(<em><span class="remark">d</span></em>, <em><span class="remark">n</span></em>) ⇔ [<em><span class="remark">d</span></em>, <em><span class="remark">n</span></em>] = [<em><span class="remark">SZT</span></em>, 101] ∨ [<em><span class="remark">d</span></em>, <em><span class="remark">n</span></em>] = [<em><span class="remark">SZT</span></em>, 102]</code></p><p><code class="code">∨ [<em><span class="remark">d</span></em>, <em><span class="remark">n</span></em>] = [<em><span class="remark">SZT</span></em>, 106] ∨ [<em><span class="remark">d</span></em>, <em><span class="remark">n</span></em>] = [<em><span class="remark">VIM</span></em>, 101]	(10.3) </code></p><p>A (10.3) egyenletet a (10.2) <span class="strong"><strong>lezárás</strong></span>ának<sup>[<a id="id632574" href="#ftn.id632574" class="footnote">104</a>]</sup> (<span class="strong"><strong>completion</strong></span>) nevezzük. A lezárás általában minden predikátumhoz egy definíciót, egy „akkor és csak akkor” állítást rendel hozzá. Minden definícióban mindegyik, a predikátumot a fejében tartalmazó definit klózhoz egy diszjunkció fog tartozni.<sup>[<a id="id632583" href="#ftn.id632583" class="footnote">105</a>]</sup> A lezárást általánosságban az alábbi módon szerkesztik meg:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Gyűjtsük ki az ugyanolyan (<span class="emphasis"><em>P</em></span>) predikátum névvel és (<span class="emphasis"><em>n</em></span>) aritással rendelkező klózokat.</p></li><li class="listitem"><p class="List Paragraph">Minden klózt az ún. <span class="strong"><strong>Clark Normál Formá</strong></span>ra (<span class="strong"><strong>Clark Normal Form</strong></span>) transzformáljuk: cseréljük a:</p></li></ol></div><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">t</span></em><sub>1</sub>,…, <em><span class="remark">t<sub>n</sub></span></em>) ← <em><span class="remark">Törzs</span></em>	</code></p><p>	kifejezést, ahol a <span class="emphasis"><em>t<sub>i</sub></em></span>-k termek, a:</p><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">t</span></em><sub>1</sub>,…, <em><span class="remark">t<sub>n</sub></span></em>) ← ∃<em><span class="remark">w</span></em><sub>1</sub>… <em><span class="remark">w<sub>m</sub></span></em> [<em><span class="remark">v</span></em><sub>1</sub>,…, <em><span class="remark">v<sub>n</sub></span></em>] = [<em><span class="remark">t</span></em><sub>1</sub>,…, <em><span class="remark">t<sub>n</sub></span></em>] ∧ <em><span class="remark">Törzs</span></em>	</code></p><p>	kifejezésre, ahol a <span class="emphasis"><em>v<sub>i</sub></em></span>-k az újonnan bevezetett változók és a <span class="emphasis"><em>w<sub>i</sub></em></span>-k az eredeti klóz változói. Használjuk minden klóz esetén a <span class="emphasis"><em>v<sub>i</sub></em></span> változók ugyanazon halmazát. Eredményként a:</p><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">v</span></em><sub>1</sub>,…, <em><span class="remark">v<sub>n</sub></span></em>) ← <em><span class="remark">B</span></em><sub>1	</sub></code></p><p><code class="code">	.</code></p><p><code class="code">	.</code></p><p><code class="code">	.</code></p><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">v</span></em><sub>1</sub>,…, <em><span class="remark">v<sub>n</sub></span></em>) ← <em><span class="remark">B<sub>k</sub></span></em><sub> </sub>	</code></p><p>	klózok halmazát kapjuk.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Kombináljuk ezeket össze egy nagy diszjunktív klózzá:</p></li></ol></div><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">v</span></em><sub>1</sub>,…, <em><span class="remark">v<sub>n</sub></span></em>) ← <em><span class="remark">B</span></em><sub>1</sub><em><span class="remark"> </span></em>∨… ∨ <em><span class="remark">B</span></em><sub><em><span class="remark">k</span></em> </sub></code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Zárjuk le azáltal, hogy a ←-at ekvivalenciára cseréljük:</p></li></ol></div><p><code class="code"><em><span class="remark">	P</span></em>(<em><span class="remark">v</span></em><sub>1</sub>,…, <em><span class="remark">v<sub>n</sub></span></em>) ⇔ <em><span class="remark">B</span></em><sub>1</sub><em><span class="remark"> </span></em>∨ … ∨ <em><span class="remark">B<sub>k</sub></span></em></code></p><p>A Clark-lezárás egy példáját – szabályokat és rögzített tényeket tartalmazó tudásbázis esetén – a 10.12. ábrán láthatjuk. Hogy hozzáadhassuk az egyedi elnevezések feltételezést is, egyszerűen adjuk meg az azonossági reláció Clark-lezárását, ahol csak azok az ismert tények, hogy <span class="emphasis"><em>SZT</em></span> = <span class="emphasis"><em>SZT</em></span> és 101 = 101 stb. Ennek megvalósítását gyakorlásképpen meghagyjuk az olvasónak.</p><div class="figure"><a id="id632884"/><p class="title"><strong>10.12. ábra - Horn-klózok egy halmazának Clark-lezárása. Az eredeti Horn-program (balra) négy tantárgyat említ explicit módon, és azt is állítja, hogy minden egészre a 101 és a 130 között létezik egy matematikai tárgy, meg azt is, hogy minden SZT tárgyhoz a 100-as (BSc) sorozatban létezik egy megfelelő tantárgy a 200-as (MSc) sorozatban. A Clark-lezárás (jobbra) azt mondja, hogy más tantárgy nincs is. A lezárással és az egyedi elnevezések feltételezéssel (valamint az <span class="emphasis"><em>Egész</em></span> predikátum nyilvánvaló definíciójával) együtt eljutunk a kívánt konklúzióig, miszerint pontosan 36 tantárgy van: 30 matematikai és 6 SZT tárgy.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/10-12.png" alt="Horn-klózok egy halmazának Clark-lezárása. Az eredeti Horn-program (balra) négy tantárgyat említ explicit módon, és azt is állítja, hogy minden egészre a 101 és a 130 között létezik egy matematikai tárgy, meg azt is, hogy minden SZT tárgyhoz a 100-as (BSc) sorozatban létezik egy megfelelő tantárgy a 200-as (MSc) sorozatban. A Clark-lezárás (jobbra) azt mondja, hogy más tantárgy nincs is. A lezárással és az egyedi elnevezések feltételezéssel (valamint az Egész predikátum nyilvánvaló definíciójával) együtt eljutunk a kívánt konklúzióig, miszerint pontosan 36 tantárgy van: 30 matematikai és 6 SZT tárgy."/></div></div></div><p>A zárt világ feltételezés lehetővé teszi, hogy megtaláljuk egy reláció <span class="strong"><strong>minimálmodell</strong></span>jét (<span class="strong"><strong>minimal model</strong></span>). Ez azt jelenti, hogy a <span class="emphasis"><em>Tantárgy</em></span> relációhoz a legkevesebb elemet tartalmazó modellt találhatjuk meg. A (10.2) egyenletben a <span class="emphasis"><em>Tantárgy</em></span> minimálmodellje négyelemű, kevesebb már ellentmondáshoz vezet. Horn-klóz tudásbázisok esetén mindig létezik egy <span class="emphasis"><em>egyértelmű</em></span> minimálmodell. Jegyezzük meg, hogy az egyedi elnevezések feltételezés mellett ez az azonossági relációra is vonatkozik: minden term csakis saját magával azonos. Paradox módon ez azt jelenti, hogy a minimál modellek egyben maximálisak abban az értelemben, hogy annyi objektumot tartalmaznak, amennyi csak lehetséges.</p><p>Lehetséges egy Horn-program Clark-lezárását képezni, majd a következtetések levonása végett egy tételbizonyítónak átadni. Hatékonyabb azonban általában egy olyan speciális rendeltetésű következtető gépet használni, mint amilyen a Prolog, amelynél a zárt világ és az egyedi elnevezések feltételezések a következtetési mechanizmusba be vannak építve.</p><p>Akik a zárt világ feltételezéshez folyamodnak, óvatosan kell megválasztaniuk az általuk használt következtetést. Egy népszámlálási adatbázisban például, ésszerű a zárt világ feltételezést használni, ha a következtetés a városok populációjáról történik, de nyilván helytelen konklúzió lenne elfogadni, hogy a jövőben nem születnek gyerekek, csakis annak alapján, hogy az adatbázis a jövőbeli születési bejegyzéseket nem tartalmazza. A zárt világ feltételezés az adatbázist <span class="strong"><strong>teljes</strong></span>sé (<span class="strong"><strong>complete</strong></span>) teszi abban az értelemben, hogy minden atomi lekérdezésre vagy pozitív, vagy negatív választ kapunk. Ha valamely tényállásról (mint például a jövőbeli születések) tényleg tudatlanok vagyunk, a zárt világ feltételezést használni nem szabad. Egy komplikáltabb tudásreprezentációs rendszerben a felhasználónak esetleg szabad lenne specifikálni a zárt világ feltételezés használatát leíró szabályokat.</p></div><div class="section" title="Negálás mint kudarc és stabil modell szemantika"><div class="titlepage"><div><div><h2 class="title"><a id="id632935"/>Negálás mint kudarc és stabil modell szemantika</h2></div></div></div><p>A 7. és a 9. fejezetekben láttuk, hogy Horn-klóz formájú tudásbázisnak kedvező számítástechnikai tulajdonságai vannak. Sok alkalmazásban azonban nem kényelmes azt biztosítani, hogy klózok törzseiben csak pozitív literálok legyenek. Szeretnénk például azt mondani, hogy „Kimehetsz, ha nem esik”, anélkül hogy olyan predikátumokhoz kellene folyamodni, mint a <span class="emphasis"><em>NemEsik</em></span>. Ebben a részben annak a lehetőségét kutatjuk, hogy a Horn-klózokhoz az explicit negálás egy formáját adjuk hozzá a <span class="strong"><strong>negálás mint kudarc</strong></span> (<span class="strong"><strong>negation as failure</strong></span>) ötletét felhasználva. Az ötlet az, hogy egy negatív „<span class="emphasis"><em>not P</em></span>” literált igaznak „bizonyíthatunk”, hasonlóan, mint ahogy <span class="emphasis"><em>P</em></span> bizonyítása kudarcba fulladhat. Ez az alapeseti következtetés egy formája, ami a zárt világ feltételezéshez szorosan kapcsolódik: tételezzük fel, hogy valami hamis, ha nem bizonyítható, hogy igaz. Hogy a negálás mint kudarc-ot a logikai „¬” operátortól megkülönböztethessük, megjelölésére a „<span class="emphasis"><em>not</em></span>”-ot fogjuk használni.</p><p>A Prolog megengedi a <span class="emphasis"><em>not</em></span> operátort egy klóz törzsében. Tekintsük például az alábbi Prolog programot:</p><p><code class="code"><em><span class="remark">IDEmeghajtó </span></em>←<em><span class="remark"> Meghajtó </span></em>∧<em><span class="remark"> not SCSImeghajtó</span></em></code></p><p><code class="code"><em><span class="remark">SCSImeghajtó </span></em>←<em><span class="remark"> Meghajtó </span></em>∧<em><span class="remark"> not IDEmeghajtó</span></em></code></p><p><code class="code"><em><span class="remark">SCSIvezérlő </span></em>←<em><span class="remark"> SCSImeghajtó</span></em></code></p><p><code class="code">Meghajtó</code></p><p>Az első szabály azt mondja, hogy ha számítógépben merevlemez-meghajtónk van, és ez nem SCSI, akkor IDE-nek kell lennie. A másik szabály azt mondja, hogy ha ez nem IDE, akkor SCSI-nek kell lennie. A harmadik azt mondja, hogy az SCSI-meghajtó létezése egy SCSI-vezérlőt tételez fel, végül a negyedik kijelenti, hogy tényleg van egy meghajtó. Ennek a programnak <span class="emphasis"><em>két</em></span> minimálmodellje van:</p><p><code class="code"><em><span class="remark">M</span></em><sub>1 </sub>= {<em><span class="remark">Meghajtó, IDEmeghajtó</span></em>}</code></p><p><code class="code"><em><span class="remark">M</span></em><sub>2</sub><em><span class="remark"> </span></em>= {<em><span class="remark">Meghajtó, SCSImeghajtó, SCSIvezérlő</span></em>}</code></p><p>A minimálmodellek nem képesek a negálás mint kudarc-ot használó programok szándékolt szemantikáját kifejezni. Tekintsük a következő programot:</p><p><code class="code"><em><span class="remark">P</span></em> ← <em><span class="remark">not</span></em> <em><span class="remark">Q</span></em></code></p><p>Ennek két minimálmodellje van: {<span class="emphasis"><em>P</em></span>} és {<span class="emphasis"><em>Q</em></span>}<span class="emphasis"><em>.</em></span> Az elsőrendű logika szemszögéből van ennek értelme, mivel a <span class="emphasis"><em>P</em></span> ⇐ ¬<span class="emphasis"><em>Q</em></span> a <span class="emphasis"><em>P</em></span> ∨ <span class="emphasis"><em>Q</em></span>-val ekvivalens. A Prolog szemszögéből azonban aggódni kellene: <span class="emphasis"><em>Q</em></span> soha nem jelenik meg a nyíl bal oldalán, hogyan lehet hát egy következmény?</p><p>Egy alternatíva a <span class="strong"><strong>stabil modell</strong></span> (<span class="strong"><strong>stable model</strong></span>), ami egy olyan minimálmodell, ahol minden atomnak <span class="strong"><strong>igazolása</strong></span> (<span class="strong"><strong>justification</strong></span>) van, azaz létezik hozzá olyan szabály, amelyben a fej az atom, és ahol a törzs minden literálja kielégített. Formálisan <span class="emphasis"><em>M</em></span> egy <span class="emphasis"><em>H</em></span> program egy stabil modellje, ha <span class="emphasis"><em>M</em></span> a <span class="emphasis"><em>H</em></span> az <span class="emphasis"><em>M</em></span>-re vonatkozó <span class="strong"><strong>redukált</strong></span>jának (<span class="strong"><strong>reduct</strong></span>) egy egyértelmű minimálmodellje. Egy <span class="emphasis"><em>H</em></span> program redukáltját úgy definiáljuk, hogy <span class="emphasis"><em>H</em></span>-ból először minden olyan szabályt törlünk, amely törzsében a <span class="emphasis"><em>not A</em></span> literál szerepel, ahol <span class="emphasis"><em>A</em></span> a modell része, majd a maradó szabályokban a negatív literálokat töröljük. Mivel <span class="emphasis"><em>H</em></span> redukáltja most már egy Horn-klóz lista, egy egyértelmű minimálmodellel kell rendelkeznie.</p><p>A <span class="emphasis"><em>P</em></span> ← <span class="emphasis"><em>not</em></span> <span class="emphasis"><em>Q</em></span> redukáltja a {<span class="emphasis"><em>P</em></span>}-re nézve maga a {<span class="emphasis"><em>P</em></span>}, aminek minimálmodellje {<span class="emphasis"><em>P</em></span>}. Így {<span class="emphasis"><em>P</em></span>} egy stabil modell. A {<span class="emphasis"><em>Q</em></span>}-ra vonatkozó redukció egy üres program, aminek minimálmodellje {}<span class="emphasis"><em>. </em></span>{<span class="emphasis"><em>Q</em></span>} tehát nem stabil modell, mert Q-nak a (10.5) egyenletben nincs igazolás. Egy másik példa a (10.4) redukáltjára az <span class="emphasis"><em>M</em></span><sub>1</sub>-re nézve:</p><p><code class="code"><em><span class="remark">IDEmeghajtó </span></em>←<em><span class="remark"> Meghajtó</span></em></code></p><p><code class="code"><em><span class="remark">SCSIvezérlő </span></em>←<em><span class="remark"> SCSImeghajtó</span></em></code></p><p><code class="code">Meghajtó</code></p><p>Ennek minimálmodellje <span class="emphasis"><em>M</em></span><sub>1</sub>, így <span class="emphasis"><em>M</em></span><sub>1</sub> egy stabil modell. A <span class="strong"><strong>válaszhalmaz programozás</strong></span> (<span class="strong"><strong>answer set programming</strong></span>) a logikai programozásnak a negálás mint kudarc-cal bővített fajtája, amely úgy működik, hogy a logikai programot rögzített formába transzformálja, majd stabil modelleket (amelyeket <span class="strong"><strong>válaszhalmaz</strong></span>oknak – <span class="strong"><strong>answer set</strong></span>s – is neveznek) keres, ítéletkalkulus modell-ellenőrzési technikákat felhasználva. A válaszhalmaz-programozás leszármazottja tehát mind a Prolognak, mind az olyan gyors ítéletkalkulus-beli kielégíthetőségi tételbizonyítóknak, mint a <code class="code">WALKSAT</code>. A válaszhalmaz programozást sikerrel alkalmazták tervkészítési problémákra, hasonlóan az ítéletkalkulus-beli kielégíthetőségi tételbizonyítókhoz. A válaszhalmaz-programozás előnye más tervkészítőkkel szemben a rugalmassága: a tervkészítő operátorokat és a kényszereket logikai programokkal fejezi ki, és így azok nem kötődnek a konkrét tervkészítési formalizmus korlátozott formátumához. A válaszhalmaz-programozás hátránya ugyanaz, mint minden ítéletkalkulus szintű technikáé: ha az univerzumban túl sok objektum létezik, egy exponenciális lassulással kell számolnunk.</p></div><div class="section" title="Körülírás és alapeseti logika"><div class="titlepage"><div><div><h2 class="title"><a id="id633255"/>Körülírás és alapeseti logika</h2></div></div></div><p>Két példát láttunk, ahol látszólag természetes következtetési folyamatok megsértik a logika a 7. fejezetben bebizonyított <span class="strong"><strong>monotonitás</strong></span> (<span class="strong"><strong>monotonicity</strong></span>) tulajdonságát.<sup>[<a id="id633271" href="#ftn.id633271" class="footnote">106</a>]</sup> Az első példában egy szemantikus hálóban egy kategória összes tagja által megörökölt tulajdonságot egy alkategóriára vonatkozó specifikusabb információ felülírhatja. A másik példában a zárt világ feltételezésből származtatott negált literálokat pozitív literálok hozzáadása szintén felülbírálja.</p><p>Ha egy kicsit magunkba nézünk, rájövünk, hogy a monotonitás ilyen sérülései a józan ész következtetésben igen elterjedtek. Úgy tűnik, az emberek gyakran „elhamarkodott következtetéseket” vonnak le. Ha az utcán parkoló kocsit látunk, mindenki elhiszi, hogy a kocsinak négy kereke van, holott csak három kerék látszik (ha valaki a negyedik kerék létezésében kételkedik, akkor vegye fontolóra azt a kérdést, vajon a három látható kerék valódi-e, vagy csupán a valódinak egy papírmása.) A valószínűség-elmélet nyilván igazolhatja, hogy a negyedik kerék nagy valószínűséggel létezik, az emberek többségében az a lehetőség, hogy a gépkocsinak esetleg nincs négy kereke, egyáltalán fel sem merül, <span class="emphasis"><em>hacsak valami új tényállás erre nem derít fényt</em></span>. A négy kerék konklúzióját tehát <span class="emphasis"><em>alapesetként</em></span> kezeljük, a kételkedésre okot adó tények hiányában. Ha új tények érkeznek – észrevesszük például, hogy a tulajdonos a kereket elviszi, és a gépkocsi egy emelőn áll – akkor a konklúziót vissza kell vonni. Az ilyen következtetésről azt mondjuk, hogy <span class="strong"><strong>nemmonoton</strong></span> (<span class="strong"><strong>nonmonoton</strong></span>), mert a hiedelemek halmaza idővel, ahogy az új evidenciák megjelennek, nem növekszik monoton módon. Az ilyen viselkedés leírására <span class="strong"><strong>nemmonoton logiká</strong></span>kat (<span class="strong"><strong>nonmonoton logic</strong></span>s) fejlesztettek ki, módosított igazságdefinícióval és vonzatrelációval. Két ilyen intenzíven tanulmányozott logikát fogunk megnézni: a körülírást és az alapeseti logikát.</p><p>A <span class="strong"><strong>körülírás</strong></span>t (<span class="strong"><strong>circumscription</strong></span>) a zárt világ feltételezés erősebb és precízebb változatának lehetne tekinteni. Az ötlet, hogy konkrét predikátumokat specifikálunk, amelyekről feltételezzük, hogy „amennyire csak lehetséges hamisak” – azaz minden objektumra hamisak, kivéve azokat, amelyekre tudjuk, hogy igazak. Tegyük fel például, hogy ki akarjuk jelenteni azt az alapértelmezett szabályt, hogy a madarak tudnak repülni. Vezessük be az <span class="emphasis"><em>Abnormális</em></span><sub>1</sub>(<span class="emphasis"><em>x</em></span>) predikátumot, és írjuk fel:</p><p><code class="code"><em><span class="remark">Madár</span></em>(<em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Abnormális</span></em><sub>1</sub>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Repül</span></em>(<em><span class="remark">x</span></em>)</code></p><p>Ha azt mondjuk, hogy az <span class="emphasis"><em>Abnormális</em></span><sub>1</sub>-et <span class="strong"><strong>körül kell írni</strong></span> (<span class="strong"><strong>circumscribed</strong></span>), a körülíró következtető feltételezheti, hogy ¬<span class="emphasis"><em>Abnormális</em></span><sub>1</sub>(<span class="emphasis"><em>x</em></span>), hacsak az <span class="emphasis"><em>Abnormális</em></span><sub>1</sub>(<span class="emphasis"><em>x</em></span>)-et nem fogja igaznak találni. Ez lehetővé teszi, hogy a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>Tweety</em></span>) konklúziót levonjuk a <span class="emphasis"><em>Madár</em></span>(<span class="emphasis"><em>Tweety</em></span>) premissza alapján, azonban a konklúzió csak addig igaz, amíg az <span class="emphasis"><em>Abnormál</em></span>(<span class="emphasis"><em>Tweety</em></span>)-t ki nem jelentjük.</p><p>A körülírást a <span class="strong"><strong>modellpreferencia-logika</strong></span> (<span class="strong"><strong>model preference logic</strong></span>) egy példájának is tekinthetjük. Az ilyen logikákban egy állítás vonzatrelációban van (alapeseti státuson), ha igaz a tudásbázis minden <span class="emphasis"><em>preferált</em></span> modelljében, ellentétben a klasszikus logika igazságkövetelményével, hogy minden modellben legyen igaz. Körülírás esetében egy modell egy másiknál preferáltabb, ha kevesebb abnormális objektuma van.<sup>[<a id="id633446" href="#ftn.id633446" class="footnote">107</a>]</sup> Nézzük meg, hogy ez az ötlet hogyan működik szemantikus hálóban fellépő többszörös öröklődés esetén. A többszörös öröklődés standard példája az ún. „Nixon-gyémánt”.<sup>[<a id="id633465" href="#ftn.id633465" class="footnote">108</a>]</sup> Az eredete az a megfigyelés, hogy Richard Nixon egy kvéker vallási szektához tartozott (és így alapesetben pacifista) és republikánus is volt (és így alapesetben éppen nem pacifista). Ezt az alábbi módon írhatjuk fel: </p><p><code class="code"><em><span class="remark">Republikánus</span></em>(<em><span class="remark">Nixon</span></em>) ∧ <em><span class="remark">Kvéker</span></em>(<em><span class="remark">Nixon</span></em>)</code></p><p><code class="code"><em><span class="remark">Republikánus</span></em>(<em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Abnormális</span></em><sub>2</sub>(<em><span class="remark">x</span></em>) ⇒ ¬<em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Kvéker</span></em>(<em><span class="remark">x</span></em>) ∧ ¬<em><span class="remark">Abnormális</span></em><sub>3</sub>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>)</code></p><p>Ha az <span class="emphasis"><em>Abnormális</em></span><sub>2</sub>-t és az <span class="emphasis"><em>Abnormális</em></span><sub>3</sub>-at körülírjuk, két preferált modellt kapunk: az egyikben igaz az <span class="emphasis"><em>Abnormális</em></span><sub>2</sub>(<span class="emphasis"><em>Nixon</em></span>) és a <span class="emphasis"><em>Pacifista</em></span>(<span class="emphasis"><em>Nixon</em></span>), a másikban igaz az <span class="emphasis"><em>Abnormális</em></span><sub>3</sub>(<span class="emphasis"><em>Nixon</em></span>) és a ¬<span class="emphasis"><em>Pacifista</em></span>(<span class="emphasis"><em>Nixon</em></span>). A körülíró következtető rendszer tehát megfelelően tudatlannak mutatkozik a pacifista Nixon ügyében. Ha ezentúl szeretnénk kijelenteni, hogy a vallásos meggyőződések elsőbbséget élveznek a politikai nézetekkel szemben, a <span class="strong"><strong>prioritásos körülírás</strong></span> (<span class="strong"><strong>prioritized circumscription</strong></span>) formalizmusát használhatjuk, hogy azoknak a modelleknek adjunk elsőbbséget, ahol az <span class="emphasis"><em>Abnormális</em></span><sub>3</sub> minimálizálva van. </p><p>Az <span class="strong"><strong>alapértelemzett logika</strong></span> (<span class="strong"><strong>default logic</strong></span>) egy olyan formalizmus, ahol <span class="strong"><strong>alapértelmezett szabály</strong></span>okat (<span class="strong"><strong>default rule</strong></span>s) lehet írni feltételes, nemmonoton következtetések generálásához. Egy alapértelmezett szabály a következőképpen néz ki:</p><p><code class="code"><em><span class="remark">Madár</span></em>(<em><span class="remark">x</span></em>) : <em><span class="remark">Repül</span></em>(<em><span class="remark">x</span></em>) /<em><span class="remark">Repül</span></em>(<em><span class="remark">x</span></em>)</code></p><p>A szabály jelentése, hogy ha a <span class="emphasis"><em>Madár</em></span>(<span class="emphasis"><em>x</em></span>) igaz, és ha a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>x</em></span>) a tudásbázissal konzisztens, akkor a <span class="emphasis"><em>Repül</em></span>(<span class="emphasis"><em>x</em></span>)-et alapértelmezésben lekövetkeztethetjük. Általánosságban egy alapértelmezett szabály formája a:</p><p class="1"><code class="code"><em><span class="remark">P</span></em> : <em><span class="remark">J</span></em><sub>1</sub>, …, J<sub>n</sub>/<em><span class="remark">C</span></em></code></p><p class="1">ahol <span class="emphasis"><em>P</em></span>-t előfeltételnek, <span class="emphasis"><em>C</em></span>-t konkluziónak és a <span class="emphasis"><em>J<sub>i</sub></em></span>-ket igazolásoknak nevezik – ha ezek közül bármelyik igazolhatóan hamis, a konklúziót levonni nem szabad. A <span class="emphasis"><em>C</em></span>-ben és a <span class="emphasis"><em>J<sub>i</sub></em></span>-ben előforduló minden változónak <span class="emphasis"><em>P</em></span>-ben is meg kell jelennie. A Nixon-gyémánt példáját alapértelmezett logikában egy ténnyel és két alapértelmezett szabállyal fejezhetjük ki:</p><p><code class="code"><em><span class="remark">Republikánus</span></em>(<em><span class="remark">Nixon</span></em>) ∧ <em><span class="remark">Kvéker</span></em>(<em><span class="remark">Nixon</span></em>)</code></p><p><code class="code"><em><span class="remark">Republikánus</span></em>(<em><span class="remark">x</span></em>) : ¬<em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>)/ ¬<em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Kvéker</span></em>(<em><span class="remark">x</span></em>) : <em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>) /<em><span class="remark">Pacifista</span></em>(<em><span class="remark">x</span></em>)</code></p><p class="1">Egy alapértelmezett szabály jelentésének interpretálásához az alapértelmezett elmélet <span class="strong"><strong>kiterjesztés</strong></span>ét (<span class="strong"><strong>extension</strong></span>) kell definiálnunk, az elmélet konklúzióinak maximális halmazaként. Egy <span class="emphasis"><em>S</em></span> kiterjesztés tehát az eredetileg ismert tényekből és az alapértelmezett szabályokból levont konklúzióhalmazból áll úgy, hogy <span class="emphasis"><em>S</em></span>-ből semmilyen más konklúziót levonni már nem lehet, és <span class="emphasis"><em>S</em></span>-beli alapértelmezett konklúzió minden igazolása <span class="emphasis"><em>S</em></span>-sel konzisztens. A körülírásban tárgyalt preferált modellekhez hasonlóan a Nixon-gyémántra két lehetséges kiterjesztésünk van: egy, amelyben pacifista és egy, amelyben nem az. Léteznek prioritásos sémák, ahol egyes alapértelmezett szabályoknak precedenciát lehet biztosítani más szabályokkal szemben, és ezzel a nem egyértelmű helyzeteket valamelyest fel lehet oldani.</p><p>1980 óta, amikor is a nemmonoton logikákat első ízben javasolták, igen nagy előrehaladás történt a matematikai tulajdonságuk megértésében. A késői 1990-es évektől kezdve a logikai programozáson alapuló gyakorlati rendszerek ígéretesnek bizonyultak a tudásreprezentációs eszközök szerepében. Vannak azonban még meg nem válaszolt kérdések. Így például ha „a gépkocsiknak négy kerekük van” hamis, mit is jelent, ha egy ilyen állítás a tudásbázis része? Milyen az alapértelmezett szabályok egy jó halmaza? Ha minden szabályról külön-külön nem tudjuk eldönteni, hogy a tudásbázisunkhoz tartozik-e, akkor igen komoly problémánk van a modularitás hiányával. Végül, hogyan lehet alapértelmezett státussal rendelkező hiedelmeket a döntéshozatalban felhasználni? Ez talán az alapértelmezett következtetés legnehezebb problémája. A döntések sokszor kompromiszszumokkal járnak együtt, és így szükség van különböző cselekvések eredményeként megjelenő hiedelmek <span class="emphasis"><em>erősségét</em></span> összehasonlítani. Azokban az esetekben, amikor ugyanilyen jellegű döntésket sokszor hozunk meg, lehetőség adódik, hogy az alapértelmezett szabályokat „küszöb-valószínűségi” állításokként értelmezzük. Például „a fékjeim rendben vannak” alapértelmezett szabály valójában azt jelenti, hogy „annak a valószínűsége, hogy a fékjeim rendben vannak, feltéve, hogy más információm nincs, elegendően magas ahhoz, hogy az optimális döntés számomra az, hogy induljak útnak a fékek ellenőrzése nélkül”. Amikor a döntés kontextusa megváltozik – például amikor egy súlyosan megrakott teherkocsit vezetünk egy lejtős hegyi úton –, az alapértelmezett szabály hirtelen alkalmatlanná válik, akkor is, ha semmilyen új evidenciánk nincs, ami azt sugallná, hogy a fékek hibásak. Az ilyen mérlegelések néhány kutatót arra vezettek, hogy mérlegeljék, hogyan ágyazzák be az alapértelmezett következtetést a valószínűség-elméletbe.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id632574" href="#id632574" class="para">104</a>] </sup> A felfedezőjéről, Keith Clarkról néha Clark-lezárásnak is nevezik.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id632583" href="#id632583" class="para">105</a>] </sup> Jegyezzük meg, hogy ez egyben a 10.3. alfejezetben megadott követő állapot axiómák alakja is.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id633271" href="#id633271" class="para">106</a>] </sup> Emlékezzünk vissza, hogy a monotonitás megköveteli, hogy minden vonzatállítás igaz maradjon, amikor a tudásbázishoz új állításokat adunk hozzá. Azaz ha <span class="emphasis"><em>TB </em></span>⊨<span class="emphasis"><em>α</em></span>, akkor <span class="emphasis"><em>TB</em></span> ∧ <span class="emphasis"><em>β</em></span> ⊨ <span class="emphasis"><em>α</em></span>.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id633446" href="#id633446" class="para">107</a>] </sup> A zárt világ feltételezésnél egy modell egy másiknál preferáltabb, ha kevesebb igaz atomja van – azaz a preferált modellek <span class="strong"><strong>minimálmodell</strong></span>ek. A <span class="strong"><strong>CWA</strong></span> és a definit klóz tudásbázis között létezik természetes kapcsolat, mert az ilyen tudásbázisban az előrecsatolt következtetés révén elért fix pont az egyértelmű minimálmodell (<a class="xref" href="ch07s04.md#ID_274_oldal">„Előre- és hátrafelé láncolás”</a>részben).</p></div><div class="footnote"><p><sup>[<a id="ftn.id633465" href="#id633465" class="para">108</a>] </sup> A „gyémánt” elnevezés a két úton futó öröklődési lánc gráfszerű alakjától származik. (<span class="emphasis"><em>A ford.</em></span>)</p></div></div></div></body></html>
