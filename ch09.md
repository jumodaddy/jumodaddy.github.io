<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="chapter" title="9. fejezet - Következtetés elsőrendű logikában"><div class="titlepage"><div><div><h1 class="title"><a id="id604168"/>9. fejezet - Következtetés elsőrendű logikában</h1></div></div></div><p><span class="emphasis"><em>Ebben a fejezetben definiálunk egy olyan hatékony következtetési mechanizmust, amelyik képes megválaszolni az elsőrendű logikában feltett kérdéseket.</em></span></p><p>A 7. fejezetben meghatároztuk a <span class="strong"><strong>következtetés</strong></span> (<span class="strong"><strong>inference</strong></span>) fogalmát, és bemutattuk, hogy hogyan érhető el helyes és teljes következtetés az ítéletlogikában. Ebben a fejezetben kiterjesztjük ezeket az eredményeket, hogy olyan algoritmusokat kapjunk, amelyek bármely, az elsőrendű logikában feltehető kérdésre válaszolni tudnak. Ez jelentős eredmény, mivel az elsőrendű logikával többé-kevésbé mindent kifejezhetünk, ha elég alaposan végezzük a feladatot.</p><p>A 9.1. alfejezet következtetési szabályokat vezet be a kvantorokra, és megmutatja, hogy hogyan lehet – jóllehet nagy erőfeszítések árán – az elsőrendű logikai következtetést ítéletlogikai következtetésre redukálni. A 9.2. alfejezet leírja az <span class="strong"><strong>egyesítés</strong></span> (<span class="strong"><strong>uni</strong></span><span class="strong"><strong>fication</strong></span>) ötletét, bemutatva, hogy az egyesítés felhasználásával, hogyan alkothatunk következtetési szabályokat, amelyek közvetlenül az elsőrendű logikai mondatokra alkalmazhatók. Ezután a 9.3. alfejezetben megvizsgáljuk az elsőrendű logikai algoritmusok három nagy családját: az <span class="strong"><strong>előrefelé láncolás</strong></span>t (<span class="strong"><strong>forward chaining</strong></span>) és ennek alkalmazását a <span class="strong"><strong>deduktív adatbázis</strong></span>okban (<span class="strong"><strong>deductive database</strong></span>s) és a <span class="strong"><strong>produkciós rendszer</strong></span>ekben (<span class="strong"><strong>production system</strong></span>s). A <span class="strong"><strong>hátrafelé láncolás</strong></span>t (<span class="strong"><strong>backward chaining</strong></span>) és a <span class="strong"><strong>logikai programozás</strong></span>t (<span class="strong"><strong>logic programming</strong></span>) alkalmazó rendszereket a 9.4. alfejezetben tárgyaljuk; míg a rezolúció alapú <span class="strong"><strong>tételbizonyító</strong></span> (<span class="strong"><strong>theorem-proving</strong></span>) rendszereket a 9.5. alfejezet ismerteti. Általánosságban mindig a leghatékonyabb, az adott feladatban reprezentálandó tényeket és axiómákat kezelni képes módszert próbáljuk használni. A teljesen általános, a tetszőleges elsőrendű logikai mondatokon alkalmazható rezolúciós következtetés általában kevésbé hatékony, mint a bizonyos típusú mondatokon alkalmazható előre- vagy hátrafelé láncolást használó megoldások.</p><div class="section" title="Ítéletlogikai következtetés kontra elsőrendű logikai következtetés"><div class="titlepage"><div><div><h1 class="title"><a id="id604262"/>Ítéletlogikai következtetés kontra elsőrendű logikai következtetés </h1></div></div></div><p>Ez és a következő alfejezet bemutatja azokat a gondolatokat, amelyeken a modern logikai következtetési rendszerek alapulnak. Néhány egyszerű következtetési szabállyal kezdjük, amelyeket kvantorral ellátott mondatokhoz alkalmazhatunk, hogy a segítségükkel kvantorok nélküli mondatokhoz juthassunk. Ezek a szabályok természetes módon elvezetnek minket ahhoz a gondolathoz, hogy az <span class="emphasis"><em>elsőrendű </em></span>következtetés megvalósítható azáltal, hogy a tudásbázist <span class="emphasis"><em>ítéletlogikává</em></span> alakítjuk át, és a már általunk ismert <span class="emphasis"><em>ítéletlogikai </em></span>következtetést használjuk. A következő alfejezet rámutat egy kézenfekvő egyszerűsítésre, amellyel olyan következtetési módszerekhez juthatunk, amelyek közvetlenül képesek az elsőrendű mondatok felhasználására.</p><div class="section" title="Kvantorokra vonatkozó következtetési szabályok"><div class="titlepage"><div><div><h2 class="title"><a id="id604278"/>Kvantorokra vonatkozó következtetési szabályok </h2></div></div></div><p>Kezdjük az univerzális kvantorok vizsgálatával. Tételezzük fel, hogy a tudásbázisunk tartalmazza a standard hagyományos axiómákat, amelyek szerint minden mohó király gonosz:</p><p><code class="code">∀<em><span class="remark">x Király</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">x</span></em>)</code></p><p>Ebből lehetségesnek tűnik kikövetkeztetni a következő mondatokat:</p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">János</span></em>) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">János</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">Richárd</span></em>) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">Richárd</span></em>) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">Richárd</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">Apja</span></em>(<em><span class="remark">János</span></em>)) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">Apja</span></em>(<em><span class="remark">János</span></em>)) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">Apja</span></em>(<em><span class="remark">János</span></em>))</code></p><p><code class="code">...</code></p><p>Az <span class="strong"><strong>univerzális példányosítás</strong></span> (<span class="strong"><strong>Universal Instantiation</strong></span>, <span class="strong"><strong>UI</strong></span>) szabálya kimondja, hogy az adott változó bármely <span class="strong"><strong>alapterm</strong></span>mel (<span class="strong"><strong>ground term</strong></span>) (változók nélküli termmel) való helyettesítésével elérhető mondatokat kikövetkeztethetjük.<sup>[<a id="id604426" href="#ftn.id604426" class="footnote">87</a>]</sup> Ahhoz, hogy formálisan le tudjuk írni a következtetési szabályokat, a 8.3. alfejezetben bevezetett <span class="strong"><strong>helyettesítés</strong></span> (<span class="strong"><strong>substitution</strong></span>) fogalmát használjuk. A <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>, <span class="emphasis"><em>α</em></span>) fogja jelölni annak az eredményét, hogy egy<span class="emphasis"><em> θ </em></span>behelyettesítést alkalmazunk az <span class="emphasis"><em>α </em></span>mondathoz. Ekkor a szabály így írható le:</p><p><span class="inlinemediaobject"><img src="math/mi-09-0001.gif" alt="Kvantorokra vonatkozó következtetési szabályok"/></span></p><p>bármely <span class="emphasis"><em>v </em></span>változóra és <span class="emphasis"><em>g </em></span>alaptermre. Például a korábban megadott három mondatot megkaphatjuk a következő helyettesítésekkel {<span class="emphasis"><em>x/János</em></span>}, {<span class="emphasis"><em>x/Richárd</em></span>} és {<span class="emphasis"><em>x/Apjα</em></span>(<span class="emphasis"><em>János</em></span>)}.</p><p>Az ennek megfelelő <span class="strong"><strong>egzisztenciális példányosítás</strong></span>i (<span class="strong"><strong>Existential Instantiation</strong></span>) szabály az egzisztenciális kvantorra egy kicsivel komplikáltabb. Minden <span class="emphasis"><em>α</em></span> mondatra, <span class="emphasis"><em>v </em></span>változóra és olyan <span class="emphasis"><em>k </em></span>konstans szimbólumra, amely sehol máshol nem jelenik meg a tudásbázisban:</p><p><span class="inlinemediaobject"><img src="math/mi-09-0002.gif" alt="Kvantorokra vonatkozó következtetési szabályok"/></span></p><p>Például abból a mondatból, hogy:</p><p><code class="code">∃<em><span class="remark">x Korona</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Fején</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> János</span></em>)</code></p><p>kikövetkeztethetjük ezt a mondatot:</p><p><code class="code"><em><span class="remark">Korona</span></em>(<em><span class="remark">C</span></em><sub>1</sub>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Fején</span></em>(<em><span class="remark">C</span></em><sub>1</sub>,<em><span class="remark"> János</span></em>)</code></p><p>feltéve, ha a <span class="emphasis"><em>C</em></span><sub>1</sub><span class="emphasis"><em> </em></span>nem jelenik meg sehol máshol a tudásbázisban. Alapjában véve az egzisztenciális mondat azt mondja ki, hogy van valamely objektum, amely eleget tesz egy feltételnek, és a példányosítás folyamata csak névvel látja el ezt az objektumot. Ez a név viszont már nem tartozhat más objektumhoz. Egy szép példát találunk a matematikában: tételezzük fel, hogy tudjuk, létezik olyan szám, amely egy kicsit kisebb, mint 2,71828, és eleget tesz annak az egyenletnek, hogy: <span class="emphasis"><em>d</em></span>(<span class="emphasis"><em>x<sup>y</sup></em></span>)/<span class="emphasis"><em>dy </em></span>=<span class="emphasis"><em> x<sup>y</sup> </em></span>az <span class="emphasis"><em>x</em></span>-re. Adhatunk nevet ennek a számnak, mint például <span class="emphasis"><em>e</em></span>,<span class="emphasis"><em> </em></span>de hiba lenne olyan nevet adni, amely már egy létező objektumhoz tartozik, mint például a Π. A logikában ezt az új nevet <span class="strong"><strong>Skolem-konstans</strong></span>nak (<span class="strong"><strong>Skolem constant</strong></span>) nevezzük. Az egzisztenciális példányosítás egy speciális esete egy általánosabb folyamatnak, amelyet <span class="strong"><strong>skolemizáció</strong></span>nak (<span class="strong"><strong>skolemization</strong></span>) nevezünk, és amelyet a 9.5. alfejezetben mutatunk be.</p><p>Amellett hogy az egzisztenciális példányosítás bonyolultabb, mint az univerzális példányosítás, kissé különböző szerepet is játszik a következtetésben. Míg az univerzális példányosítást többször is alkalmazhatjuk, hogy sok különböző eredményhez jussunk, az egzisztenciális példányosítást csak egyszer végezhetjük el, majd az egzisztenciális kvantorral ellátott mondattól megszabadulhatunk. Például amint hozzáadtuk a tudásbázishoz a <span class="emphasis"><em>Meggyilkol</em></span>(<span class="emphasis"><em>Gyilkos</em></span>,<span class="emphasis"><em> Áldozat</em></span>)<span class="emphasis"><em> </em></span>mondatot,<span class="emphasis"><em> </em></span>már nincs szükségünk a ∃<span class="emphasis"><em>x Meggyilkol</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> Áldozat</em></span>)<span class="emphasis"><em> </em></span>mondatra<span class="emphasis"><em>. </em></span>Pontosabban megfogalmazva, az új tudásbázis logikailag nem ekvivalens a régivel, de tekinthetjük úgy, hogy a <span class="strong"><strong>következtetés szempontjából ekvivalens</strong></span> (<span class="strong"><strong>inferentially equivalent</strong></span>), azaz pontosan akkor kielégíthető, amikor az eredeti tudásbázis is kielégíthető.</p></div><div class="section" title="Redukálás ítéletlogikára"><div class="titlepage"><div><div><h2 class="title"><a id="id604692"/>Redukálás ítéletlogikára</h2></div></div></div><p>Ha egyszer vannak szabályaink arra, hogy kvantorral ellátott mondatokból hogyan következtethetünk kvantor nélküli mondatokra, akkor vissza tudjuk vezetni az elsőrendű következtetést az ítéletlogikai következtetésre. Ebben az alfejezetben áttekintjük ennek a módszernek a legfontosabb elemeit; a részletekről a 9.5. alfejezetben<span class="emphasis"><em> </em></span>fogunk szólni. </p><p>Az első gondolat az, hogy éppen úgy, ahogyan egy egzisztenciális kvantorral ellátott mondatot felcserélhetünk a mondat egy példányával, egy univerzális kvantorral ellátott mondatot is felcserélhetünk a mondat <span class="emphasis"><em>összes lehetséges </em></span>példányosításainak halmazával. Például tételezzük fel, hogy a tudásbázisunk mindössze a következő mondatokat tartalmazza:</p><p><code class="code">∀<em><span class="remark">x Király</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">x</span></em>)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Gonosz</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>)<em><span class="remark">							</span></em>(9.1)</code></p><p><code class="code"><em><span class="remark">Mohó</span></em>(<em><span class="remark">János</span></em>)</code></p><p><code class="code"><em><span class="remark">Fivér</span></em>(<em><span class="remark">Richárd</span></em>, <em><span class="remark">János</span></em>)<em><span class="remark"> </span></em></code></p><p>Ekkor alkalmazzuk az univerzális páldányosítást az első mondatra úgy, hogy az összes lehetséges alapterm-helyettesítést felhasználjuk a tudásbázisszótárból, ami ebben az esetben az {<span class="emphasis"><em>x/János</em></span>} és az {<span class="emphasis"><em>x/Richárd</em></span>}. Így ezt kapjuk:</p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Mohó</span></em>(<em><span class="remark">János</span></em>)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Gonosz</span></em>(<em><span class="remark">János</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">Richárd</span></em>)<em><span class="remark"> </span></em>∧<em><span class="remark"> Mohó</span></em>(<em><span class="remark">Richárd</span></em>)<em><span class="remark"> </span></em>⇒<em><span class="remark"> Gonosz</span></em>(<em><span class="remark">Richárd</span></em>)</code></p><p>és megválhatunk az univerzális kvantorral ellátott mondattól. Mármost, a tudásbázist alapvetően ítéletkalkulus-belinek tekinthetjük, ha az alap atomi mondatokat, mint a <span class="emphasis"><em>Király</em></span>(<span class="emphasis"><em>János</em></span>),<span class="emphasis"><em> Mohó</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em> </em></span>stb., ítéletlogikai szimbólumoknak tekintjük. Így tehát a 7. fejezetben bemutatott bármely teljes ítéletlogikai algoritmust alkalmazhatjuk, hogy olyan következtetéshez juthassunk, mint a <span class="emphasis"><em>Gonosz</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em>.</em></span></p><p>Ez a technika az <span class="strong"><strong>ítéletlogikai állításokra való visszavezetés</strong></span> (<span class="strong"><strong>propositionalization</strong></span>), amelyet teljesen általánossá tehetünk, mint azt a 9.5. alfejezetben be is fogjuk mutatni. Ez azt jelenti, hogy minden elsőrendű tudásbázis és lekérdezés átalakítható ítéletlogikai mondatokra úgy, hogy a tudásbázis vonzatai nem változnak. Így tehát van egy teljes következtetési folyamatunk vonzatok levezetésére. Vagy talán mégsem? Van egy probléma: amikor a tudásbázis tartalmaz függvényszimbólumot, a lehetséges alaptermek helyettesítéseinek halmaza végtelen! Például ha a tudásbázis megemlíti az <span class="emphasis"><em>Apja </em></span>szimbólumot, akkor végtelen számú egymásba ágyazott termeket hozhatunk létre, mint például az <span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>János</em></span>))).<span class="emphasis"><em> </em></span>Az ítéletlogikai algoritmusainknak tehát nehézségeik lesznek a végtelen nagyságú mondathalmazokkal.</p><p>Szerencsére ismert egy Jacques Herbrandnak köszönhető híres tétel az előbbi problémára (Herbrand, 1930), ami azt mondja ki, hogy ha egy mondat következik az eredeti, elsőrendű tudásbázisból, akkor létezik olyan bizonyítás, amely csak egy véges méretű részhalmazt használ fel az ítéletkalkulus-belire átalakított tudásbázisból. Mivel bármely ilyen részhalmazban az alaptermeknek van egy maximális beágyazási mélysége, meg lehet találni a részhalmazt úgy, hogy először generáljuk az összes példányt a konstans szimbólumokhoz (<span class="emphasis"><em>Richárd </em></span>és <span class="emphasis"><em>János</em></span>), azután az összes 1-es mélységű termet (<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>Richárd</em></span>)<span class="emphasis"><em> </em></span>és <span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>János</em></span>)),<span class="emphasis"><em> </em></span>majd az összes 2-es mélységű termet, és így tovább mindaddig, amíg képesek leszünk megalkotni a vonzatmondat ítéletlogikai bizonyítását. </p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Felvázoltuk az elsőrendű következtetés egy megközelítését  az ítéletlogikai állításokra való visszavezetés révén, amely <span class="strong"><strong>teljes</strong></span> (<span class="strong"><strong>complete</strong></span>) – tehát bármely következményként kapott mondatot bizonyítani tudunk. Ez jelentős eredmény, ha figyelembe vesszük, hogy a lehetséges modellek száma végtelen. Másrészt viszont nem tudhatjuk, hogy a mondat <span class="emphasis"><em>vonzat-e,</em></span> amíg a bizonyítás nincs kész<span class="emphasis"><em>. </em></span>Mi történik, ha <span class="emphasis"><em>α mondat nem vonzata a TB-nek?</em></span> Meg tudjuk-e ezt állapítani? Nos, ahogy ez majd kiderül, az elsőrendű logika esetében erre a kérdésre a válasz nemleges. A bizonyítási eljárás tovább folytatódik, egyre mélyebben beágyazott termeket generálva, és nem tudhatjuk, hogy a folyamat egy végtelen ciklusba kerül, vagy hamarosan megleljük a bizonyítást. Ez nagyon hasonló a Turing gépek leállási problémájához. Alan Turing és Alonzo Church egymástól függetlenül és eltérő módon bizonyították be ennek a kérdésnek az eldönthetetlenségére vonatkozó tételt (Turing, 1936; Church, 1936). <span class="emphasis"><em>Az elsőrendű logikában a maga után vonzás kérdése <span class="strong"><strong>félig eldönthető</strong></span> </em></span>(<span class="emphasis"><em><span class="strong"><strong>semidecidable</strong></span></em></span>)<span class="emphasis"><em>, ami azt jelenti, hogy létezik olyan algoritmus, amely igent mond minden vonzatmondatra, de nem létezik olyan algoritmus, amely emellett képes nemet mondani a nem levezethető mondatokra.</em></span> </p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id604426" href="#id604426" class="para">87</a>] </sup> Ne keverjük össze ezeket a helyettesítéseket a kiterjesztett interpretációkkal, amelyeket a kvantorok szemantikájának a meghatározására használtunk. A helyettesítés egy változót cserél le egy termre (egy szintaktikai elemre), hogy új mondatot hozzon létre, ezzel szemben egy interpretáció hozzárendel egy változót egy objektumhoz a tárgyterületben.</p></div></div></div></body></html>
