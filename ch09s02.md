<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Egyesítés és kiemelés"><div class="titlepage"><div><div><h1 class="title"><a id="id604985"/>Egyesítés és kiemelés</h1></div></div></div><p>Az előző alfejezet bemutatta az elsőrendű következtetésnek azt az értelmezését, amely az 1960-as évekig létezett. Az éles szemű olvasók (és bizonyára a hatvanas évek elejének logikával foglalkozó kutatói) észrevehették, hogy az ítéletlogikai megközelítés nem nagyon hatékony. Például ha megnézzük a <span class="emphasis"><em>Gonosz</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>lekérdezést<span class="emphasis"><em> </em></span>és az ehhez tartozó tudásbázist a (9.1) egyenletben, feleslegesnek tűnik olyan mondatok generálása, mint a <span class="emphasis"><em>Király</em></span>(<span class="emphasis"><em>Richárd</em></span>) ∧ <span class="emphasis"><em>Mohó</em></span>(<span class="emphasis"><em>Richárd</em></span>) ⇒ <span class="emphasis"><em>Gonosz</em></span>(<span class="emphasis"><em>Richárd</em></span>)<span class="emphasis"><em>. </em></span>Valójában a <span class="emphasis"><em>Gonosz</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em> </em></span>mondatra vonatkozó következtetés bárki számára teljesen nyilvánvaló a következő mondatok alapján: <span class="emphasis"><em> </em></span></p><p><code class="code">∀<em><span class="remark">x Király</span></em>(<em><span class="remark">x</span></em>) ∧ <em><span class="remark">Mohó</span></em>(<em><span class="remark">x</span></em>) ⇒ <em><span class="remark">Gonosz</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>)</code></p><p><code class="code"><em><span class="remark">Mohó</span></em>(<em><span class="remark">János</span></em>)</code></p><p>Most megmutatjuk, hogyan tehetjük ezt a számítógép számára is egyértelművé.</p><div class="section" title="Egy elsőrendű következtetési szabály"><div class="titlepage"><div><div><h2 class="title"><a id="id605091"/>Egy elsőrendű következtetési szabály</h2></div></div></div><p>Az a következtetés, hogy János gonosz a következőképpen megy végbe: találjon egy <span class="emphasis"><em>x</em></span>-et, amelyre igaz, hogy <span class="emphasis"><em>x</em></span> egy király és <span class="emphasis"><em>x </em></span>mohó, majd következtesse ki, hogy <span class="emphasis"><em>x </em></span>gonosz. Általánosabban, ha van valamely <span class="emphasis"><em>θ </em></span>helyettesítés, amely az implikáció premisszáját megegyezővé teszi a tudásbázisban már létező mondatokkal, akkor a <span class="emphasis"><em>θ </em></span>helyettesítés elvégzése után az implikációkövetkezmény részét hozzáadhatjuk a tudásbázishoz. Ebben az esetben az {<span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>János</em></span>} helyettesítés eléri ezt a célt.</p><p>Tulajdonképpen több feladatot is elvégeztethetünk a következtetés ezen lépésével. Tételezzük fel, hogy a <span class="emphasis"><em>Mohó</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em> </em></span>mondat ismerete<span class="emphasis"><em> </em></span>helyett csak azt tudjuk, hogy <span class="emphasis"><em>mindenki </em></span>mohó:</p><p><code class="code">∀<em><span class="remark">y Mohó</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark">							</span></em>(9.2)</code></p><p>Ebben az esetben is szeretnénk azt a következtetést levonni, hogy <span class="emphasis"><em>Gonosz</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em>, </em></span>mivel tudjuk, hogy János egy király (ez adott), és hogy János mohó (mert mindenki mohó). Egy megfelelő helyettesítés megtalálására van szükségünk ennek elvégzéséhez, mind az implikációs mondatban, mind az ehhez illesztendő mondatokban található változókra. Ebben az esetben az {<span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> y</em></span>/<span class="emphasis"><em>János</em></span>} helyettesítés alkalmazása az implikáció <span class="emphasis"><em>Király</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> </em></span>és <span class="emphasis"><em>Mohó</em></span>(<span class="emphasis"><em>x</em></span>) premisszáihoz és a <span class="emphasis"><em>Király</em></span>(<span class="emphasis"><em>János</em></span>)<span class="emphasis"><em> </em></span>és <span class="emphasis"><em>Mohó</em></span>(<span class="emphasis"><em>y</em></span>)<span class="emphasis"><em> </em></span>tudásbázis mondatokhoz létrehozza az azonosságot. Így tehát ki tudjuk következtetni az implikáció konklúzióját.</p><p>Ez a következtetés elvégezhető egyetlen következtetési szabály alkalmazásával, amelyet <span class="strong"><strong>általánosított Modus Ponens</strong></span>nek (<span class="strong"><strong>Generalized Modus Ponens</strong></span>) nevezünk: a <span class="emphasis"><em>p<sub>i</sub></em></span>, <span class="emphasis"><em>p</em></span>′<sub>i </sub>és <span class="emphasis"><em>q</em></span> atomi mondatokra, amelyekre létezik olyan <span class="emphasis"><em>θ</em></span> helyettesítés, hogy <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>, <span class="emphasis"><em>p</em></span>′<sub>i</sub>) = <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>, <span class="emphasis"><em>p<sub>i</sub></em></span>) minden <span class="emphasis"><em>i</em></span>-re, akkor:</p><p><span class="inlinemediaobject"><img src="math/mi-09-0003.gif" alt="Egy elsőrendű következtetési szabály"/></span></p><p>A szabály <span class="emphasis"><em>n </em></span>+<span class="emphasis"><em> </em></span>1 premisszát tartalmaz: <span class="emphasis"><em>n</em></span> számú <span class="emphasis"><em>p</em></span>′<sub><sub>i</sub> </sub> atomi mondatot és egy implikációt. A konklúzió a <span class="emphasis"><em>q</em></span> konzekvenciára történő helyettesítés alkalmazásának az eredménye. A mi példánkra ezt így alkalmazhatjuk:</p><p><code class="code"><em><span class="remark">p′</span></em><sub>1</sub> – <em><span class="remark">Király</span></em>(<em><span class="remark">János</span></em>)<em><span class="remark">		p</span></em><sub>1</sub><em><span class="remark"> – Király</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">p′</span></em><sub>2</sub> – <em><span class="remark">Mohó</span></em>(<em><span class="remark">y</span></em>)<em><span class="remark">		</span></em>	<em><span class="remark">p</span></em><sub>2</sub><em><span class="remark"> – Mohó </span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code"><em><span class="remark">θ</span></em> – {<em><span class="remark">x</span></em>/<em><span class="remark">János</span></em>,<em><span class="remark"> y</span></em>/<em><span class="remark">János</span></em>}		<em><span class="remark">q – Gonosz</span></em>(<em><span class="remark">x</span></em>)</code></p><p><code class="code">Helyettesít(<em><span class="remark">θ</span></em>, <em><span class="remark">q</span></em>)<em><span class="remark"> </span></em>– <em><span class="remark">Gonosz</span></em>(<em><span class="remark">János</span></em>)</code></p><p>Könnyű megmutatni, hogy az általánosított Modus Ponens helyes következtetési szabály. Először is, megfigyelhetjük, hogy bármely <span class="emphasis"><em>p </em></span>mondatra (amelyeknek változóiról feltételezzük, hogy univerzális kvantorokkal vannak ellátva) és bármely <span class="emphasis"><em>θ </em></span>helyettesítésre:</p><p><code class="code"><em><span class="remark">p </span></em>⊭  Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> p</span></em>)</code></p><p>Ez hasonlóan igazolható, mint az univerzális példányosítás szabály, és alkalmazható olyan <span class="emphasis"><em>θ-</em></span>ra, amely kielégíti az általánosított Modus Ponens szabály feltételeit. Így tehát, a <span class="emphasis"><em>p</em></span><sub>1</sub>′,…, <span class="emphasis"><em>p<sub>n</sub></em></span>′<span class="emphasis"><em> </em></span>-ből következtethetjük, hogy:</p><p><code class="code">Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> p′</span></em><sub>1</sub>)<em><span class="remark"> </span></em>∧ <em><span class="remark">…</span></em> ∧ Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> p′<sub>n</sub></span></em>)</code></p><p>és a <span class="emphasis"><em>p</em></span><sub>1</sub><span class="emphasis"><em> </em></span>∧<span class="emphasis"><em> … </em></span>∧ <span class="emphasis"><em>p<sub>n</sub></em></span> ⇒ <span class="emphasis"><em>q </em></span>implikációból ezt következtethetjük, hogy:</p><p><code class="code">Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> p</span></em><sub>1</sub>) ∧ … ∧ Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> p<sub>n</sub></span></em>) ⇒ Helyettesít(<em><span class="remark">θ</span></em>,<em><span class="remark"> q</span></em>)</code></p><p>Mivel a <span class="emphasis"><em>θ </em></span>az általánosított Modus Ponensben úgy van definiálva, hogy: <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>,<span class="emphasis"><em> p<sub>i</sub></em></span>′)<span class="emphasis"><em> </em></span>= <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>,<span class="emphasis"><em> p<sub>i</sub></em></span>) minden <span class="emphasis"><em>i</em></span>-re; ebből kifolyólag a két mondatból az első pontosan illeszkedik a másodiknak a premisszájához. Így tehát a <code class="code">HELYETTESÍT</code> (<span class="emphasis"><em>θ</em></span>,<span class="emphasis"><em> q</em></span>)<span class="emphasis"><em> </em></span>következik a Modus Ponensből.</p><p>Az általánosított Modus Ponens egy <span class="strong"><strong>kiemelt</strong></span> (<span class="strong"><strong>lifted</strong></span>) változata a Modus Ponensnek – átemeli a Modus Ponenst az ítéletlogikából az elsőrendű logikába. Látni fogjuk a fejezet későbbi részében, hogy kifejleszthetjük az előrefelé láncolás, a hátrafelé láncolás és a 7. fejezetben bemutatott rezolúciós algoritmusok kiemelt változatait is. A kiemelt következtetési szabályok legfontosabb előnye az ítéletlogikára történő átalakítással szemben az, hogy csak azokat a helyettesítéseket hajtják végre, amelyek bizonyos következtetések végrehajtását teszik lehetővé. Egy potenciális korlát az, hogy egy bizonyos szempontból az Általánosított Modus Ponens kevésbé általános, mint a Modus Ponens (lásd <a class="xref" href="ch07s04.md#ID_265_oldal">„Az ítéletkalkulus következtetési mintái”</a> részben): a Modus Ponens bármely <span class="emphasis"><em>α </em></span> mondatot megenged az implikáció bal oldalán, ezzel szemben az Általánosított Modus Ponens speciális formátumot kíván meg erre a mondatra. Csak abban az értelemben nevezhető általánosítottnak, hogy tetszőleges számú <span class="emphasis"><em>p<sub>i</sub></em></span>′-re alkalmazható.</p></div><div class="section" title="Egyesítés"><div class="titlepage"><div><div><h2 class="title"><a id="id606848"/>Egyesítés</h2></div></div></div><p>A kiemelt következtetési szabályok olyan helyettesítések megtalálását igénylik, amelyek a különböző logikai kifejezéseket látszólag azonossá teszik. Ezt a folyamatot <span class="strong"><strong>egyesítési lépés</strong></span>nek (<span class="strong"><strong>unification</strong></span>) nevezzük, ami kulcsfontosságú eleme minden elsőrendű következtetési algoritmusnak. Az <code class="code">EGYESÍT</code> algoritmus vesz két mondatot, és visszaad egy rájuk vonatkozó <span class="strong"><strong>egyesítés</strong></span>t (<span class="strong"><strong>unifier</strong></span>), ha létezik ilyen: </p><p><code class="code">Egyesít(<em><span class="remark">p</span></em>, <em><span class="remark">q</span></em>) = <em><span class="remark">θ,</span></em> ahol Helyettesít(<em><span class="remark">θ</span></em>, <em><span class="remark">p</span></em>) = Helyettesít(<em><span class="remark">θ</span></em>, <em><span class="remark">q</span></em>)</code></p><p>Nézzünk meg néhány példát arra, hogy az <code class="code">EGYESÍT</code>-nek hogyan kell viselkednie. Tételezzük fel, hogy van egy <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>)<span class="emphasis"><em> </em></span>lekérdezésünk:<span class="emphasis"><em> </em></span>kit ismer János? Erre a kérdésre néhány választ úgy találhatunk, hogy megkeressük az összes mondatot a tudásbázisban, amely egyesíthető az <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>)-szel. Itt vannak az egyesítési eredmények négy különböző, a tudásbázisban előforduló mondatra.</p><p><code class="code">Egyesít(<em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>, <em><span class="remark">x</span></em>), <em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>, <em><span class="remark">Júlia</span></em>)) = {<em><span class="remark">x</span></em>/<em><span class="remark">Júlia</span></em>}</code></p><p><code class="code">Egyesít(<em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>, <em><span class="remark">x</span></em>), <em><span class="remark">Ismer</span></em>(<em><span class="remark">y</span></em>, <em><span class="remark">Lajos</span></em>)) = {<em><span class="remark">x</span></em>/<em><span class="remark">Lajos</span></em>, <em><span class="remark">y/János</span></em>}</code></p><p><code class="code">Egyesít(<em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>, <em><span class="remark">x</span></em>), <em><span class="remark">Ismer</span></em>(<em><span class="remark">y</span></em>, <em><span class="remark">Anyja</span></em>(<em><span class="remark">y</span></em>))) = {<em><span class="remark">y</span></em>/<em><span class="remark">János</span></em>, <em><span class="remark">x</span></em>/<em><span class="remark">Anyja</span></em>(<em><span class="remark">János</span></em>)}</code></p><p><code class="code">Egyesít(<em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>, <em><span class="remark">x</span></em>), <em><span class="remark">Ismer</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">Erzsébet</span></em>)) = <em><span class="remark">sikertelen</span></em></code></p><p>Az utolsó egyesítés sikertelen, mert az <span class="emphasis"><em>x </em></span>nem tudja a <span class="emphasis"><em>János </em></span>és az <span class="emphasis"><em>Erzsébet </em></span>értékeit egyszerre felvenni. Emlékezzünk arra, hogy az <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Erzsébet</em></span>) azt jelenti, hogy: „Mindenki ismeri Erzsébetet”, így képesnek <span class="emphasis"><em>kellene </em></span>lennünk azt kikövetkeztetni, hogy János ismeri Erzsébetet. A probléma abból származik, hogy a két mondat történetesen ugyanazt a változónevet, az <span class="emphasis"><em>x</em></span>-et használja. A problémát úgy kerülhetjük el, hogy az egyesítendő mondatokban <span class="strong"><strong>átnevezzük a változókat</strong></span> (<span class="strong"><strong>standardizing apart</strong></span>) úgy, hogy elkerüljük a nevek egybeeséseit. Például átnevezhetjük az <span class="emphasis"><em>x</em></span>-et az <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Erzsébet</em></span>)-ben például <span class="emphasis"><em>z</em></span><sub>17</sub>-re (egy tetszőleges új változónévre) anélkül, hogy a jelentését megváltoztatnánk. Most már működik az egyesítésünk:</p><p><code class="code">Egyesít(<em><span class="remark">Ismer</span></em>(<em><span class="remark">János</span></em>,<em><span class="remark"> x</span></em>),<em><span class="remark"> Ismer</span></em>(<em><span class="remark">z</span></em><sub>17</sub>,<em><span class="remark"> Erzsébet</span></em>))<em><span class="remark"> </span></em>=<em><span class="remark"> </span></em>{<em><span class="remark">x</span></em>/<em><span class="remark">Erzsébet</span></em>,<em><span class="remark"> z</span></em><sub>17</sub>/<em><span class="remark">János</span></em>}</code></p><p>A 9.7. feladat tovább vizsgálja az átnevezés szükségességének problémáját.</p><div class="figure"><a id="id607199"/><p class="title"><strong>9.1. ábra - Az egyesítési algoritmus. Az algoritmus összehasonlítja a bemenetek felépítését elemről elemre. A <span class="emphasis"><em>θ</em></span> helyettesítés, amely az <code class="code">EGYESÍTÉS</code> argumentuma, útközben épül fel, és arra használjuk, hogy meggyőződjünk arról, hogy a későbbi összehasonlítások konzisztensek lesznek az általunk előzőleg létrehozott lekötésekkel. Egy összetett kifejezésben, mint például az <span class="emphasis"><em>F</em></span>(<span class="emphasis"><em>A</em></span>,<span class="emphasis"><em> B</em></span>), a <code class="code">VÁL</code> függvény kiveszi az <span class="emphasis"><em>F</em></span> függvényszimbólumot, és az <code class="code">ARGOK</code> függvény kiveszi az (<span class="emphasis"><em>A</em></span>,<span class="emphasis"><em> B</em></span>) argumentumlistát.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-01.png" alt="Az egyesítési algoritmus. Az algoritmus összehasonlítja a bemenetek felépítését elemről elemre. A θ helyettesítés, amely az EGYESÍTÉS argumentuma, útközben épül fel, és arra használjuk, hogy meggyőződjünk arról, hogy a későbbi összehasonlítások konzisztensek lesznek az általunk előzőleg létrehozott lekötésekkel. Egy összetett kifejezésben, mint például az F(A, B), a VÁL függvény kiveszi az F függvényszimbólumot, és az ARGOK függvény kiveszi az (A, B) argumentumlistát."/></div></div></div><p>Még egy további nehézségen kell túljutni. Azt mondtuk, hogy az <code class="code">EGYESÍT</code> olyan helyettesítéseket ad vissza, amelyek a két argumentumot látszólag azonossá teszi. Azonban több különböző ilyen egyesítés létezhet. Például az <code class="code">EGYESÍT</code> (<span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>), <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>y</em></span>,<span class="emphasis"><em> z</em></span>))<span class="emphasis"><em> </em></span>visszaadhatja azt is, hogy: {<span class="emphasis"><em>y</em></span>/<span class="emphasis"><em>János, x</em></span>/<span class="emphasis"><em>z</em></span>}, vagy azt is, hogy: {<span class="emphasis"><em>y</em></span>/<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>/<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> z</em></span>/<span class="emphasis"><em>János</em></span>}. Az első egyesítési lépés azt eredményezi, hogy: <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> z</em></span>), ezzel szemben a második azt adja, hogy: <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> János</em></span>)<span class="emphasis"><em>. </em></span>A második eredményt megkaphatjuk az elsőből is egy további helyettesítés hozzáadásával: {<span class="emphasis"><em>z</em></span>/<span class="emphasis"><em>János</em></span>}. Láthatjuk, hogy az első egyesítés <span class="emphasis"><em>általánosabb,</em></span> mint a második, mert kevesebb korlátozást ad meg a változók értékeire. Azt állapíthatjuk meg, hogy minden egyesítendő kifejezéspárra létezik egy <span class="strong"><strong>legáltalánosabb egyesítés</strong></span> (<span class="strong"><strong>most general unifier</strong></span>), amely egyedi a változók átnevezésében. Ebben az esetben ez: {<span class="emphasis"><em>y</em></span>/<span class="emphasis"><em>János</em></span>, <span class="emphasis"><em>x</em></span>/<span class="emphasis"><em>z</em></span>}.</p><p>A legáltalánosabb egyesítések kiszámításához a 9.1. ábrán láthatunk egy algoritmust. Az eljárás igen egyszerű: egy rekurzív algoritmussal egymással párhuzamosan tárjuk fel a két kifejezést, felépítve az egyesítést, kivéve akkor, ha a struktúrákban a két megfelelő elem nem illeszkedik. Van egy drága lépés: amikor egy változót kell egy komplex termhez illesztünk, meg kell vizsgálni, hogy a változó előfordul-e a termben; ha igen, akkor az illesztés sikertelen, mert nem tudunk konzisztens egyesítést megalkotni. Ez a lépés az úgynevezett <span class="strong"><strong>előfordulási próba</strong></span> (<span class="strong"><strong>occur check</strong></span>), amely az algoritmus komplexitását az egyesítendő kifejezés méretével négyzetesen növekvővé teszi. Néhány rendszer, beleértve az összes logikai programozási rendszert, egyszerűen kihagyja az előfordulási próbát, és ennek eredményeként a következtetésük nem helyes. Más rendszerek időben lineáris komplexitású, ennél összetettebb algoritmusokat használnak.</p></div><div class="section" title="Tárolás és visszakeresés"><div class="titlepage"><div><div><h2 class="title"><a id="id607385"/>Tárolás és visszakeresés</h2></div></div></div><p>A <code class="code">KIJELENT</code> és a <code class="code">KÉRDEZ</code> függvények, amelyek szerepe, hogy informálják és lekérdezzék a tudásbázist, két egyszerűbb függvényt, a <code class="code">TÁROL</code> és a <code class="code">BETÖLT</code> függvényeket használják fel. A <code class="code">TÁROL</code> (<span class="emphasis"><em>s</em></span>) eltárol egy <span class="emphasis"><em>s </em></span>mondatot a tudásbázisban, míg a <code class="code">BETÖLT</code> (<span class="emphasis"><em>q</em></span>) visszaadja az összes egyesítést, amelyet a <span class="emphasis"><em>q </em></span>lekérdezés felhasználásával lehet létesíteni a tudásbázis illeszthető mondataival. A probléma, amivel illusztráltuk az egyesítést – az összes olyan tény megtalálása, amely egyesíthető az <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>)-szel – a <code class="code">BETÖLT</code> egyik példája.</p><p>A <code class="code">TÁROL</code> és a <code class="code">BETÖLT</code> megvalósításának legegyszerűbb módja, hogy a tudásbázisban az összes tényt egyetlen hosszú listán tároljuk, és egy <span class="emphasis"><em>q</em></span> lekérdezés megválaszolásakor meghívjuk az <code class="code">EGYESÍT</code> (<span class="emphasis"><em>q</em></span>,<span class="emphasis"><em> s</em></span>)-t minden <span class="emphasis"><em>s</em></span> mondatra a listán. Ez az eljárás nem hatékony, de működik, és egyelőre elég a fejezet további részének megértéséhez. Az alfejezet hátralévő része áttekinti azokat az eljárásokat, amelyekkel a visszakeresést hatékonyabbá tehetjük, így ezt első olvasásra átugorhatjuk.</p><p>A <code class="code">BETÖLT</code> függvényt azzal tehetjük hatékonyabbá, hogy biztosítjuk, hogy az egyesítési lépést csak olyan mondatokkal kíséreljük meg, amelyeknél van egyáltalán<span class="emphasis"><em> </em></span>esély az egyesítésre. Például nincs értelme, hogy megpróbáljuk az egyesítést az <span class="emphasis"><em>Ismer</em></span>(<span class="emphasis"><em>János</em></span>,<span class="emphasis"><em> x</em></span>)-re és a <span class="emphasis"><em>Fivér</em></span>(<span class="emphasis"><em>Richárd</em></span>,<span class="emphasis"><em> János</em></span>)-re. Elkerülhetjük az ilyen egyesítési lépéseket, ha <span class="strong"><strong>indexel</strong></span>jük (<span class="strong"><strong>indexing</strong></span>) a tényeket a tudásbázisban. Egy egyszerű séma, amit <span class="strong"><strong>predikátum i</strong></span><span class="strong"><strong>ndexelés</strong></span>nek (<span class="strong"><strong>predicate indexing</strong></span>) nevezünk, beteszi az összes <span class="emphasis"><em>Ismer </em></span>tényt egy verembe és az összes <span class="emphasis"><em>Fivér </em></span>tényt egy másikba. A vermek egy hash-táblában<sup>[<a id="id607532" href="#ftn.id607532" class="footnote">88</a>]</sup> tárolhatók, hogy hatékonyan elérhessük őket.</p><p>A predikátumok indexelése hasznos, ha sok predikátumszimbólum van, de csak kevés állítás az egyes szimbólumokhoz. Néhány alkalmazásban azonban sok mondat tartozik egy adott predikátumszimbólumhoz. Például tételezzük fel, hogy az adóhatóságok nyomon akarják követni, hogy ki alkalmaz kit, és ezeket a kapcsolatokat egy <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> y</em></span>)<span class="emphasis"><em> </em></span>predikátum használatával írjuk le. Ez egy igen nagy verem lenne, akár munkaadók millióival és alkalmazottak tízmillióival. Egy olyan kérdés megválaszolása, mint az <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> Richárd</em></span>),<span class="emphasis"><em> </em></span>a predikátumok indexelésével az egész verem átböngészését igényelné.</p><p>Egy ilyen lekérdezés esetében segítene, ha a tényeket mind a predikátummal, mind a második argumentummal indexelnénk, például úgy, hogy egy kombinált hash-tábla kulcsot használunk. A kulcsot egyszerűen előállíthatjuk a lekérdezésből, és pontosan visszakereshetjük közvetlenül azokat a tényeket, amelyek egyesíthetők a lekérdezéssel. Más lekérdezésekhez, mint amilyen az <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>AIMA.org</em></span>,<span class="emphasis"><em> y</em></span>),<span class="emphasis"><em> </em></span>szükségünk van arra, hogy a tényeket a predikátum és az első argumentum kombinálásával indexeljük. Így aztán a tényeket tárolhatjuk többszörös indexkulcsok alatt, azonnal hozzáférhetővé téve minden, a ténnyel egyesíthető lekérdezés számára.</p><p>Ha adott egy tárolandó mondat, akkor létre lehet hozni az indexeket az <span class="emphasis"><em>összes lehetséges </em></span>vele egyesíthető lekérdezéshez. Arra a tényre, hogy <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>AIMA.org</em></span>,<span class="emphasis"><em> Richárd</em></span>), ezek a lekérdezések:</p><p><code class="code"><em><span class="remark">Alkalmaz</span></em>(<em><span class="remark">AIMA.org</span></em>,<em><span class="remark"> Richárd</span></em>)<em><span class="remark">	</span></em>Az AIMA.org alkalmazza Richárdot?</code></p><p><code class="code"><em><span class="remark">Alkalmaz</span></em>(<em><span class="remark">x</span></em>,<em><span class="remark"> Richárd</span></em>)<em><span class="remark">		</span></em>Ki alkalmazza Richárdot?</code></p><p><code class="code"><em><span class="remark">Alkalmaz</span></em>(<em><span class="remark">AIMA.org</span></em>,<em><span class="remark"> y</span></em>)<em><span class="remark">		</span></em>Kit alkalmaz az AIMA.org?</code></p><p><code class="code"><em><span class="remark">Alkalmaz</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)<em><span class="remark">			</span></em>Ki alkalmaz kit?</code></p><p>Ezek a lekérdezések egy <span class="strong"><strong>bennfoglalási háló</strong></span>t (<span class="strong"><strong>subsumption lattice</strong></span>) alkotnak, amint az a 9.2. (a) ábrán látható. A hálónak van néhány érdekes tulajdonsága. Például a háló bármely csomópontjának a gyereke a szülőjéből egy egyszerű behelyettesítéssel megkapható, és a „legmagasabb” közös leszármazottja bármely két csomópontnak a legáltalánosabb egyesítőjük használatával érhető el. A háló részeiből bármely alaptény szisztematikusan létrehozható (9.5. feladat). Egy ismétlődő konstansokkal rendelkező mondatnak egy kissé más hálója van, ezt a 9.2. (b) ábrán láthatjuk. A függvényszimbólumok és a változók az eltárolandó mondatokban még érdekesebb hálófelépítéseket tesznek szükségessé.</p><div class="figure"><a id="id607685"/><p class="title"><strong>9.2. ábra - (a) A bennfoglalási háló, amelynek a legalacsonyabb csomópontja ez a mondat: <span class="emphasis"><em>Alkalmaz(AIMA.org</em></span>,<span class="emphasis"><em> Richárd)</em></span>. (b) A bennfoglalási háló arra a mondatra, hogy: <span class="emphasis"><em>Alkalmaz(János</em></span>,<span class="emphasis"><em> János)</em></span>.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/09-02.png" alt="(a) A bennfoglalási háló, amelynek a legalacsonyabb csomópontja ez a mondat: Alkalmaz(AIMA.org, Richárd). (b) A bennfoglalási háló arra a mondatra, hogy: Alkalmaz(János, János)."/></div></div></div><p>A séma, amelyet leírtunk, nagyon jól működik, amikor a háló csak kisszámú csomópontot tartalmaz. Egy <span class="emphasis"><em>n </em></span>argumentumú predikátumra a háló <span class="emphasis"><em>O</em></span>(2<sup>n</sup>)<span class="emphasis"><em> </em></span>csomópontot tartalmaz. Ha a függvényszimbólumok használata megengedett, akkor a csomópontok száma szintén exponenciális a tárolandó mondat termjeinek függvényében. Ez rendkívül nagy számú indexet eredményezhet. Egy ponton az indexelés elveszti előnyeit az összes index tárolásának és fenntartásának problémája miatt. Ez ellen egy rögzített stratégia bevezetésével próbálhatunk védekezni úgy, hogy csak azokon a kulcsokon tartunk fenn indexeket, amelyek predikátumokból és az egyes argumentumokból állnak. Egy másik megoldás, hogy egy adaptív tervet használunk, amely mindig olyan indexeket hoz létre, amelyek megfelelnek az aktuális lekérdezéstípus igényeinek. A legtöbb MI-rendszerben a tárolni kívánt tények száma elég kicsi ahhoz, hogy a hatékony indexelés problémáját megoldottnak tekintsük. Az ipari és kereskedelmi adatbázisok esetében jelentős technikai fejlesztések történtek a feladat megoldására.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id607532" href="#id607532" class="para">88</a>] </sup> A hash-tábla információk tárolására és visszakeresésére szolgáló olyan adatstruktúra, amelyeket rögzített <span class="emphasis"><em>kulcsokkal</em></span> indexelünk. Gyakorlati okokból egy hash-táblát tekinthetünk olyannak, mint amelynek a tárolási és a visszakérdezési ideje állandó, akkor is, ha a tábla nagyon nagy számú elemet tartalmaz.</p></div></div></div></body></html>
