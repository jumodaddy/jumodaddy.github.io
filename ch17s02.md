<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Értékiteráció"><div class="titlepage"><div><div><h1 class="title"><a id="id713767"/>Értékiteráció</h1></div></div></div><p>Ebben az alfejezetben az optimális eljárásmód kiszámítására mutatunk be egy algoritmust, az úgynevezett <span class="strong"><strong>értékiteráció</strong></span>t (<span class="strong"><strong>value iteration</strong></span>). Az alapötlet az, hogy kiszámítjuk minden egyes <span class="emphasis"><em>állapot</em></span> hasznosságát, majd az állapothasznosságokat felhasználjuk az egyes állapotoknál az optimális cselekvés megválasztásához.</p><div class="section" title="Az állapotok hasznossága"><div class="titlepage"><div><div><h2 class="title"><a id="id713786"/>Az állapotok hasznossága</h2></div></div></div><p>Az állapotok hasznosságát az állapotsorozatok hasznosságán keresztül definiáljuk. Nagyjából azt mondhatjuk, hogy egy állapot hasznossága a belőle kiinduló állapotsorozatok várható hasznosságával egyenlő. Nyilvánvalóan az állapotsorozatok függnek a végrehajtott eljárásmódtól, így elsőként egy adott π eljárásmódra definiáljuk a hasznosságot, <span class="emphasis"><em>U</em></span><sup>π</sup>(<span class="emphasis"><em>s</em></span>)-t. Jelöljük <span class="emphasis"><em>s<sub>t</sub></em></span>-vel az ágens állapotát a π<span class="emphasis"><em> </em></span>eljárásmód <span class="emphasis"><em>t</em></span> lépésnyi végrehajtása után, ekkor azt kapjuk, hogy</p><p><span class="inlinemediaobject"><img src="math/mi-17-0006.gif" alt="Az állapotok hasznossága"/></span></p><p>Felhasználva ezt a definíciót, egy állapot valódi hasznossága az <span class="emphasis"><em>U</em></span><sup>π </sup>(<span class="emphasis"><em>s</em></span>), amit <span class="emphasis"><em>U</em></span>(<span class="emphasis"><em>s</em></span>)-sel jelölünk.<span class="emphasis"><em> </em></span>Ez a a leszámítolt jutalmak várható értéke akkor, amikor az ágens egy optimális eljárásmódot hajt végre. Vegyük észre, hogy az <span class="emphasis"><em>U</em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>és az <span class="emphasis"><em>R</em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>igen<span class="emphasis"><em> </em></span>eltérő mennyiségek: az <span class="emphasis"><em>R</em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>a „rövid távú” jutalom az <span class="emphasis"><em>s</em></span>-ben tartózkodásért, míg az <span class="emphasis"><em>U</em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>a „hosszú távú” összjutalom <span class="emphasis"><em>s</em></span>-től kezdve. A 17.3. ábrán láthatók a hasznosságok a 4 × 3-as világban. Látható, hogy a hasznosságok nagyobbak a +1-es kijárathoz közeli állapotoknál, mivel kevesebb lépés szükséges a kijárat eléréséhez.</p><p>Az <span class="emphasis"><em>U</em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>hasznosságfüggvény lehetővé teszi az ágensnek, hogy a cselekvéseit a 16. fejezetben szereplő maximális várható hasznosság elve alapján válassza meg; azt a cselekvést választja, amelyik maximalizálja a bekövetkező állapot várható hasznosságát:</p><p><span class="inlinemediaobject"><img src="math/mi-17-0007.gif" alt="Az állapotok hasznossága"/></span></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Most azonban, ha egy állapot hasznossága a leszámítolt jutalmak várható értékének összege attól a kiindulóponttól kezdve, akkor közvetlen kapcsolat áll fenn egy állapot hasznossága és a szomszédjainak a hasznossága között: <span class="emphasis"><em>egy állapot hasznossága az állapotban tartózkodás közvetlen jutalmának és a következő állapot várható leszámítolt hasznosságának az összege, feltéve, hogy az ágens az optimális cselekvést választja</em></span>. Azaz egy állapot hasznossága a következő:</p><a id="ID_714_oldal"/><p><span class="inlinemediaobject"><img src="math/mi-17-0008.gif" alt="Az állapotok hasznossága"/></span></p></div><div class="figure"><a id="id713941"/><p class="title"><strong>17.2. ábra - Az állapotok hasznosságai a 4 × 3-as világban, <span class="emphasis"><em>γ</em></span> = 1 és a nem végállapotoknál <span class="emphasis"><em>R</em></span>(<span class="emphasis"><em>s</em></span>) = –0,04 esetén</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/17-03.png" alt="Az állapotok hasznosságai a 4 × 3-as világban, γ = 1 és a nem végállapotoknál R(s) = –0,04 esetén"/></div></div></div><p class="Tartalom3">A (17.5) egyenletet <span class="strong"><strong>Bellman-egyenlet</strong></span>nek (<span class="strong"><strong>Bellman equation</strong></span>) nevezik Richard Bellman tiszteletére (Bellman, 1957). Az állapotok hasznosságai – mint a bekövetkező állapotsorozatok várható hasznossága a (17.3) egyenlet szerint – a Bellman-egyenletek egy rendszerének a megoldásai. Valójában ezek egyértelmű megoldások, ahogyan a következő két alfejezetben megmutatjuk. </p><p class="Tartalom3">Nézzük meg a 4 × 3-as világ Bellman-egyenleteinek egyikét. Az (1, 1) állapothoz tartozó egyenlet:</p><p><code class="code"><em><span class="remark">U</span></em>(1, 1) = –0,04 + <em><span class="remark">γ</span></em> max{0,8<em><span class="remark">U</span></em>(1, 2) + 0,1<em><span class="remark">U</span></em>(2, 1) + 0,1<em><span class="remark">U</span></em>(1, 1)	(<em><span class="remark">Fel</span></em>)</code></p><p><code class="code">0,9<em><span class="remark">U</span></em>(1, 1) + 0,1<em><span class="remark">U</span></em>(1, 2)			(<em><span class="remark">Balra</span></em>)</code></p><p><code class="code">0,9<em><span class="remark">U</span></em>(1, 1) + 0,1<em><span class="remark">U</span></em>(2,1)			(<em><span class="remark">Le</span></em>)</code></p><p><code class="code">0,8<em><span class="remark">U</span></em>(2, 1) + 0,1<em><span class="remark">U</span></em>(1, 2) + 0,1<em><span class="remark">U</span></em>(1, 1)}	(<em><span class="remark">Jobbra</span></em>)</code></p><p>A 17.3. ábrán látható számok behelyettesítésével azt láthatjuk, hogy a <span class="emphasis"><em>Fel</em></span> a legjobb cselekvés.</p></div><div class="section" title="Az értékiteráció algoritmus"><div class="titlepage"><div><div><h2 class="title"><a id="id714055"/>Az értékiteráció algoritmus</h2></div></div></div><p>A Bellman-egyenletek képezik az alapját az MDF-ek megoldására szolgáló értékiteráció algoritmusnak. Ha <span class="emphasis"><em>n</em></span> lehetséges állapot van, akkor <span class="emphasis"><em>n</em></span> Bellman-egyenlet létezik, mindegyik állapotra egy. Az <span class="emphasis"><em>n</em></span> egyenlet <span class="emphasis"><em>n</em></span> ismeretlent tartalmaz – az állapotok hasznosságát. Így a hasznosságok megállapításához ezen egyenletek együttesét szeretnénk megoldani. Azonban van egy probléma: az egyenletek nemlineárisak, mivel a „max” operátor nemlineáris operátor. Míg a lineáris egyenletrendszerek hatékonyan megoldhatók lineáris algebrai eszközökkel, a nemlineáris egyenletrendszerek már problematikusabbak. Ekkor iteratív módszerrel próbálkozhatunk. Kezdéskor tetszőleges kezdeti értékeket választunk a hasznosságoknak, kiszámítjuk az egyenletek jobb oldalát, majd behelyettesítjük a bal oldalra – így frissítve az egyes állapotok hasznosságát a szomszédjainak a hasznosságával. Ezt addig ismételjük, ameddig el nem érünk egy egyensúlyi helyzetet. Jelölje <span class="emphasis"><em>U<sub>i</sub></em></span>(<span class="emphasis"><em>s</em></span>)<span class="emphasis"><em> </em></span>az <span class="emphasis"><em>s</em></span> állapot hasznosságértékét az <span class="emphasis"><em>i</em></span>-edik iterációban. A <span class="strong"><strong>Bellman-frissítés</strong></span>nek (<span class="strong"><strong>Bellman update</strong></span>) nevezett iterációs lépés a következőképpen néz ki:</p><p><span class="inlinemediaobject"><img src="math/mi-17-0009.gif" alt="Az értékiteráció algoritmus"/></span></p><p>Ha a Bellman-frissítést végtelen sokszor alkalmazzuk, garantált, hogy egyensúlyi helyzetet érünk el (lásd következő alfejezet), és ekkor a végső hasznosságértékeknek a Bellman-egyenletek megoldását kell adniuk. Valójában ezek <span class="emphasis"><em>egyértelmű</em></span> megoldások is, és a hozzájuk tartozó eljárásmód optimális (amit a (17.4) egyenlettel nyerhetünk). Az algoritmus, amit <code class="code">ÉRTÉKITERÁCIÓ</code>-nak nevezünk, a 17.4. ábrán látható. </p><div class="figure"><a id="id714124"/><p class="title"><strong>17.4. ábra - Az értékiteráció algoritmus az állapotok hasznosságának kiszámítására. A leállási feltétel a (17.8) egyenletből származik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/17-04.png" alt="Az értékiteráció algoritmus az állapotok hasznosságának kiszámítására. A leállási feltétel a (17.8) egyenletből származik."/></div></div></div><div class="figure"><a id="id714134"/><p class="title"><strong>17.5. ábra - (a) A grafikonokon kiválasztott állapotok hasznosságainak a fejlődése látható az értékiteráció felhasználásánál. (b) A szükséges értékiterációk száma (<span class="emphasis"><em>k</em></span>), hogy a hiba garantáltan legfeljebb <span class="emphasis"><em>ε </em></span>=<span class="emphasis"><em> cR</em></span><sub>max</sub> legyen, <span class="emphasis"><em>c</em></span> különböző értékeinél, mint a <span class="emphasis"><em>γ</em></span> leszámítolási tényező függvénye.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/17-05.png" alt="(a) A grafikonokon kiválasztott állapotok hasznosságainak a fejlődése látható az értékiteráció felhasználásánál. (b) A szükséges értékiterációk száma (k), hogy a hiba garantáltan legfeljebb ε = cRmax legyen, c különböző értékeinél, mint a γ leszámítolási tényező függvénye."/></div></div></div><p>Az értékiterációt alkalmazhatjuk a 17.1. (a) ábra 4 × 3-as világára. Nulla kezdeti értékekről indulva, a hasznosságok alakulása a 17.5. (a) ábrán látható. Vegyük észre, ahogy a (4, 3) állapottól különböző távolságra lévő állapotok negatív jutalmakat halmoznak fel egészen addig, amíg egy bizonyos ponton utat találnak a (4, 3)-hoz, amikortól is a hasznosságok elkezdenek növekedni. Az értékiteráció algoritmusára gondolhatunk úgy, mint lokális frissítések általi <span class="emphasis"><em>információterjesztésre</em></span> az állapottérben.</p></div><div class="section" title="Az értékiteráció konvergenciája"><div class="titlepage"><div><div><h2 class="title"><a id="id714170"/>Az értékiteráció konvergenciája</h2></div></div></div><p>Azt állítottuk, hogy az értékiteráció végül a Bellman-egyenletek egy egyértelmű megoldásához konvergál. Ebben az alfejezetben kifejtjük, miért is történik ez. Ennek során bevezetünk néhány hasznos matematikai fogalmat, és olyan módszereket kapunk, amelyek megbecsülik a hasznosságfüggvény hibáját , ha az algoritmust hamar állítottuk le; ennek hasznosságát az adja, hogy nem kell végtelen hosszan futtatnunk az algoritmust. Az alfejezet a technikai részleteket is bemutatja.</p><p>Az értékiteráció konvergenciájának megmutatásában használt alapfogalom az <span class="strong"><strong>összehúzás</strong></span> (<span class="strong"><strong>contraction</strong></span>). Az összehúzás nagyjából egy olyan egyváltozós függvény, ami két különböző bemeneti értékre alkalmazva, két olyan kimeneti értéket ad, amelyek „egymáshoz közelebbiek”, mint az eredeti értékek, legalább egy bizonyos állandó mennyiséggel. Például a „kettővel való osztás” egy összehúzás, mivel bármely két szám elosztása után a különbségük megfeleződik. Vegyük észre, hogy a „kettővel való osztásnak” van egy fix pontja, nevezetesen a nulla, ami a függvény alkalmazásával nem változik. Ebből a példából az összehúzás két fontos tulajdonságát vehetjük észre:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Egy összehúzásnak egyetlen fix pontja van: ha két fix pontja lenne, nem kerülnének egymáshoz közel a függvény alkalmazásakor, így nem is volna összehúzás.</p></li><li class="listitem"><p>A függvény tetszőleges argumentumra történő alkalmazásakor a függvényértéknek közelebb kell kerülniük a fix ponthoz (mivel a fix pont nem mozdul el), így egy öszszehúzás ismételt alkalmazása a fix pontot adja határértékben.</p></li></ul></div><p>Most tegyük fel, hogy a Bellman-frissítést (a (17.6) egyenletet) egy <span class="emphasis"><em>B</em></span> operátornak tekintjük, aminek egyszeri alkalmazása az összes állapot hasznosságát frissíti. Jelölje <span class="emphasis"><em>U<sub>i</sub></em></span> az összes állapot <span class="emphasis"><em>i</em></span>-edik iterációbeli hasznosságának a vektorát. Ekkor a Bellman-frissítési egyenletet felírhatjuk úgy, hogy</p><p><code class="code"><em><span class="remark">U<sub>i</sub></span></em><sub>+1</sub> ← <em><span class="remark">BU<sub>i</sub></span></em></code></p><p>Most egy olyan módszerre van szükségünk, amellyel a hasznosságvektorok távolságát mérhetjük. A <span class="strong"><strong>maximum normá</strong></span>t (<span class="strong"><strong>max norm</strong></span>) fogjuk használni, ami egy vektor hoszszát a legnagyobb komponensének hosszával méri:</p><p class="Tartalom3"><span class="inlinemediaobject"><img src="math/mi-17-0010.gif" alt="Az értékiteráció konvergenciája"/></span></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Ezzel a definícióval, a két vektor közötti „távolság” ||<span class="emphasis"><em>U</em></span> – <span class="emphasis"><em>U</em></span>′|| az összetartozó elemek közötti különbségek maximuma. Az alfejezet fő eredménye a következő: <span class="emphasis"><em>Legyen</em></span> <span class="emphasis"><em>U<sub>i</sub></em></span> <span class="emphasis"><em>és két tetszőleges hasznosságvektor.</em></span> <span class="emphasis"><em>Ekkor</em></span></p><p><code class="code">||<em><span class="remark">BU<sub>i</sub> – BU<sub>i</sub></span></em>′|| ≤ <em><span class="remark">γ</span></em>||<em><span class="remark">U<sub>i </sub>– U<sub>i</sub></span></em>′||					(17.7)</code></p><p><span class="emphasis"><em>Azaz, a Bellman-frissítés egy összehúzás egy γ tényezővel a hasznosságvektorok terében. </em></span>Így az értékiteráció mindig a Bellman-egyenletek egy egyértelmű megoldásához konvergál.</p></div><p>Nevezetesen, a (17.7) egyenletben lecserélhetjük <span class="emphasis"><em>U<sub>i</sub></em></span>′ -t a valódi <span class="emphasis"><em>U</em></span> hasznosságokkal, amire <span class="emphasis"><em>BU</em></span> = <span class="emphasis"><em>U</em></span>. Ekkor a következő egyenlőtlenséget kapjuk</p><p><code class="code">||<em><span class="remark">BU<sub>i </sub>– U</span></em>|| ≤ <em><span class="remark">γ</span></em>||<em><span class="remark">U<sub>i </sub>– U</span></em>||</code></p><p>Ezért, ha ||<span class="emphasis"><em>U<sub>i </sub>– U</em></span>||-ra mint az <span class="emphasis"><em>U<sub>i</sub></em></span> becslés <span class="emphasis"><em>hibájára</em></span> tekintünk, látjuk, hogy a hiba minden iterációban legalább egy <span class="emphasis"><em>γ</em></span> tényezővel csökken. Ez azt jelenti, hogy az értékiteráció exponenciálisan gyorsan konvergál. A szükséges iterációk számát egy adott <span class="emphasis"><em>e</em></span> hibahatár eléréséhez a következőképpen számíthatjuk ki: először, a (17.1) egyenlet<span class="emphasis"><em> </em></span>szerint, az összes állapot hasznossága korlátos ±<span class="emphasis"><em>R</em></span><sub>max</sub>/(1<span class="emphasis"><em> – γ</em></span>) értékkel. Ez azt jelenti, hogy a maximális kezdeti hiba ||<span class="emphasis"><em>U</em></span><sub>0</sub> – <span class="emphasis"><em>U</em></span>|| ≤ 2<span class="emphasis"><em>R</em></span><sub>max</sub>/(1 – <span class="emphasis"><em>γ</em></span>)<span class="emphasis"><em>.</em></span> Tegyük fel, hogy <span class="emphasis"><em>N</em></span> iterációt végzünk ahhoz, hogy a hiba legfeljebb <span class="emphasis"><em>ε</em></span> értékű legyen. Mivel a hiba minden egyes alkalommal legalább <span class="emphasis"><em>γ</em></span> -szorosára csökken, annak kell teljesülnie, hogy <span class="emphasis"><em>γ<sup>N</sup> </em></span>2 <span class="emphasis"><em>R</em></span><sub>max</sub>/(1 – <span class="emphasis"><em>γ</em></span>) ≤ <span class="emphasis"><em>ε. </em></span>Ha vesszük a két oldal logaritmusát, az adódik, hogy</p><p><span class="inlinemediaobject"><img src="math/mi-17-0011.gif" alt="Az értékiteráció konvergenciája"/></span></p><p>számú iteráció elegendő. A 17.5. (b) ábrán látható, hogyan változik <span class="emphasis"><em>γ </em></span>függvényében az <span class="emphasis"><em>N</em></span> különböző értékű <span class="emphasis"><em>ε</em></span>/<span class="emphasis"><em>R</em></span><sub>max<span class="emphasis"><em> </em></span></sub>hányadosok esetében. A jó hír az, hogy az exponenciális gyorsaságú konvergencia miatt <span class="emphasis"><em>N</em></span> nem függ túlságosan az <span class="emphasis"><em>ε</em></span>/<span class="emphasis"><em>R</em></span><sub>max<span class="emphasis"><em> </em></span></sub>hányadostól. A rossz hír az, hogy <span class="emphasis"><em>N</em></span> gyorsan nő, ahogy <span class="emphasis"><em>γ </em></span>közel kerül 1-hez. Így gyors konvergenciát úgy érhetünk el, ha <span class="emphasis"><em>γ -</em></span>t kicsivé tesszük, de ez valójában az ágensnek rövid távú horizontot biztosít, és az ágens cselekvéseinek hosszú távú hatásait figyelmen kívül hagyhatja. </p><p>Az előző bekezdés hibakorlátja ad bizonyos tájékozódást az algoritmus futási idejét befolyásoló tényezőkről, de gyakran túlságosan óvatos módszert jelent annak eldöntésére, hogy mikor álljon le az iteráció. Az utóbbi célra felhasználhatunk egy korlátot, ami a hibát az egyes iterációkban a Bellman-frissítés nagyságához kapcsolja. Az összehúzási tulajdonságból ((17.7) egyenlet) meg lehet mutatni, hogy ha a frissítés kicsi (azaz egyetlen állapot hasznossága sem változik nagyon), akkor a hiba a valódi hasznosságfüggvényhez képest szintén kicsi. Pontosabban,</p><p><code class="code">ha      ||<em><span class="remark">U</span></em><sub><em><span class="remark">i</span></em>+1</sub> – <em><span class="remark">U<sub>i</sub></span></em>|| &lt; <em><span class="remark">ε</span></em>(1 – <em><span class="remark">γ</span></em>)/<em><span class="remark"> γ</span></em>,     akkor     ||<em><span class="remark">U</span></em><sub><em><span class="remark">i+</span></em>1</sub> – <em><span class="remark">U</span></em>|| &lt; <em><span class="remark">ε 	</span></em>(17.8)</code></p><p>Ez a leállási feltétel szerepel az <code class="code">ÉRTÉKITERÁCIÓ</code> algoritmusában a 17.4. ábrán.</p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>Eddig az értékiteráció algoritmusa által visszaadott hasznosságfüggvény hibáját elemeztük<span class="emphasis"><em>. Az ágenst azonban igazán az érdekli, hogyan fog boldogulni, ha egy ilyen döntésfüggvény alapján hoz döntéseket. </em></span>Tegyük fel, hogy az értékiteráció <span class="emphasis"><em>i</em></span>-edik iterációja után az ágens a valódi <span class="emphasis"><em>U</em></span> hasznosságra egy <span class="emphasis"><em>U<sub>i</sub></em></span> becslést kap, és az <span class="emphasis"><em>U<sub>i</sub></em></span>-n alapuló egylépéses előrenézés felhasználásával (ahogy a (17.4) egyenletben) megkapja a <span class="emphasis"><em>π</em></span><sub> <span class="emphasis"><em>i </em></span></sub>MVH-eljárásmódot. Vajon a kiadódó viselkedés megközelítőleg lesz-e olyan jó, mint az optimális viselkedés? Ez döntő kérdés minden valós ágens számára, és bizonyítható, hogy a válasz igen. Jelölje <span class="inlinemediaobject"><img src="math/mi-17-0012.gif" alt="Az értékiteráció konvergenciája"/></span> azt a hasznosságot, ami a <span class="emphasis"><em>π<sub> i</sub></em></span> végrehajtásakor adódik <span class="emphasis"><em>s</em></span>-ből kiindulva. Ekkor az<span class="emphasis"><em> </em></span><span class="inlinemediaobject"><img src="math/mi-17-0013.gif" alt="Az értékiteráció konvergenciája"/></span> az<span class="emphasis"><em> </em></span><span class="strong"><strong>eljárásmód vesztesége</strong></span> (<span class="strong"><strong>policy loss</strong></span>) annak a maximális értéke, amit az ágens veszíthet <span class="emphasis"><em>π<sub> i</sub></em></span>-t végrehajtva az optimális <span class="emphasis"><em>π</em></span><sup> *</sup> eljárásmód helyett. A <span class="emphasis"><em>π<sub> i</sub></em></span> eljárásmód veszteségét az <span class="emphasis"><em>U<sub>i</sub></em></span>-beli hibához a következő egyenlőtlenség kapcsolja:</p><p><span class="inlinemediaobject"><img src="math/mi-17-0014.gif" alt="Az értékiteráció konvergenciája"/></span></p><p>A gyakorlatban sokszor előfordul, hogy <span class="emphasis"><em>π<sub> i</sub></em></span> jóval hamarabb optimálissá válik, mielőtt <span class="emphasis"><em>U<sub>i</sub></em></span> konvergált volna. A 17.6. ábrán látható, ahogy a 4 × 3-as környezetben a maximális <span class="emphasis"><em>U<sub>i</sub></em></span>-beli hiba és az eljárásmód vesztesége az értékiteráció folyamatának előrehaladtával nullához közelít, <span class="emphasis"><em>γ</em></span> = 0,9 értéknél. A <span class="emphasis"><em>π<sub> i</sub></em></span> eljárásmód már <span class="emphasis"><em>i</em></span> = 4-nél optimális, pedig az <span class="emphasis"><em>U<sub>i</sub></em></span>-beli maximális hiba még 0,46.</p></div><div class="figure"><a id="id714704"/><p class="title"><strong>17.6. ábra - A hasznosságbecslés maximális hibája ||<span class="emphasis"><em>U<sub>i</sub></em></span> – <span class="emphasis"><em>U</em></span>|| és az eljárásmód vesztesége <span class="inlinemediaobject"><img src="math/mi-17-0015.gif" alt="A hasznosságbecslés maximális hibája ||Ui – U|| és az eljárásmód vesztesége az optimális eljárásmódhoz viszonyítva az értékiteráció iterációszámának függvényében"/></span> az optimális eljárásmódhoz viszonyítva az értékiteráció iterációszámának függvényében</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/17-06.png" alt="A hasznosságbecslés maximális hibája ||Ui – U|| és az eljárásmód vesztesége az optimális eljárásmódhoz viszonyítva az értékiteráció iterációszámának függvényében"/></div></div></div><p class="Tartalom3">Most már minden rendelkezésünkre áll, hogy az értékiterációt a gyakorlatban is felhasználjuk. Tudjuk, hogy a helyes hasznosságokhoz konvergál, a hasznosság becslésének hibájára korlátokat tudunk adni, ha véges számú iteráció után leállunk, és korlátokat tudunk adni az eljárásmód veszteségére, ami a becsült hasznosságértékekhez tartozó MVH-eljárásmód végrehajtása miatt lép fel. A végső megjegyzés, hogy az összes eredmény feltétele ebben az alfejezetben a <span class="emphasis"><em>γ </em></span>&lt; 1-gyel való leszámítolás. Ha <span class="emphasis"><em>γ </em></span>= 1 és a környezet tartalmaz végállapotokat, akkor bizonyos technikai feltételek teljesülése esetén konvergenciaeredmények és hibakorlátok hasonló halmaza származtatható.</p></div></div></body></html>
