<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id566071"/>Összefoglalás</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="strong"><strong>kényszerkielégítési problémá</strong></span>k (<span class="strong"><strong>CSP</strong></span>-k) változókból állnak, melyekre kényszerek vonatkoznak. Nagyon sok fontos valósvilág-beli probléma írható le kényszerkielégítési problémaként. A kényszerkielégítési problémák struktúrája egy kényszergráffal reprezentálható.</p></li><li class="listitem"><p>A <span class="strong"><strong>visszalépéses keresés</strong></span> (<span class="strong"><strong>backtracking search</strong></span>), a mélységi keresés egyik formája, a kényszerkielégítési problémák megoldásának gyakran alkalmazott eszköze.</p></li><li class="listitem"><p>A <span class="strong"><strong>legkevesebb fennmaradó érték</strong></span> (<span class="strong"><strong>least-remaining value</strong></span>) <span class="strong"><strong>heurisztika</strong></span> és a <span class="strong"><strong>fokszám</strong></span>- (<span class="strong"><strong>degree</strong></span>-) <span class="strong"><strong>heurisztika</strong></span> tárgyterület-független módszerek annak eldöntésére, hogy a visszalépéses keresés során melyik változót válasszuk ki következőnek. A <span class="strong"><strong>legkevésbé korlátozó érték</strong></span> (<span class="strong"><strong>least-constraining value</strong></span>) <span class="strong"><strong>heurisztika</strong></span> segítségül szolgálhat a változóértékek sorrendezésében.</p></li><li class="listitem"><p>A visszalépéses algoritmus nagyban csökkenteni tudja a probléma elágazási tényezőjét a létrehozott részleges hozzárendelések következményeinek terjesztésével. Erre a legegyszerűbb módszer az <span class="strong"><strong>előrenéző ellenőrzés</strong></span> (<span class="strong"><strong>forward checking</strong></span>). Az <span class="strong"><strong>élkonzisztencia</strong></span> (<span class="strong"><strong>arc consistency</strong></span>) kikényszerítés egy jóval nagyobb teljesítőképességű technika, de tovább is tart a futása.</p></li><li class="listitem"><p>Visszalépésre akkor kerül sor, amikor egy változóhoz már nem találunk hozzárendelhető értéket. A <span class="strong"><strong>konfliktusvezérelt visszaugrás</strong></span> (<span class="strong"><strong>conflict-directed backjumping</strong></span>) közvetlenül a probléma okához ugrik vissza. A <span class="strong"><strong>min-konfliktusok</strong></span> (<span class="strong"><strong>min-conflicts</strong></span>) heurisztikát használó lokális keresést komoly sikerrel alkalmazták a kényszerkielégítési problémákra.</p></li><li class="listitem"><p>A kényszerkielégítési probléma komplexitása szorosan kötődik a saját kényszergráfjának struktúrájához. A fastruktúrájú problémák megoldhatók lineáris időben. A <span class="strong"><strong>vágóhalmaz-kondicionálás</strong></span> (<span class="strong"><strong>cutset conditioning</strong></span>) az eredeti kényszerkielégítési problémát fastruktúrájúvá alakíthatja, és nagyon hatékonynak bizonyul, ha sikerül kis vágóhalmazt találnunk. A <span class="strong"><strong>fadekompozíció</strong></span> (<span class="strong"><strong>tree decomposition</strong></span>) technikák a kényszerkielégítési problémát részproblémák fájává alakíthatják, és hatékonyak, ha a kényszergráf <span class="strong"><strong>faszélesség</strong></span>e (<span class="strong"><strong>tree width</strong></span>) kicsi.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id566232"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>A kényszerkielégítéssel kapcsolatos legkorábbi munka a numerikus kényszerekhez kötődik. Az egész értékű egyenlőségi kényszereket Brahmagupta indiai matematikus tanulmányozta a 7. században. Ezeket gyakran <span class="strong"><strong>diofantoszi egyenlet</strong></span>eknek<span class="emphasis"><em> </em></span>is nevezik Diofantosz görög matematikus (kb. 200–284) nyomán, aki valójában a pozitív racionális számok esetét vizsgálta. A lineáris egyenlőségek változókiküszöböléssel történő megoldásának szisztematikus módszereit Gauss tanulmányozta (Gauss, 1829), a lineáris egyenlőtlenség alakú kényszerek megoldása Fourier-ig vezethető vissza (Fourier, 1827).</p><p>A véges tartományú kényszerkielégítési problémáknak hosszú történetük van. A <span class="strong"><strong>gráfszínezés</strong></span> például (amelynek a térképszínezés csak egy speciális esete) a matematika régi problémáinak egyike. Biggs és társai (Biggs és társai, 1986) szerint a négyszín-sejtést (minden síkbeli gráf kiszínezhető legfeljebb négy színnel) először Francis Guthrie, de Morgan egyik tanítványa fogalmazta meg 1852-ben. A feladat ellenállt a megoldási kísérleteknek – annak ellenére, hogy néhányan publikációkban az ellenkezőjét állították –, mígnem Appel és Haken (Appel és Haken, 1977) előállt egy számítógépre is támaszkodó bizonyítással.</p><p>A kényszerkielégítési problémák egyes osztályai gyakran felmerültek a számítógép-tudomány történetében. Az egyik legkorábbi nagy hatású példa a <code class="code">SKETCHPAD</code> rendszer volt (Sutherland, 1963), amely geometriai kényszereket oldott meg diagramokban, és a modern rajzolóprogramok és CAD-programok előfutárának tekinthető. A kényszerkielégítési problémák <span class="emphasis"><em>általános problémaosztályként</em></span> történő azonosítása Ugo Montanari (Montanari, 1974) nevéhez fűződik. A magasabb rendű kényszerkielégítési problémák visszavezetése segédváltozók felvételével tisztán bináris esetre (lásd 5.11. feladat) eredetileg a 19. századi logikushoz, Charles Sanders Peirce-hez fűződik. A CSP-irodalomba Dechter (Dechter, 1990b) vezette be, majd Bacchus és Van Beek (Bacchus és van Beek, 1998) dolgozták ki. A megoldásokra vonatkozó preferenciákkal kiegészített kényszerkielégítési problémákat széles körben tanulmányozza az optimalizáció irodalma; lásd (Bistarelli és társai, 1997)-et a CSP-keretrendszer preferenciákat is megengedő általánosításáról. A vödör-eliminációs algoritmus (Dechter, 1999) szintén alkalmazható az optimalizációs problémákra.</p><p>A kényszerkielégítési problémák visszalépéses keresése Bitnertől és Reingoldtól (Bitner és Reingold, 1975) származik, noha ők az alapalgoritmust a 19. századig követik vissza. Bitner és Reingold az MRV-heurisztikát is bevezették (ők ezt <span class="emphasis"><em>leginkább-korlátozott-érték</em></span> heurisztikának nevezték). Az MRV-heurisztika utáni eldöntetlen helyzetek megoldására Brelaz (Brelaz, 1979) a fokszám-heurisztikát alkalmazta. Az így létrejövő algoritmus, minden egyszerűsége ellenére, máig a leghatékonyabb tetszőleges gráfok <span class="emphasis"><em>k</em></span>-színezésére. A <span class="emphasis"><em>legkevésbé-korlátozó-érték </em></span>heurisztikát Haralick és Elliot javasolták (Haralick és Elliot, 1980).</p><p>A kényszerterjesztési módszereket Waltz (Waltz, 1975) sikere tette népszerűvé, amelyet a számítógépes látásnál felmerülő poliéder-élcímkézési problémán ért el. Waltz megmutatta, hogy sok probléma esetén a kényszerterjesztés teljesen kiküszöböli a visszalépést. Montanari (Montanari, 1974) bevezette a kényszerhálózat és az útvonalkonzisztencia-terjesztés fogalmát. Alan Mackworth (Mackworth, 1977) javasolta az AC-3 algoritmust az élkonzisztencia betartatására, csakúgy, mint annak általános lehetőségét, hogy valamilyen fokú konziszentencia-ellenőrzést építsünk be a visszalépéses algoritmusba. Az AC-4, egy jóval hatékonyabb algoritmus, melyet Mohr és Henderson fejlesztettek ki (Mohr és Henderson, 1984). Nem sokkal Mackworth cikkének megjelenése után a kutatók elkezdtek kísérletezni a konzisztencia-ellenőrzések költsége és a kereséslevágásban jelentkező előny csereviszonyának feltérképezésével. Haralick és Elliot (Haralick és Elliot, 1980) a McGregor által leírt (McGregor, 1979) minimális előrenéző ellenőrzés mellett álltak ki, míg Gaschnig (Gaschnig, 1979) minden egyes változó-hozzárendelés után élkonzisztencia-ellenőrzéseket javasolt (ezt az algoritmust nevezte később Sabin és Freuder (Sabin és Freuder, 1994) MAC-nak). Az utóbbi cikk valamennyire meggyőző bizonyítékot hoz fel amellett, hogy nehezebb problémáknál kifizetődik a teljes élkonzisztencia-ellenőrzés. Freuder (Freuder 1978, 1982) megvizsgálta a <span class="emphasis"><em>k</em></span>-konzisztenciát és ennek kapcsolatát a kényszerkielégítési problémák megoldásának komplexitásával. Apt (Apt, 1999) egy általános algoritmikus keretrendszert mutat be a konzisztenciaterjesztési algoritmusok vizsgálatára.</p><p>A magasabb rendű kényszerek kezelésének külön módszerei elsősorban a <span class="strong"><strong>kényszerlogikai-programozás</strong></span> (<span class="strong"><strong>constraint logic programming</strong></span>) keretein belül alakultak ki. Marriott és Stuckey (Marriott és Stuckey, 1998) nagyszerű összefoglalást nyújt erről a kutatási területről. A <span class="emphasis"><em>MindKül</em></span> kényszert Regin (Regin, 1994) tanulmányozta. Az alsó és felső határokból álló kényszereket Van Hentenryck és társai vezették be a kényszerlogikai programozásba (Van Hentenryck és társai,1998).</p><p>Az alapvető visszaugró módszer John Gaschnigtől (Gaschnig, 1977; 1979) származik. Kondrak és van Beek (Kondrak és Van Beek, 1997) megmutatták, hogy ezt az algoritmust lényegében magában foglalja az előrenéző ellenőrzés. A konfliktusvezérelt visszaugrást Prosser (Prosser, 1993) alakította ki. Az intelligens visszalépés legáltalánosabb és legerősebb formáját tulajdonképpen már nagyon korán kifejlesztette Stallman és Sussman (Stallman és Sussman, 1977). Technikájuk, a <span class="strong"><strong>függőségvezérelt visszalépés</strong></span> (<span class="strong"><strong>dependen</strong></span><span class="strong"><strong>cy-directed backtracking</strong></span>) az <span class="strong"><strong>igazság-karbantartó rendszer</strong></span>ek (<span class="strong"><strong>truth maintenance </strong></span><span class="strong"><strong>system</strong></span>s) kifejlesztéséhez vezetett (Doyle, 1979), amelyekkel a 10.8. alfejezetben foglalkozunk. A két terület közti kapcsolatot De Kleer (De Kleer, 1989) vizsgálta.</p><p>Stallman és Sussman munkája a <span class="strong"><strong>kényszerfeljegyzés</strong></span> (<span class="strong"><strong>constraint recording</strong></span>) elképzelését is bevezette: a keresés által elért részleges eredményeket elmentjük és a keresés során később felhasználjuk. Ezt az elképzelést a visszalépéses keresésbe formális módon Dechter (Dechter, 1990a) vezette be. A <span class="strong"><strong>visszajegyzés</strong></span> (<span class="strong"><strong>backmarking</strong></span>) (Gaschnig, 1979) egy különlegesen egyszerű módszer, amelyben a konzisztens és inkonzisztens páronkénti hozzárendeléseket elmentjük, hogy elkerüljük a kényszerek későbbi újraellenőrzését. A visszajegyzés ötvözhető a konfliktusvezérelt visszaugrással; Kondrak és Van Beek (Kondrak és Van Beek, 1997) bemutatnak egy hibrid algoritmust, amely bizonyíthatóan tartalmazza mindkét külön módszert. A <span class="strong"><strong>dinamikus visszalépés</strong></span> (<span class="strong"><strong>dynamic backtracking</strong></span>) (Ginsberg, 1993) megőrzi a változók későbbi részhalmazaiból származó sikeres parciális hozzárendeléseket, amikor egy olyan korábbi választási pontra ugrik vissza, amely a későbbi sikert nem teszi érvénytelenné.</p><p>A kényszerkielégítési problémák lokális keresését Kirkpatrick és társai (Kirkpatrick és társai, 1983) <span class="strong"><strong>szimulált lehűtés</strong></span>ről (<span class="strong"><strong>simulated annealing</strong></span>) (lásd 4. fejezet) szóló munkája tette népszerűvé, és ezt széles körben alkalmazták az ütemezési problémáknál. A <span class="emphasis"><em>min-konfliktusok </em></span>heurisztikát először Gu (Gu, 1989) javasolta, és tőle függetlenül Minton és társai (Minton és társai, 1992) is kifejlesztették. Sosic és Gu (Sosic és Gu, 1994) megmutatta, hogyan lehet ennek a heurisztikának az alkalmazásával a 3 000 000-királynő problémát kevesebb, mint egy perc alatt megoldani. A bámulatos siker, amit a min-konfliktusokat használó lokális keresés ért el az <span class="emphasis"><em>n</em></span>-királynő problémában, a „könnyű” és a „nehéz” problémák természetének és elterjedtségének újraértékeléséhez vezetett. Peter Cheesman és társai (Cheesman és társai,<span class="emphasis"><em> </em></span>1991) feltérképezték a véletlenszerűen generált kényszerkielégítési problémák nehézségét, és azt találták, hogy majdnem minden ilyen probléma vagy triviálisan könnyű, vagy megoldhatatlan. Csak akkor találunk „nehéz” probléma példányokat, ha a problémagenerátor paramétereit egy bizonyos szűk tartományba állítjuk be, melyen belül a problémák közelítőleg fele megoldható. Ezzel a jelenséggel a 7. fejezetben foglalkozunk részletesebben.</p><p>A kényszerkielégítési problémák struktúrájának és nehézségének kapcsolatával foglalkozó kutatást Freuder (Freuder, 1985) indította el, aki megmutatta, hogy az élkonzisztens fák esetében a keresés visszalépések nélkül fut le. Egy hasonló eredmény az aciklikus hipergráfokra való kiterjesztésével együtt jött létre az adatbázisokkal foglalkozó kutatói közösségben (Beeri és társai, 1983). Ezen cikkek publikálása óta komoly haladás történt a kényszergráf struktúrája és a kényszerkielégítési probléma megoldási komplexitásának kapcsolatát illetően. A faszélesség fogalmát a gráfelmélettel foglalkozó Robertson és Seymour (Robertson és Seymour, 1986) vezették be. Freuder munkásságára építve Dechter és Pearl (Dechter és Pearl, 1987, 1989) ugyanezt a fogalmat – amit ők <span class="strong"><strong>indukált szélesség</strong></span>nek (<span class="strong"><strong>induced width</strong></span>) hívtak – alkalmazták a kényszerkielégítési problémákra és kifejlesztették az 5.4. alfejezetben felvázolt fadekompozíciót. Az adatbázis-elméletre és erre az eredményre alapozva Gottlob és társai (Gottlob és társai, 1999a, 1999b) kialakították a kényszerkielégítési probléma hipergráfként történő felfogásán alapuló <span class="strong"><strong>hiperfaszélesség</strong></span> (<span class="strong"><strong>hypertree width</strong></span>) fogalmat. Annak megmutatásán túl, hogy minden <span class="emphasis"><em>w</em></span> szélességű hiperfa-CSP megoldható <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n<sup>w+1</sup></em></span>log<span class="emphasis"><em>n</em></span>) időben, azt is bebizonyították, hogy a hiperfaszélesség az összes korábbi „szélesség”-mértéket magában foglalja (abban az értelemben, hogy bizonyos esetekben a hiperfaszélesség korlátozott, bizonyos esetekben pedig nem).</p><p>Sok jó áttekintés létezik a CSP-technikákhoz, például Kumar (Kumar, 1992), Dechter és Frost (Dechter és Frost, 1999) és Bartak (Bartak, 2001); továbbá a Dechter-től (Dechter, 1992) és Mackworthtől (Mackworth, 1992) származó enciklopédiacikkek. Pearson és Jeavons (Pearson és Jeavons, 1997) a könnyen kezelhető CSP-osztályokat veszik számba, beleértve mind a strukturális dekompozíciós módszereket, mind a maguknak a tartományoknak vagy a kényszereknek a tulajdonságaira támaszkodó módszereket. Kondrak és Van Beek (Kondrak és Van Beek, 1997) a visszalépéses keresési algoritmusok analitikus áttekintését adják, Bacchus és Van Run (Bacchus és Van Run, 1998) pedig empirikusabb képet festenek. Tsang (Tsang, 1993), valamint Marriott és Stuckey (Marriott és Stuckey, 1998) szövegei jóval mélyebbre hatolnak a témában, mint azt a fejezet korlátai számunkra lehetővé tették. Sok érdekes alkalmazást mutat be a Freuder és Mackworth szerkesztésében megjelent gyűjtemény (Freuder és Mackworth, 1994). Kényszerkielégítéssel foglalkozó cikkek rendszeresen jelennek meg az <span class="emphasis"><em>Artificial Intelligence</em></span>-ben és egy specialistáknak szóló újságban, a <span class="emphasis"><em>Constraints</em></span>ben. A legfőbb konferenciakiadvány az International Conference on Principles and Practice of Constraint Programming, amit gyakran <span class="emphasis"><em>CP</em></span>-nek hívnak.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id566436"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>5.1.</strong></span></p><p>Fogalmazza meg a saját szavaival a kényszerkielégítési problémák, a kényszerek, a visszalépéses keresés, az élkonzisztencia, a visszaugrás és a min-konfliktusok definícióját.</p><p><span class="strong"><strong>5.2.</strong></span></p><p>Hány megoldása van az 5.1. ábra térképszínezési problémájának?</p><p><span class="strong"><strong>5.3.</strong></span></p><p>Magyarázza el, miért jó heurisztika a <span class="emphasis"><em>leginkább</em></span> korlátozott változót és a <span class="emphasis"><em>legkevésbé</em></span> korlátozott értéket választani a kényszerkielégítési probléma megoldásának keresése közben.</p><p><span class="strong"><strong>5.4.</strong></span></p><p>Tekintsük a keresztrejtvények készítésének (nem megoldásának) problémáját:<sup>[<a id="id566477" href="#ftn.id566477" class="footnote">52</a>]</sup> szavakat kell illeszteni egy négyszögletes rácsba. A rács, amely része a probléma specifikációjának, megadja, hogy mely négyzetek legyenek üresek és melyek sötétek. Tegyük fel, hogy adott a szavak egy listája (például egy szótár), és az a feladat, hogy az üres négyzeteket a lista tetszőleges részhalmazát használva kitöltsük. Fogalmazza meg pontosan ezt a problémát kétféle módon:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Mint általános keresési problémát. Válasszon egy megfelelő keresési algoritmust, és specifikálja a heurisztikus függvényt (amennyiben elképzelése szerint szüksége van rá). A fehér kockákba egyszerre egy betűt vagy egész szavakat érdemes-e beírni?</p></li><li class="listitem"><p>Mint kényszerkielégítési problémát. A változók betűk vagy szavak legyenek? Melyik megfogalmazást tartja jobbnak? Miért?</p></li></ol></div><p><span class="strong"><strong>5.5.</strong></span></p><p>Adjon precíz megfogalmazást az alábbiakra mint kényszerkielégítési problémákra:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Négyszögletes kirakó</strong></span>: találjon nemátfedő helyeket egy nagy négyszögben kisebb négyszögek számára.</p></li><li class="listitem"><p><span class="strong"><strong>Órarend-ütemezés</strong></span>: adott számú professzor és terem van, valamint rögzített az órarendi órák listája is a lehetséges időablakokkal együtt. Mindegyik professzorhoz adott az általa tartott órák halmaza.</p></li></ol></div><p><span class="strong"><strong>5.6.</strong></span></p><p>Oldja meg az 5.2. ábra betűrejtvényét kézzel, visszalépéses kereséssel, előrenéző ellenőrzéssel, valamint az MRV-, illetve a legkevésbé korlátozó érték heurisztikával.</p><p><span class="strong"><strong>5.7.</strong></span></p><div class="informalexample"><p>Az 5.5. ábra a különböző algoritmusokat az <span class="emphasis"><em>n</em></span>-királynő problémán teszteli. Próbálja meg ugyanezt egy véletlenszerűen generált térképszínezési problémával is: osszon el az egységsíkon véletlenszerűen <span class="emphasis"><em>n</em></span> pontot, válasszon ki véletlenszerűen egy <span class="emphasis"><em>X</em></span> pontot, kösse <span class="emphasis"><em>X</em></span>-et a legközelebbi olyan <span class="emphasis"><em>Y</em></span> ponthoz, amelyikkel <span class="emphasis"><em>X </em></span>még nincs összekötve, és a vonal semelyik más vonalat nem metsz; ismételje a fenti lépést mindaddig, amíg újabb összeköttetés már nem lehetséges. Számítsa ki a teljesítménytáblázatot a legnagyobb <span class="emphasis"><em>n</em></span>-re, amire csak tudja (mind <span class="emphasis"><em>d </em></span>=<span class="emphasis"><em> </em></span>3-at mind, <span class="emphasis"><em>d </em></span>=<span class="emphasis"><em> </em></span>4-et használva). Fűzzön magyarázatokat a kapott eredményhez.</p></div><p><span class="strong"><strong>5.8.</strong></span></p><p>Az AC-3 algoritmus felhasználásával mutassa meg, hogy az élkonzisztencia alkalmas arra, hogy kimutassa az 5.1. ábra {<span class="emphasis"><em>NyA </em></span>=<span class="emphasis"><em> vörös</em></span>,<span class="emphasis"><em> V </em></span>=<span class="emphasis"><em> kék</em></span>} parciális hozzárendelésének inkonzisztenciáját.</p><p><span class="strong"><strong>5.9.</strong></span></p><p>Mi a fastruktúrájú kényszerkielégítési problémán futtatott AC-3 legrosszabb esetbeli komplexitása?</p><p><span class="strong"><strong>5.10.</strong></span></p><p>Az AC-3 visszarak a sorba <span class="emphasis"><em>minden</em></span> (<span class="emphasis"><em>X<sub>k</sub></em></span>,<span class="emphasis"><em> X<sub>i</sub></em></span>) élet, amikor <span class="emphasis"><em>X<sub>i</sub></em></span> tartományából <span class="emphasis"><em>bármely</em></span> értéket töröltek, akkor is, ha <span class="emphasis"><em>X<sub>k</sub></em></span> minden értéke konzisztens <span class="emphasis"><em>X<sub>i</sub></em></span> több fennmaradó értékével. Tegyük fel, hogy minden egyes (<span class="emphasis"><em>X<sub>k</sub></em></span>,<span class="emphasis"><em> X<sub>i</sub></em></span>) élhez nyilvántartjuk a fennmaradó <span class="emphasis"><em>X<sub>i</sub></em></span> értékek számát, amelyek az <span class="emphasis"><em>X<sub>k</sub></em></span> minden egyes értékével konzisztensek. Magyarázza el, hogyan lehet hatékonyan frissíteni ezeket az értékeket, és hogyan lehet ennek segítségével az élkonzisztenciát <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup><span class="emphasis"><em>d</em></span><sup>2</sup>) lépésben elérni.</p><p><span class="strong"><strong>5.11.</strong></span></p><p>Mutassa meg, hogy egy ternáris kényszer, mint például az „<span class="emphasis"><em>A </em></span>+<span class="emphasis"><em> B </em></span>=<span class="emphasis"><em> C</em></span>” egy segédváltozó bevezetésével három bináris kényszerré alakítható. Feltételezheti, hogy a tartományok végesek. (<span class="emphasis"><em>Segítség: </em></span>gondoljon egy olyan új változóra, amelynek értékei más értékekből álló párok, és gondoljon olyan kényszerekre, mint „<span class="emphasis"><em>X </em></span>az első eleme az <span class="emphasis"><em>Y</em></span> párnak”.) Ezután mutassa meg, hogyan lehet hasonlóan kezelni a háromnál több változót tartalmazó kényszereket. Végül mutassa meg, miként lehet kiküszöbölni az unáris kényszereket a változók tartományának megváltoztatásával. Ez teljessé teszi annak bizonyítását, hogy bármely CSP átalakítható olyan problémákká, melyek csak bináris kényszereket tartalmazhatnak.</p><p><span class="strong"><strong>5.12.</strong></span></p><p class="irodalom" title="Olvasnivaló"><strong>Olvasnivaló. </strong>Tegyük fel, hogy ismerjük egy gráfról, hogy van egy legfeljebb <span class="emphasis"><em>k</em></span> csomópontot tartalmazó ciklikusság-vágóhalmaza. Írjon le <span class="emphasis"><em>n</em></span> változós CSP-k esetén egy egyszerű algoritmust a minimális ciklikusság-vágóhalmaz megkeresésére, ahol a futási idő maximuma <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n<sup>k</sup></em></span>). Végezzen irodalomkutatást olyan vágóhalmaz-keresési eljárások után, amelyek a vágóhalmaz méretében közelítőleg polinomiális időben találnak közelítőleg minimális ciklikusság-vágóhalmazt. Praktikussá teszi az ilyen módszerek létezése a ciklikusság-vágóhalmaz módszereket?</p><p><span class="strong"><strong>5.13.</strong></span></p><p>Tekintsük a következő logikai rejtvényt: Öt különböző színű házban öt különböző nemzetiségű személy él, és mindegyikük más márkájú cigarettát, más italt és más háziállatot szeret. Az alábbi tények alapján a megválaszolandó kérdés a következő: „Hol lakik a zebra, és melyik házban isznak vizet?”</p><p>Az angol a vörös házban lakik.</p><p>A spanyolnak kutyája van.</p><p>A norvég balról az első házban lakik.</p><p>A Kools cigarettát a sárga házban szívják.</p><p>A Chesterfieldset szívó ember a rókás ház mellett lakik.</p><p>A norvég a kék ház mellett lakik.</p><p>A Winstont szívó ember kígyókat tart.</p><p>A Lucky Strike-ot szívó narancslevet iszik.</p><p>Az ukrán teát iszik.</p><p>A japán Parliamentset szív.</p><p>A Koolsot abban a házban szívják, amely mellett lovat tartanak.</p><p>Kávét a zöld házban isznak.</p><p>A zöld ház közvetlenül jobbra (Ön felől nézve) van az elefántcsontszínű háztól.</p><p>Tejet a középső házban isznak.</p><p>Vizsgálja meg a probléma különböző CSP-reprezentációit. Milyen okokból részesítené előnyben az egyiket a másikkal szemben?</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id566477" href="#id566477" class="para">52</a>] </sup> Ginsberg és társai (Ginsberg és társai, 1990) több módszert tárgyalnak keresztrejtvények készítésére. Littman és társai pedig a nehezebb problémát, megoldásukat veszik célba (Littman és társai, 1999).</p></div></div></div></body></html>
