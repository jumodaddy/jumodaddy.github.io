<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Összefoglalás"><div class="titlepage"><div><div><h1 class="title"><a id="id617761"/>Összefoglalás</h1></div></div></div><p>Az elsőrendű logikai következtetés egy elemzését mutattuk be, továbbá számos algoritmust, melyek ilyen következtetéseket képesek végrehajtani.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph">Egy első megközelítés következtetési szabályokat használ kvantorok példányosítására azért, hogy átalakítsa a következtetési problémát az ítéletkalkulusra. Ez a megközelítés jellemzően nagyon lassú megoldásokat eredményez.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>egyesítés</strong></span> használata, azaz a megfelelő helyettesítések megkeresése változókhoz, megszünteti a példányosítás lépését az elsőrendű bizonyításokban, és így sokkal hatékonyabbá teszi a folyamatot.</p></li><li class="listitem"><p class="List Paragraph">A <span class="strong"><strong>Modus Ponens</strong></span> kiterjesztett változata az egyesítést használja, létrehozva egy természetes és nagy modellező erejű következtetési szabályt, az <span class="strong"><strong>általánosított Modus Ponens</strong></span>t (<span class="strong"><strong>generalized Modus Ponens</strong></span>). Az <span class="strong"><strong>előrefelé láncolás</strong></span> (<span class="strong"><strong>forward chaining</strong></span>) és a <span class="strong"><strong>hátrafelé láncolás</strong></span> (<span class="strong"><strong>backward chaining</strong></span>) algoritmusok határozott klózok halmazára alkalmazzák ezt a szabályt.</p></li><li class="listitem"><p class="List Paragraph">Az általánosított Modus Ponens teljes a határozott klózokra, habár a következtetési probléma <span class="strong"><strong>félig eldönthető</strong></span> (<span class="strong"><strong>semidecidable</strong></span>). A <span class="strong"><strong>Datalog</strong></span> programok esetében, amely programok csak függvénymentes határozott klózokat tartalmaznak, a következtetés eldönthető.</p></li><li class="listitem"><p class="List Paragraph">Az előrefelé láncolást a <span class="strong"><strong>deduktív adatbázis</strong></span>okban (<span class="strong"><strong>deductive database</strong></span>s) használják, ahol sikeresen kombinálják ezt a módszert a relációs adatbázis más műveleteivel. Ezenkívül az előrefelé láncolást használják a <span class="strong"><strong>produkciós rendszer</strong></span>ekben (<span class="strong"><strong>production system</strong></span>s) is, amelyek hatékonyan képesek frissíteni a tudásbázisukat nagyméretű szabályhalmazokkal is.</p></li><li class="listitem"><p class="List Paragraph">Az előrefelé láncolás teljes a Datalog programokra, és polinomiális időben fut.</p></li><li class="listitem"><p class="List Paragraph">A hátrafelé láncolást a <span class="strong"><strong>logikai programozási rendszer</strong></span>ekben (<span class="strong"><strong>logic programming </strong></span><span class="strong"><strong>system</strong></span>s) használják, mint amilyen például a <span class="strong"><strong>Prolog</strong></span>, amely kifinomult fordítási technikákat alkalmaz, hogy biztosítsa a gyors következtetést.</p></li><li class="listitem"><p class="List Paragraph">A hátrafelé láncolásban sok a felesleges következtetés, és előfordulhatnak végtelen hurkok. Ezeket a <span class="strong"><strong>memók gyűjtésé</strong></span>vel (<span class="strong"><strong>memoization</strong></span>) lehet kezelni.</p></li><li class="listitem"><p class="List Paragraph">Az általánosított <span class="strong"><strong>rezolúció</strong></span>s (<span class="strong"><strong>resolution</strong></span>) következtetés teljes bizonyítási rendszer az elsőrendű logikában. Az eljárás konjunktív normál formájú tudásbázisokat használ fel.</p></li><li class="listitem"><p class="List Paragraph">Számos stratégia ismert a rezolúciós rendszerek keresési terének a csökkentésére, anélkül hogy a teljességet veszélybe sodornánk. A hatékony rezolúcióalapú tételbizonyításokat felhasználták, hogy érdekes matematikai tételeket bebizonyítsanak, és hogy verifikáljanak, valamint szintetizáljanak szoftvereket és hardvereket.</p></li></ul></div><div class="section" title="Irodalmi és történeti megjegyzések"><div class="titlepage"><div><div><h2 class="title"><a id="id617931"/>Irodalmi és történeti megjegyzések</h2></div></div></div><p>A logikai következtetéseket széles körben vizsgálták már az ókori görög matematikusok is. Az Arisztotelész által legtöbbet vizsgált következtetési módszer a <span class="strong"><strong>szillogizmus</strong></span> (<span class="strong"><strong>syllogism</strong></span>) volt. A szillogizmus „szituációkra” és „hangulatokra” bontható a termek mondatbeli sorrendjétől függően (amelyeket predikátumoknak nevezünk ma) és az egyes termek általánosságának mértékétől függően (amit ma a kvantorok segítségével értelmezünk), illetve attól függően, hogy a termek negálva voltak-e. A legalapvetőbb szillogizmus, amely az első szituáció első hangulata, a következő:</p><p>Minden <span class="emphasis"><em>S</em></span> az <span class="emphasis"><em>M </em></span>is. 	</p><p>Minden <span class="emphasis"><em>M</em></span> a <span class="emphasis"><em>P </em></span>is. 	</p><p>Ezért minden <span class="emphasis"><em>S</em></span> a <span class="emphasis"><em>P </em></span>is.</p><p>Arisztotelész más szillogizmusok érvényességét is megpróbálta igazolni, visszavezetve ezeket az első szituációra. Pontosan leírta az egyes szillogizmusokhoz tartozó hangulatokat és szituációkat, de a szillogizmusok igazolása már kevésbé volt precíz.</p><p>Gottlob Frege, aki teljes elsőrendű logikát fejlesztett ki 1879-ben, következtetési rendszerét logikailag érvényes sémák nagyméretű gyűjteményére és egyetlen következtetési szabályra alapozta, a Modus Ponensre. Frege kihasználta azt a tényt, hogy ennek a formának „A <span class="emphasis"><em>P</em></span>-ből következtesd a <span class="emphasis"><em>Q</em></span>-t” következtetési szabályának a hatását szimulálhatja a Modus Ponens alkalmazásával a <span class="emphasis"><em>P</em></span>-re, egy logikailag érvényes sémával, a <span class="emphasis"><em>P </em></span>⇒ <span class="emphasis"><em>Q</em></span>-val. A kifejezésnek ezt az „axiomatikus” stílusát, amely a Modus Ponenst, plusz számos logikailag érvényes sémát használ, Frege után még számos matematikus használta; a leginkább említésre méltó, hogy a <span class="emphasis"><em>Principia Mathematicá</em></span>ban (Whitehead és Russell, 1910) is felhasználták.<span class="emphasis"><em> </em></span> </p><p>A következtetési szabályok, mint az axiomatikus sémáktól különálló dolgok álltak a <span class="strong"><strong>természetes dedukció</strong></span> (<span class="strong"><strong>natural deduction</strong></span>) központjában, amelyet Gerhard Gentzen és Stanislaw Jáskowski vezetett be (Gentzen, 1934; Jáskowski, 1934). A természetes dedukciót azért nevezik „természetesnek”, mert nem kívánja meg a mondatok átalakítását az (olvashatatlan) normál formára, és következtetési szabályaikat úgy tervezték, hogy az emberek számára természetesnek tűnjenek. Prawitz egy egész könyv hosszúságú elemzést adott a természetes dedukcióról (Prawitz, 1965). Gallier az automatikus dedukció elméleti alátámasztásának kifejtéséhez alkalmazta Gentzen szekvenciáit (Gallier, 1986).</p><p>A klózforma felfedezése nagy jelentőségű lépés volt az elsőrendű logika matematikai elemzésének kifejlesztésében. Whitehead és Russell (Whitehead és Russell, 1910) kiterjesztették az úgynevezett <span class="emphasis"><em>átviteli szabályt</em></span> [maga a kifejezés Herbrandtól származik (Herbrand, 1930)], amit a kvantoroknak a formula elé történő kiemelésére alkalmaztak. A Skolem-konstansokat és a Skolem-függvényeket, viszonylag precíz leírást adva, Thoralf Skolem vezette be (Skolem, 1920). A skolemizáció teljes eljárása, a Herbrand-univerzum fontos fogalmának bevezetésével együtt egy későbbi írásban található (Skolem, 1928).</p><p>Herbrand elmélete, amit Jacques Herbrand francia matematikusról neveztek el, fontos szerepet játszott az automatikus következtető rendszerek módszereinek fejlesztésében, mind a Robinsonhoz fűződő rezolúció bevezetése előtt és után (Herbrand, 1930). Ezt tükrözi az, hogy habár maga a fogalom valójában Skolem eredménye, erre „Skolem-univerzum” helyett „Herbrand-univerzumként” hivatkozunk. Herbrandot említhetjük még az egyesítés felfedezőjeként is, mivel az egyesítés algoritmus egy változata megtalálható a (Herbrand, 1930)-ban. Gödel (Gödel, 1930) mutatta meg, Skolem és Herbrand elméleteire építve, hogy az elsőrendű logikának létezik teljes bizonyítási eljárása. Alan Turing és Alonzo Church egymástól függetlenül, igen különböző bizonyításokat alkalmazva megmutatták, hogy az érvényesség kérdése az elsőrendű logikában nem eldönthető (Turing, 1936; Church 1936). Enderton kiválóan megfogalmazott írása egy precíz, de viszonylag érthető stílusban magyarázza el ezeket az eredményeket (Enderton, 1972).</p><p>Habár McCarthy (McCarthy, 1958) javasolta először az elsőrendű logika használatát reprezentációs feladatokra és következetésre az MI-ben, az első ilyen rendszert a matematikai tételbizonyítás iránt érdeklődő matematikai logika kutatói fejlesztették ki. Abraham Robinson javasolta először, hogy használják az ítéletlogikára történő átalakítást és Herbrand-elméletet együtt. Gilmore (Gilmore, 1960) készített először egy olyan programot, amely ezen a megközelítésen alapult. Davis és Putnam (Davis és Putnam, 1960) vezették be a klózformát, és hoztak létre egy olyan programot, amely megkísérelt cáfolatokat találni, oly módon, hogy a Herbrand-univerzum elemeit a változók helyére alapklózokat helyettesítve és ítéletinkonzisztenciákat keresve az alapklózok között. Prawitz (Prawitz, 1960) vezette be azt az alapötletet, hogy az ítéletinkonzisztencia lekérdezése vezesse a keresési folyamatot, és azt is, hogy csak akkor hozzunk létre termeket a Herbrand-univerzumban, hogyha ez szükséges az ítélet-inkonzisztencia megállapítása céljából. Más kutatók egyéb fejlesztései után, ez a gondolat vezette el J. A. Robinsont (nem rokona az előzőnek) a rezolúció módszerének kifejlesztéséhez (Robinson, 1965). Az úgynevezett „inverz módszer”, amit egyidejűleg fejlesztett ki S. Maslov szovjet kutató, kissé eltérő elveken alapult, mint Robinson rezolúciós módszere, de hasonló számítási előnyöket nyújt a propozicionalizációhoz képest (Maslov, 1964, 1967). Wolfgang Bibel <span class="strong"><strong>kapcsolati módszer</strong></span>e (<span class="strong"><strong>connection method</strong></span>) e megközelítés kiterjesztésének tekinthető.</p><p>A rezolúció kifejlesztése után az elsőrendű következtetéssel foglalkozó munkák különböző irányokban ágaztak el. Az MI-ben a rezolúciót a kérdés-válasz rendszerekre adoptálta Cordell Green és Bertram Raphael (Green és Raphael, 1968). Egy kevésbé formális megközelítést alkalmazott Carl Hewitt (Hewitt, 1969). Az ő <code class="code">PLANNER</code> nyelve, habár sohasem valósították meg teljességében, előfutára volt a logikai programozásnak, és útmutatásokat tartalmazott az előrefelé és hátrafelé láncoláshoz, valamint a negáltak sikertelenségének vizsgálati módszeréhez. Az eredeti nyelv egy részét, a <code class="code">MICRO-PLANNER</code>-t (Sussman és Winograd, 1970) megvalósították és felhasználták az <code class="code">SHRDLU</code> természetes nyelvek megértését segítő rendszerben (Winograd, 1972). A korai MI-alkalmazások jelentős erőfeszítést tettek olyan adatstruktúrák előállítására, amelyek lehetővé teszik tények hatékony előhívását. Ezeket a munkákat is bemutatják az MI-programozással kapcsolatos cikkek (Charniak és társai, 1987; Norvig, 1992; Forbus és de Kleer, 1993).</p><p>A hetvenes évek elejére az <span class="strong"><strong>előrefelé láncolás</strong></span> (<span class="strong"><strong>forward chaining</strong></span>) jól megalapozottnak tekinthető az MI-ben, egy könnyen érthető alternatívája lett a rezolúciónak. Rendszerek széles körében került felhasználásra, Nevins geometriai tételbizonyítójától (Nevins, 1975) a VAX konfigurációjához használt R1 szakértői rendszerig (McDermott, 1982). Az MI-alkalmazások jellemzően nagyszámú szabályt tartalmaztak, tehát fontos volt kifejleszteni hatékony szabályillesztési technológiát, különösen az inkrementális frissítések problémájára. A <span class="strong"><strong>produkciós rendszer</strong></span>ek (<span class="strong"><strong>production system</strong></span>s) technológiáját azért fejlesztették ki, hogy segítse az ilyen típusú az alkalmazások megvalósítását. Az <code class="code">OPS-5</code> produkciós rendszer nyelvet (Forgy, 1981; Brownston és társai, 1985) használták az R1-hez és a <code class="code">SOAR</code> kognitív szerkezetéhez (Laird és társai, 1987). Az <code class="code">OPS-5</code> tartalmazta a rete illesztési folyamatot is (Forgy, 1982). A <code class="code">SOAR</code>, amely új szabályokat generál, hogy megőrizze a megelőző számítások eredményeit, igen nagy szabályhalmazokat állíthat elő – több mint 1 000 000 szabályt a <code class="code">TACAIR-SOAR</code> rendszer esetében, amely katonai repülőgépek szimulációját kontrollálja (Jones és társai, 1998). A CLIPS (Wygant, 1989) egy C-alapú produkciós rendszer nyelv, amelyet a NASA-nál fejlesztettek ki, és hatékony integrációt tett lehetővé más programokkal, eszközökkel és érzékelő rendszerekkel, valamint felhasználták űrjárművek automatizálására és egyéb harcászati alkalmazásokra.</p><p>A <span class="strong"><strong>deduktív adatbázis</strong></span>okként (<span class="strong"><strong>deductive database</strong></span>s) ismert kutatási terület szintén hozzájárult az előrefelé következtetés megértéséhez. Egy Toulouse-i szellemi műhelyben kezdődött a munka 1977-ben, amelyet Jack Minker szervezett, összehozva a logikai következtetési és az adatbázisrendszerekkel foglalkozó szakembereket (Gallaire és Minker, 1978). Egy történeti áttekintés (Ramakrishnan és Ullman, 1995) szerint: a „deduktív [adatbázis-] rendszerek megkísérlik a Prolog adaptálását, a »kis mennyiségű adat« megközelítésről a »nagymennyiségű adat« világára.” Így tehát, ennek a munkának a célja az, hogy egybeolvassza a relációs adatbázis technológiát, amelyet nagyméretű tényhalmazok<span class="emphasis"><em> </em></span>előhívására terveztek, a Prolog-alapú következtetési technológiával, amely jellemzően egyszerre csak egy tényt hív elő. A deduktív adatbázisokról szóló szövegek közé tartoznak az (Ullman, 1989) és a (Ceri és társai, 1990) munkák.</p><p>Chandra és Harel (Chandra és Harel, 1980), valamint Ullman (Ullman, 1985) nagy hatású munkái a Datalognak mint egy, a deduktív adatbázisokhoz kidolgozott standard nyelvnek az elfogadásához vezettek. Az „alulról felfelé” irányú következtetés, az előrefelé láncolás szintén standard lett – részben azért, mert elkerüli a leállási problémákat és a felesleges számítások problémáját, amely a hátrafelé láncolásnál előfordul, és részben azért, mert természetesebben felhasználható az alapvető relációs adatbázis-operációkhoz. A <span class="strong"><strong>mágikus halmaz</strong></span>ok (<span class="strong"><strong>magic set</strong></span>s) technikája a szabályok átírására, amelyet Bancilhon (Bancilhon és társai, 1986) fejlesztettek ki, lehetővé tette az előrefelé láncolásnak, hogy a hátrafelé láncolástól kölcsönözze a célorientáltság előnyös tulajdonságát. A „fegyverkezési verseny” kiegyenlítése céljából, a táblázatos logikai programozási módszerek kölcsönveszik a dinamikus programozás előnyét az előrefelé láncolástól.</p><p>A logikai következtetések komplexitásáról szerzett tudásunk legnagyobb része a deduktív adatbázisokkal foglalkozó tudományos közösségből származik. Chandra és Merlin (Chandra és Merlin, 1977) mutatták ki először, hogy egy egyszerű nem rekurzív szabály (vagyis egy <span class="strong"><strong>konjunktív lekérdezés</strong></span> (<span class="strong"><strong>conjunctive query</strong></span>) az adatbázisok terminológiájában) illesztése NP-nehéz lehet. Kuper és Vardi (Kuper és Vardi, 1993) javasolták az <span class="strong"><strong>adatkomplexitás</strong></span> (<span class="strong"><strong>data complexity</strong></span>) használatát – annak a mértéknek a használatát, ami a komplexitást, mint az adatbázis méretének egy függvényét méri, miközben a szabály méretét konstansnak tekinti – a lekérdezések megválaszolásának mértékére. Gottlob és társai<span class="emphasis"><em> </em></span>(Gottlob és társai, 1999b) a konjuktív lekérdezések és a kényszerkielégítés közötti  kapcsolatot vizsgálták, megmutatva, hogy a hiper-fák lebontása hogyan optimizálja az illesztési folyamatot.</p><p>Mint azt már előzőleg említettük, a <span class="strong"><strong>hátrafelé láncolás</strong></span> (<span class="strong"><strong>backward chaining</strong></span>) Hewitt <code class="code">PLANNER</code> nyelvében jelent meg a logikai következtetéshez (Hewitt, 1969). A logikai következtetés magától értetődően ettől a munkától függetlenül fejlődött tovább. A lineáris rezolúció egy korlátozott változatát, amelyet <span class="strong"><strong>SL-rezolúció</strong></span>nak (<span class="strong"><strong>SL-resolution</strong></span>) nevezünk, Kowalski és Kuehner (Kowalski és Kuehner, 1971) fejlesztette ki Loveland <span class="strong"><strong>modellelimináció</strong></span>s (<span class="strong"><strong>model elimination</strong></span>) technikájára építve (Loveland, 1968). Ennek a határozott klózokra alkalmazott változata az <span class="strong"><strong>SLD-rezolúció</strong></span> (<span class="strong"><strong>SLD-resolution</strong></span>), amely önmagában alkalmas határozott klózok, mint programok interpretálására (Kowalski, 1974; 1979a; 1979b). Ezalatt, 1972-ben, a francia kutató, Alain Colmerauer kifejlesztette és alkalmazni kezdte a <span class="strong"><strong>Prolog</strong></span>ot, a természetes nyelvek elemzésének céljából. A Prolog klózait először kontextusmentes nyelvtani szabályoknak szánták (Roussel, 1975; Colmerauer és társai, 1973). Az elméleti háttér túlnyomó részét a logikai programozás részére Colmerauerrel együttműködve Kowalski fejlesztette ki. A szemantikai definíció, amely a rögzített pontokat használja, Van Emdennek és Kowalskinak köszönhető (Van Emden és Kowalski, 1976). Kowalski (Kowalski, 1988) és Cohen (Cohen, 1988) jó történeti áttekintést nyújtanak a Prolog eredetéről. A <span class="emphasis"><em>Logikai programozás alapjai (Foundations of Logic Programming) </em></span>(Lloyd, 1987) egy elméleti elemzése a Prolog és egyéb logikai programozónyelvek megalapozásának.</p><p>A hatékony Prolog fordítókat általában a Warren Abstract Machine (WAM) számítási modelljére alapozzák, amelyet David H. D. Warren (Warren, 1983) fejlesztett ki. Van Roy (Van Roy, 1990) megmutatta, hogy a további fordítási technikák alkalmazása, mint amilyen a típusinterferencia, versenyképessé teszi a Prolog programokat a C programokkal a sebesség tekintetében. A Japán Ötödik Generációs projekt, amely egy 1982-ben kezdődő 10 éves kutatási erőfeszítés volt, teljes egészében a Prologon, mint az intelligens rendszerek kifejlesztésének alapeszközén alapult.</p><p>A rekurzív logikai programok felesleges ciklusainak elkerüléséhez egymástól függetlenül Smith (Smith és társai, 1986), valamint Tamaki és Sato (Tamaki és Sato, 1986) fejlesztettek ki módszereket. Az utóbbi tanulmány tartalmazta a memók gyűjtését is a logikai programokra, egy olyan módszert, amelyet teljes mértékben David S. Warren fejlesztett ki a <span class="strong"><strong>táblázatos logikai programozás</strong></span> (<span class="strong"><strong>tabled logic programming</strong></span>) módszerében. Swift és Warren (Swift és Warren, 1994) bemutatták, hogy hogyan terjesszük ki a WAM-ot táblázatok kezelésére, amely képessé tette a Datalog programokat, hogy egy nagyságrenddel gyorsabban fussanak, mint az előrefelé láncolást alkalmazó deduktív adatbázisrendszerek.</p><p>A korai elméleti munkákat a korlátozott logikai programozás területén Jaffar és Lassez végezték (Jaffar és Lassez, 1987). Jaffar és társai (Jaffar és társai, 1992a) kifejlesztették a CLP(R) rendszert a valós értékű kényszerek kezelésére. Jaffar (Jaffar és társai, 1992b) általánosította a WAM-ot, létrehozva ezzel a CLAM-ot (Korlátozott Logikai Absztrakt Gép, Constraint Logic Abstract Machine) a CLP megvalósításainak specifikálásához. Ait-Kaci és Podelski (Ait-Kaci és Podelski, 1993) bemutattak egy kifinomult LIFE-nak nevezett nyelvet, amely egyesíti a CLP-t a funkcionális programozással és az öröklődés következtetéssel. Kohn (Kohn, 1991) egy ambiciózus projektet mutat be a korlátozott logikai programozás használva, a valós idejű vezérlési architektúrákat megalapozva, teljesen automata pilóták alkalmazására.</p><p>A logikai programozásról és a Prologról számos könyvet írtak. A <span class="emphasis"><em>Logika a problémamegoldáshoz (Logic for Problem Solving) </em></span>(Kowalski, 1979b) egy korai általános tanulmány a logikai programozásról. A Prologgal foglalkozó könyvek közé tartoznak Clocksin és Mellish (Clocksin és Mellish, 1994), Shoham (Shoham, 1994) és Bratko (Bratko, 2001) írásai. Marriott és Stuckey (Marriott és Stuckey, 1998) kitűnő leírását adják a CLP-nek. A 2000-ben történt megszűnéséig a <span class="emphasis"><em>Journal of Logic Programming </em></span>volt a téma legfontosabb folyóirata; helyét mára átvette a <span class="emphasis"><em>Theory and Practice of Logic Programming. </em></span>A logikai programozások konferenciái között a legjelentősebbek az International Conference on Logic Programming (ICLP) és az International Logic Programming Symposium (ILPS).</p><p>A kutatások a <span class="strong"><strong>matematikai tételbizonyítás</strong></span>ok (<span class="strong"><strong>mathematical theorem proving</strong></span>) területén már az első teljes elsőrendű logikai rendszerek kifejlesztése előtt megkezdődtek. Herbert Gelernter Geometriai Tételbizonyítója (Gelernter, 1959) heurisztikai keresési módszereket használt diagramokkal kombinálva, hogy kiselejtezze a hamis részcélokat, és képes volt bebizonyítani néhány nagyon bonyolult eredményt az euklideszi geometriában. Ettől kezdve azonban nem volt jelentős együttműködés a tételbizonyítás és az MI között.</p><p>A korai munkák a teljességre koncentráltak. Robinson korszakalkotó tanulmányát követően a demodulációs és a paramodulációs szabályokat az egyenlőségi következtetésekre Wos (Wos és társai, 1967), valamint Wos és Robinson (Wos és Robinson, 1968) vezették be, ebben a sorrendben. Ezeket a szabályokat a term átírási rendszerek kontextusában is kifejlesztették (Knuth és Bendix, 1970). Az egyenlőségi következtetés beépítése az egyesítési algoritmusba Gordon Plotkinnak köszönhető (Plotkin, 1972); ez fontos vonása volt a QLISP-nek is (Sacerdoti és társai,<span class="emphasis"><em> </em></span>1976). Jouannaud és Kirchner (Jouannaud és Kirchner, 1991) az egyenlőségi egyesítést a termek átírásának szempontjából vizsgálják. Hatékony algoritmusokat a standard egyesítésre Martelli és Montanari (Martelli és Montanari, 1976), valamint Paterson és Wegman (Paterson és Wegman, 1978) fejlesztettek ki.</p><p>Az egyenlőségi következtetések mellett a tételbizonyítások tartalmaztak különféle speciális célú döntési folyamatokat. Nelson és Oppen (Nelson és Oppen, 1979) javasoltak egy nagy hatású sémát az ilyen eljárásoknak egy általános következtetési rendszerbe integrálására. Más módszerek is hasonló problémákkal foglalkoztak, beleértve Stickel (Stickel, 1985) „elméleti rezolúcióját”, valamint Manna és Waldinger (Manna és Waldinger, 1986) „speciális relációit”.</p><p>Számos vezérlési stratégiát javasoltak a rezolúcióra, kezdve az egységpreferencia stratégiával (Wos és társai, 1964). A támogató halmaz stratégiát Wos (Wos és társai, 1964) javasolta, hogy biztosítson egy bizonyos fokú célorientáltságot a rezolúcióban. A lineáris rezolúció először Lovelandnél (Loveland, 1970) jelent meg. Genesereth és Nilsson (Genesereth és Nilsson, 1987, 5. fejezet) rövid, de átfogó elemzést nyújtanak a vezérlési stratégiák széles skálájáról.</p><p>Guard és társai<span class="emphasis"><em> </em></span>(Guard és társai, 1969) egy korai <code class="code">SAM</code> tételbizonyítót írnak le, amely segített megoldani egy megoldatlan problémát a rácselméletben. Wos és Winkler (Wos és Winkler, 1983) áttekintést nyújtanak az <code class="code">AURA</code> tételbizonyító eredményeiről, amelyeket a matematika és a logika különböző területein fellelhető problémák megoldása terén ért el. McCune (McCune, 1992) ezt folytatja, amikor felhasználja ezeket az eredményeket az <code class="code">AURA</code> utódjának, az <code class="code">OTTER</code>-nek alkalmazásában megoldatlan problémák megoldására. Weidenbach (Weidenbach, 2001) bemutatja a <code class="code">SPASS</code>-t, az egyik legerőteljesebb jelenlegi tételbizonyítót. <span class="emphasis"><em>A Computational Logic </em></span>(Boyer és Moore, 1979) című könyv az alapreferencia a Boyer–Moore-tételbizonyítókhoz. Stickel (Stickel, 1988) leírja a Prolog Technológiai Tételbizonyítót (PTTP), amely egyesíti a Prolog fordítás előnyeit a modell elimináció teljességével (Loveland, 1968). A SETHEO (Letz és társai, 1992) egy másik széles körben használt tételbizonyító, amely hasonló megközelítésen alapul; másodpercenként több millió következtetést tud végrehajtani egy 2000-es munkaállomáson. A <code class="code">LEANTAP</code> (Beckert és Posegga, 1995) hatékony tételbizonyító, amelyet mindössze 25 Prolog sorral valósítottak meg.</p><p>Az automata programszintézisről szóló korai munkákat Simon (Simon, 1963), Green (Green, 1969a), valamint Manna és Waldinger (Manna és Waldinger, 1971) készítették. Burstall és Darlington transzformációs rendszere (Burstall és Darlington, 1977) egyenlőség következtetést használt a rekurzív programszintézishez. A <code class="code">KIDS</code> (Smith, 1990, 1996) az egyik legerősebb modern rendszer; amely egy szakértő segédeszközként működik. Manna és Waldinger (Manna és Waldinger, 1992) egy áttekintő bevezetést adtak a témakör aktuális helyzetéről fókuszba állítva a saját deduktív megközelítésüket. Az <span class="emphasis"><em>Automating Software Design </em></span>(Lowry és McCartney, 1991) számos, a témáról szóló tanulmányt gyűjtött össze. A logikának a hardvertervezésben való felhasználásáról Kern és Greenstreet (Kern és Greenstreet, 1999) adott egy áttekintést; Clarke (Clarke és társai, 1999) műve pedig a modellellenőrzéssel foglalkozik a hardververifikálásban.</p><p>A <span class="emphasis"><em>Computability and Logic </em></span>(Boolos és Jeffrey, 1989) egy jó referencia a teljesség és a nem eldönthetőség témaköréhez. Számos korai tanulmány a matematikai logikáról megtalálható a <span class="emphasis"><em>From Frege to Gödel: A Source Book in Mathematical Logic </em></span>(van Heijenoort, 1967) című könyvben. A tiszta matematikai logika témakörének folyóirata a <span class="emphasis"><em>Journal of Symbolic Logic. </em></span>Az automatizált dedukció irányába haladó könyvek közé tartozik a klasszikus <span class="emphasis"><em>Symbolic Logic and Mechanical Theorem Proving </em></span>(Chang és Lee, 1973), és számos más írás, köztük Wos, Bibel és Kaufmann később íródott munkái (Wos és társai, 1992; Bibel, 1993; Kaufmann és társai, 2000). Az <span class="emphasis"><em>Automation of Reasoning </em></span>c. antológia (Siekmann és Wrightson, 1983) sok fontos korai tanulmányt tartalmaz az automatizált dedukcióról. További áttekintő műveket írtak Loveland (Loveland, 1984) és Bundy (Bundy, 1999). A legjelentősebb folyóirat a tételbizonyítások területén a <span class="emphasis"><em>Journal of Automated Reasoning;</em></span> a legfontosabb konferencia az évente megtartott Conference on Automated Deduction (CADE). A tételbizonyítás területén folyó kutatás szintén szoros kapcsolatban áll a logika használatával a programok és programozási nyelvek elemzésében, amely tárgyban a legfőbb konferencia a Logic in Computer Science.</p></div><div class="section" title="Feladatok"><div class="titlepage"><div><div><h2 class="title"><a id="id618317"/>Feladatok</h2></div></div></div><p><span class="strong"><strong>9.1.</strong></span></p><p>Vezesse le az alaptételekből, hogy az univerzális példányosítás helyes, és azt, hogy az egzisztenciális példányosítás következtetési szempontból egyenértékű tudásbázist hoz létre.</p><p><span class="strong"><strong>9.2.</strong></span></p><p>A <span class="emphasis"><em>Szereti</em></span>( <span class="emphasis"><em>János</em></span>, <span class="emphasis"><em>Fagylalt</em></span>) mondatból kiindulva logikusnak tűnik arra következtetni, hogy ∃<span class="emphasis"><em>x  Szereti</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Fagylalt</em></span>)<span class="emphasis"><em>. </em></span>Adjon meg egy általános következtetési szabályt, az <span class="strong"><strong>egzisztenciális bevezetés</strong></span>t (<span class="strong"><strong>Existential Introduction</strong></span>), amely megerősíti ezt a következtetést. Gondosan vizsgálja meg a feltételeket, amelyeket ki kell elégíteni a felhasznált változókkal és termekkel.</p><p><span class="strong"><strong>9.3.</strong></span></p><p>Tételezzük fel, hogy egy tudásbázis csak egy mondatot tartalmaz: ∃<span class="emphasis"><em>x OlyanMagasMint</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>Everest</em></span>)<span class="emphasis"><em>. </em></span>A következők közül melyek a törvényszerű következményei az Egzisztenciális Példányosítás alkalmazásának?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>OlyanMagasMint</em></span>(<span class="emphasis"><em>Everest</em></span>,<span class="emphasis"><em> Everest</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>OlyanMagasMint</em></span>(<span class="emphasis"><em>Kilimandzsáró</em></span>,<span class="emphasis"><em> Everest</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>OlyanMagasMint</em></span>(<span class="emphasis"><em>Kilimandzsáró</em></span>,<span class="emphasis"><em> Everest</em></span>)<span class="emphasis"><em> </em></span>∧ <span class="emphasis"><em>OlyanMagasMint</em></span>(<span class="emphasis"><em>BenNevis</em></span>,<span class="emphasis"><em> Everest</em></span>)</p></li></ol></div><p>	       (a szabály kétszeri alkalmazása után).</p><p><span class="strong"><strong>9.4.</strong></span></p><p>Adja meg az alábbi atomi mondatpárok legáltalánosabb egyesítőjét, ha egyáltalán létezik ilyen:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>B</em></span>), <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>z</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>)), <span class="emphasis"><em>Q</em></span>(<span class="emphasis"><em>G</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>x</em></span>), <span class="emphasis"><em>y</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Idősebb</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>y</em></span>), <span class="emphasis"><em>y</em></span>), <span class="emphasis"><em>Idősebb</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>x</em></span>), <span class="emphasis"><em>János</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="emphasis"><em>Ismeri</em></span>(<span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>y</em></span>), <span class="emphasis"><em>y</em></span>), <span class="emphasis"><em>Ismeri</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>x</em></span>)</p></li></ol></div><p><span class="strong"><strong>9.5.</strong></span></p><p>Figyelje meg a 9.2. ábrán bemutatott bennfoglalási rácsokat.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Hozza létre a rácsot a következő mondatra: <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>Anyja</em></span>(<span class="emphasis"><em>János</em></span>),<span class="emphasis"><em> Apja</em></span>(<span class="emphasis"><em>Richárd</em></span>))<span class="emphasis"><em>.</em></span></p></li><li class="listitem"><p class="List Paragraph">Hozza létre a rácsot a következő mondatra: <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>IBM</em></span>,<span class="emphasis"><em> y</em></span>)<span class="emphasis"><em> </em></span>(„Mindenki az IBM-nél dolgozik”). Figyeljen arra, hogy minden olyan lekérdezést felsoroljon, amely egyesíthető a mondattal.</p></li><li class="listitem"><p class="List Paragraph">Tételezzük fel, hogy a <code class="code">TÁROL</code> indexel minden egyes mondatot, minden egyes csomópontra a bennfoglalási rácsban. Magyarázza meg, hogy a <code class="code">BETÖLT</code> eljárásnak hogyan kell működnie, amikor néhány mondat ezek közül változókat is tartalmaz; példaként használja a mondatokat az (a) és (b) részfeladatokból, és a következő lekérdezést: <span class="emphasis"><em>Alkalmaz</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> Apja</em></span>(<span class="emphasis"><em>x</em></span>)).</p></li></ol></div><p><span class="strong"><strong>9.6.</strong></span></p><p>Tételezzük fel, hogy betöltjük egy logikai adatbázisba az amerikai választási címjegyzéket, amely felsorolja a korát, a lakóhelyét, a születési dátumát és az anyja nevét minden személynek, társadalombiztosítási számokat használva azonosító adatként. Így tehát György kora így van megadva: <span class="emphasis"><em>Kora</em></span>(443-65-1282, 56). A következő S1–S5 indexelő sémák melyike tesz lehetővé hatékony megoldást a Q1–Q4 lekérdezésekre (tekintsünk egy normál hátrafelé láncolást)?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>S1: </strong></span>egy index minden egyes atomra minden egyes pozícióban.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>S2: </strong></span>egy index minden egyes első argumentumra.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>S3: </strong></span>egy index minden egyes predikátumatomra.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>S4: </strong></span>egy index a predikátum és az első argumentum minden egyes <span class="emphasis"><em>kombinációjára</em></span>.</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>S5: </strong></span>egy index a predikátum és a második argumentum minden egyes <span class="emphasis"><em>kombinációjára</em></span>, és egy index minden egyes első argumentumra (nem standard).</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Q1: Kora</strong></span>(443-44-4321, <span class="emphasis"><em>x</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Q2: Lakik</strong></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> Houston</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Q3: Anyja</strong></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> y</em></span>)</p></li><li class="listitem"><p class="List Paragraph"><span class="strong"><strong>Q4: Kora</strong></span>(<span class="emphasis"><em>x</em></span>, 34) ∧ <span class="emphasis"><em>Lakik</em></span>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em> PiciVárosUSA</em></span>)</p></li></ul></div><p><span class="strong"><strong>9.7.</strong></span></p><p>Feltételezhetnénk, hogy az egyesítés során a változó konfliktus problémáját elkerülhetjük úgy, ha minden mondatnál egyszerre átnevezzük az összes változót a tudásbázisban. Mutassa meg, hogy léteznek olyan mondatok, amelyekre ez a megközelítés nem alkalmazható. (<span class="emphasis"><em>Segítség:</em></span> tekintsünk egy olyan mondatot, amelynek egyik része egyesíthető a többivel.)</p><p><span class="strong"><strong>9.8.</strong></span></p><p>Mutassa meg, hogy hogyan írhatunk meg egy tetszőleges méretű adott 3-SAT problémát, egy elsőrendű határozott klózt és nem több, mint 30 alaptényt felhasználva.</p><p><span class="strong"><strong>9.9.</strong></span></p><p>Adja meg az alábbi mondatok olyan logikai reprezentációját, amely alkalmas arra,  hogy az Általánosított Modus Ponens szabályt alkalmazzuk rájuk:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">A lovak, a tehenek és a malacok emlősök.</p></li><li class="listitem"><p class="List Paragraph">Egy ló leszármazottja is ló.</p></li><li class="listitem"><p class="List Paragraph">Kékszakáll egy ló.</p></li><li class="listitem"><p class="List Paragraph">Kékszakáll Charlie szülője.</p></li><li class="listitem"><p class="List Paragraph">A leszármazott és a szülő inverz relációk.</p></li><li class="listitem"><p class="List Paragraph">Minden emlősnek van szülője.</p></li></ol></div><p><span class="strong"><strong>9.10.</strong></span></p><p>Ebben a problémában a 9.4. feladatban bemutatott mondatokat fogjuk használni. Válaszolja meg a következő kérdéseket hátrafelé láncolást alkalmazva!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Rajzolja fel egy kimerítő hátrafelé láncolás algoritmus bizonyítási fáját a következő mondat igazolásához: ∃<span class="emphasis"><em>h Ló</em></span>(<span class="emphasis"><em>h</em></span>)</p></li><li class="listitem"><p class="List Paragraph">Mi figyelhető meg erről a tárgyterületről?</p></li><li class="listitem"><p class="List Paragraph">Hány megoldás származtatható le <span class="emphasis"><em>h</em></span>-ra a mondatokból?</p></li><li class="listitem"><p class="List Paragraph">Tudna-e olyan módszert mondani, amellyel mindet megkaphatjuk? (<span class="emphasis"><em>Segítség:</em></span> érdemes megnézni (Smith és társai, 1986).)</p></li></ol></div><p><span class="strong"><strong>9.11.</strong></span></p><p>Egy népszerű találós kérdés gyerekeknek a következő: „Nincs se bátyám, se nővérem, mégis annak az embernek az apja az én apám fia.” Használja fel a család tárgykör szabályait (lásd 7. fejezet), és mutassa meg, hogy ki is az említett ember. Használhatja bármelyik, a fejezetben bemutatott következtetési módszert.</p><p><span class="strong"><strong>9.12.</strong></span></p><p>Kövesse nyomon a 9.6. ábrán látható hátrafelé láncolási algoritmus végrehajtását, amikor azt a bűntény probléma megoldására alkalmazzuk. Mutassa be azt az érték-szekvenciát, amelyet a <span class="emphasis"><em>célok </em></span>változó vesz fel, és rendezze egy fa formába.</p><p><span class="strong"><strong>9.13.</strong></span></p><p>A következő Prolog kód egy P<span class="emphasis"><em> </em></span>predikátumot határoz meg:</p><p><code class="code">	P(X,[XС∣Y])</code></p><p><code class="code">	P(X,[Y∣Z]):-P(X,Z)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Mutasson be bizonyítási fákat és megoldásokat ezekre a lekérdezésekre: P(A[1,2,3])és P(2,[1,A,3]) </p></li><li class="listitem"><p class="List Paragraph">Milyen standard operációs listát reprezentál a P?</p></li></ol></div><p><span class="strong"><strong>9.14.</strong></span></p><div class="informalexample"><p/><p>Ebben a feladatban megvizsgáljuk egy sorbarendezés megvalósítását a Prologban.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Írjon Prolog-klózokat, amelyek definiálják a rendezés(L) predikátumot, amely akkor és csakis akkor igaz, ha az L lista emelkedő sorrendben van rendezve.</p></li><li class="listitem"><p class="List Paragraph">Írjon egy Prolog-definíciót erre a predikátumra: perm(L,M), amely akkor és csakis akkor igaz, ha az L a permutációja az M-nek.</p></li><li class="listitem"><p class="List Paragraph">Definiálja a rendez(L, M)-et (az M egy válogatott verziója az L-nek) a perm és a rendezés használatával.</p></li><li class="listitem"><p class="List Paragraph">Futtassa a rendez predikátumot minél hosszabb listákon, amíg el nem veszíti a türelmét. Mekkora a programjának az időkomplexitása?</p></li><li class="listitem"><p class="List Paragraph">Írjon egy gyorsabb rendező algoritmust Prologban, mint amilyen például a beszúrásos válogatás vagy a gyorsválogatás (quicksort).</p></li></ol></div><p/></div><p><span class="strong"><strong>9.15.</strong></span></p><div class="informalexample"><p/><p>Ebben a feladatban megvizsgáljuk az újraíró szabályok rekurzív alkalmazását a logikai programozás felhasználásával. Egy újraíró szabály (vagy <span class="strong"><strong>demodulátor</strong></span> az <code class="code">OTTER</code> terminológiában) egy egyenlet egy megadott iránnyal. Például az <span class="emphasis"><em>x </em></span>+ 0 → <span class="emphasis"><em>x </em></span>újraíró szabály azt sugallja, hogy minden, az <span class="emphasis"><em>x </em></span>+<span class="emphasis"><em> 0</em></span>-hoz illeszkedő kifejezést fel kell cserélni <span class="emphasis"><em>x</em></span>-re. Az újraíró szabályok alkalmazása központi része az egyenletkövetkeztető rendszereknek. Ezt a predikátumot fogjuk használni: újraír(X, Y) az újraíró szabályok reprezentálására. Például a korábbi újraíró szabályt így írtuk: újraír(X+0, X). Néhány term <span class="emphasis"><em>primitív, </em></span>és nem lehet tovább egyszerűsíteni; így tehát ezt fogjuk írni: primitív(0) , ami azt jelenti, hogy a 0 egy primitív term.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Írjon egy definíciót az egyszerűsít(X,Y) predikátumra, amely akkor igaz, amikor az Y az egyszerűsített változata X-nek – tehát amikor már több újraíró szabály nem alkalmazható az Y egyik részkifejezésére sem.</p></li><li class="listitem"><p class="List Paragraph">Írjon egy szabálygyűjteményt az aritmetikai operátorokat tartalmazó kifejezések egyszerűsítésére, és alkalmazza az egyszerűsítési algoritmusát néhány minta kifejezésre.</p></li><li class="listitem"><p class="List Paragraph">Írjon egy újraíró szabálygyűjteményt a szimbolikus differenciálásra, és használja az egyszerűsítési szabályaival együtt, hogy differenciáljon, és egyszerűsítsen aritmetikai kifejezéseket tartalmazó kifejezéseket, beleértve a hatványozást.</p></li></ol></div><p/></div><p><span class="strong"><strong>9.16.</strong></span></p><p>Ebben a feladatban megvizsgáljuk a keresési algoritmusok alkalmazását a Prologban. Tételezzük fel, hogy a következő(X, Y) akkor igaz, ha az Y állapot az X állapotot követi; és ha a cél(X) akkor igaz, amikor az X a célállapot. Írjon egy definíciót a megold(X,P)-re, ami azt jelenti, hogy a P az útvonal (az állapotok listája), amely az X-szel kezdődik, a célállapotban végződik, és szabályos lépésekből áll, amelyeket a következő határoz meg. Valószínűleg a mélységi keresés a legkönnyebb módja annak, hogy ezt végrehajtsa. Mennyire lenne könnyű egy heurisztikus keresési vezérlés hozzáadása?<span class="emphasis"><em> </em></span></p><p><span class="strong"><strong>9.17.</strong></span></p><p>Hogyan alkalmazható a rezolúció annak megmutatásra, hogy egy mondat</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">érvényes-e?</p></li><li class="listitem"><p class="List Paragraph">kielégíthetetlen-e?</p></li></ol></div><p><span class="strong"><strong>9.18.</strong></span></p><p>Abból a mondatból, hogy „a lovak állatok” következik-e, hogy „egy ló feje egy állat feje”. Demonstrálja, hogy ez a következtetés érvényes, ha végrehajtjuk a következő lépéseket:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Fordítsa le a premisszát és a következményt az elsőrendű logika nyelvére. Használjon három predikátumot: <span class="emphasis"><em>Feje</em></span>(<span class="emphasis"><em>h</em></span>, <span class="emphasis"><em>x</em></span>),<span class="emphasis"><em> Ló</em></span>(<span class="emphasis"><em>x</em></span>) és <span class="emphasis"><em>Állat</em></span>(<span class="emphasis"><em>x</em></span>)!</p></li><li class="listitem"><p class="List Paragraph">Negálja a következményt, és konvertálja a premisszát és a negált következményt konjunktív normál formára!</p></li><li class="listitem"><p class="List Paragraph">Mutassa meg a rezolúció felhasználásával, hogy a következmény valóban következik a premisszából!</p></li></ol></div><p><span class="strong"><strong>9.19.</strong></span></p><p>Tekintsük a következő két elsőrendű logikai mondatot:</p><p><code class="code">	(A):	∀<em><span class="remark">x</span></em>   ∃<em><span class="remark">y</span></em>   (<em><span class="remark">x </span></em>≥ <em><span class="remark">y</span></em>)</code></p><p><code class="code">	(B):	∃<em><span class="remark">y</span></em>   ∀<em><span class="remark">x</span></em>   (<em><span class="remark">x ≥</span></em> <em><span class="remark">y</span></em>)</code></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="List Paragraph">Legyenek a változók lehetséges értékei a természetes számok 0, 1, 2, …, ∞, és jelentse a „≥” predikátum azt, hogy „nagyobb vagy egyenlő”. Fordítsa le ezeket a mondatokat magyarra ebben az interpretációban!</p></li><li class="listitem"><p class="List Paragraph">Igaz-e (A) ebben az interpretációban?</p></li><li class="listitem"><p class="List Paragraph">Igaz-e (B) ebben az interpretációban?</p></li><li class="listitem"><p class="List Paragraph">Maga után vonja-e az (A) mondat a (B) mondatot?</p></li><li class="listitem"><p class="List Paragraph">Maga után vonja-e a (B) mondat az (A) mondatot?</p></li><li class="listitem"><p class="List Paragraph">Próbálja meg a rezolúció felhasználásával bizonyítani, hogy (A) következik (B)-ből! Tegye meg ezt akkor is, ha azt gondolja, hogy (B) nem vonja maga után (A)-t; folytassa az eljárást addig, amíg a bizonyítás már nem folytatható. Tüntesse fel az egyesítő helyettesítéseket minden rezolúciós lépésnél! Ha a bizonyítás sikertelen, magyarázza meg, hogy hol, hogyan és miért akad meg!</p></li><li class="listitem"><p class="List Paragraph">Most próbálja meg igazolni azt, hogy (B) következik (A)-ból!</p></li></ol></div><p><span class="strong"><strong>9.20.</strong></span></p><p>A rezolúció változókkal való lekérdezésekre létrehozhat nem konstruktív bizonyításokat, ezért egy speciális eljárást kell bevezetnünk a definit válaszok kinyerésére. Magyarázza meg, hogy ez a probléma miért nem merül fel csak definit klózokat tartalmazó tudásbázisokkal!</p><p><span class="strong"><strong>9.21.</strong></span></p><p>Ebben a fejezetben azt mondtuk, hogy a rezolúció nem használható egy mondathalmaz összes logikai következményének a generálására. Van olyan algoritmus, ami képes erre?</p></div></div></body></html>
