<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Induktív logikai programozás"><div class="titlepage"><div><div><h1 class="title"><a id="id734118"/>Induktív logikai programozás</h1></div></div></div><p>Az induktív logikai programozás (ILP) az induktív módszereket az elsőrendű reprezentációk erejével kombinálva, az elméletek logikai programok formájában történő kifejezésére helyezi a hangsúlyt.<sup>[<a id="id734125" href="#ftn.id734125" class="footnote">192</a>]</sup> Az ILP három oknál fogva terjedt el. Először is az ILP az általános tudásalapú induktív tanulási probléma precíz, szigorú megközelítését adja. Másodszor, teljes algoritmusokat szolgáltat az általános elsőrendű elméletek indukciós úton, példák alapján történő előállítására. Következésképpen olyan területeken is képes sikeresen tanulni, ahol az attribútumalapú algoritmusokat nehéz alkalmazni. Ennek egy példája a fehérjemolekulák összehajtogatásának a tanulása (lásd 19.10. ábra). A fehérjemolekula háromdimenziós konfigurációját egy attribútumhalmazzal ésszerűen kifejezni nem lehet, mert a konfiguráció lényege az objektumok közötti <span class="emphasis"><em>relációkra</em></span> vonatkozik, és nem az egyes objektumok attribútumaira. A relációk leírására megfelelő apparátus az elsőrendű logika. Harmadszor, induktív logikai programozás által létrehozott hipotézisek emberek számára (viszonylag) könnyen olvashatók. A 19.10. ábrabeli természetes nyelvű fordítást a gyakorló biológusok végigelemezhetik és kritizálhatják. Ez azt jelenti, hogy az induktív logikai programrendszerek részt vehetnek a kísérletezés, a hipotézisgenerálás, a megvitatás és a cáfolat tudományos ciklusában. Az ilyen részvétel a „fekete doboz” osztályozókat gyártó módszerek számára, mint amilyenek például a neurális hálók, lehetetlen lenne.</p><div class="section" title="Egy példa"><div class="titlepage"><div><div><h2 class="title"><a id="id734134"/>Egy példa</h2></div></div></div><p>Emlékezzünk a (19.5) egyenlet alapján, hogy az általános tudásalapú indukciós probléma az alábbi vonzatkényszer:</p><p><code class="code"><em><span class="remark">Háttértudás </span></em>∧<em><span class="remark"> Hipotézis </span></em>∧ <em><span class="remark">Leírások</span></em> ⊨ <em><span class="remark">Besorolások</span></em></code></p><p>„megoldása” az ismeretlen <span class="emphasis"><em>Hipotézis-re</em></span> nézve, feltéve, hogy adottak a <span class="emphasis"><em>Háttértudás</em></span>, valamint a <span class="emphasis"><em>Leírások</em></span> és a <span class="emphasis"><em>Besorolások</em></span> által leírt példák. Hogy ezt megvilágítsuk, tekintsük a rokonsági relációk példák alapján történő tanulását. A megfigyeléseket egy kiterjedt családfa képezi, az <span class="emphasis"><em>Anyja</em></span>, <span class="emphasis"><em>Apja</em></span>, <span class="emphasis"><em>Házas</em></span> relációkkal, valamint a <span class="emphasis"><em>Férfi</em></span> és <span class="emphasis"><em>Nő</em></span> tulajdonságokkal leírva. A 8.11. feladat családfáját fogjuk használni, amit a 19.11. ábra mutat. A példához tartozó leírások az alábbiak:</p><p><code class="code"><em><span class="remark">Apja</span></em>(<em><span class="remark">Fülöp</span></em>, <em><span class="remark">Károly</span></em>)		 <em><span class="remark">Apja</span></em>(<em><span class="remark">Fülöp</span></em>, <em><span class="remark">Anna</span></em>)		...</code></p><p><code class="code"><em><span class="remark">Anyja</span></em>(<em><span class="remark">Mami</span></em>, <em><span class="remark">Margit</span></em>)		<em><span class="remark">Anyja</span></em>(<em><span class="remark">Mami</span></em>, <em><span class="remark">Erzsébet</span></em>)		...</code></p><p><code class="code"><em><span class="remark">Házas</span></em>(<em><span class="remark">Diana</span></em>, <em><span class="remark">Károly</span></em>)		<em><span class="remark">Házas</span></em>(<em><span class="remark">Erzsébet</span></em>, <em><span class="remark">Fülöp</span></em>)		...</code></p><p><code class="code"><em><span class="remark">Férfi</span></em>(<em><span class="remark">Fülöp</span></em>)			<em><span class="remark">Férfi</span></em>(<em><span class="remark">Károly</span></em>)			...</code></p><p><code class="code"><em><span class="remark">Nő</span></em>(<em><span class="remark">Beatrix</span></em>)			<em><span class="remark">Nő</span></em>(<em><span class="remark">Margit</span></em>)			...</code></p><p>A <span class="emphasis"><em>Besorolások</em></span> állításai azon múlnak, hogy milyen célfogalmat szeretnénk megtanulni. A célpredikátumok olyan fogalmak lehetnének, mint például a <span class="emphasis"><em>Nagyszülője</em></span>, a <span class="emphasis"><em>Sógora</em></span>, illetve az <span class="emphasis"><em>őse</em></span>. A <span class="emphasis"><em>Nagyszülője</em></span> esetén a <span class="emphasis"><em>Besorolások</em></span> teljes halmaza 20 × 20 = 400</p><p><code class="code"><em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">Mami</span></em>, <em><span class="remark">Károly</span></em>)	<em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">Erzsébet</span></em>, <em><span class="remark">Beatrix</span></em>)	…</code></p><p><code class="code">¬<em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">Mami</span></em>, <em><span class="remark">Harry</span></em>)	¬<em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">Spencer</span></em>, <em><span class="remark">Péter</span></em>)	…</code></p><p>alakú konjunktból áll. Természetesen e teljes halmaz részhalmazából is tudnánk tanulni. </p><div class="figure"><a id="id734373"/><p class="title"><strong>19.10. ábra - Az (a) és (b) ábra a fehérjemolekula összehajtogatásának tárgyterületén a „négy-helikális fel-és-le köteg” fogalom pozitív és negatív példáját mutatja. Mindkét példa struktúráját egy olyan kb. 100 konjunktív tagot tartalmazó logikai kifejezésbe kódolták, mint amilyen például<span class="emphasis"><em> </em></span>a<span class="emphasis"><em> TeljesHossz</em></span>(<span class="emphasis"><em>D</em></span>2<span class="emphasis"><em>mhr</em></span>, 118) ∧ <span class="emphasis"><em>HelikálisSzám</em></span>(<span class="emphasis"><em>D</em></span>2<span class="emphasis"><em>mhr</em></span>, 6) ∧ …<span class="emphasis"><em> </em></span>kifejezés<span class="emphasis"><em>.</em></span></strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-10.png" alt="Az (a) és (b) ábra a fehérjemolekula összehajtogatásának tárgyterületén a „négy-helikális fel-és-le köteg” fogalom pozitív és negatív példáját mutatja. Mindkét példa struktúráját egy olyan kb. 100 konjunktív tagot tartalmazó logikai kifejezésbe kódolták, mint amilyen például a TeljesHossz(D2mhr, 118) ∧ HelikálisSzám(D2mhr, 6) ∧ … kifejezés."/></div></div></div><p>Az ilyen leírásokból és az<span class="emphasis"><em> Összehajtogatás</em></span>(<code class="code">NÉGY-HELIKÁLIS-FEL-ÉS-LE-KÖTEG</code>, <span class="emphasis"><em>D</em></span>2<span class="emphasis"><em>mhr</em></span>) jellegű besorolásokból a <code class="code">PROGOL</code><span class="emphasis"><em> </em></span>induktív logikai programrendszer (Muggleton, 1995) az alábbi szabályt tanulta meg:</p><p><code class="code"><em><span class="remark">Összehajtogatás</span></em>(Négy-Helikális-Fel-és-Le-Köteg, <em><span class="remark">f</span></em>) ⇐</code></p><p><code class="code"><em><span class="remark">		Helikális</span></em>(<em><span class="remark">f</span></em>, <em><span class="remark">cs</span></em><sub>1</sub>) ∧ <em><span class="remark">Hossz</span></em>(<em><span class="remark">cs</span></em><sub>1</sub>, Magas) ∧ <em><span class="remark">Pozíció</span></em>(<em><span class="remark">f</span></em>, <em><span class="remark">cs</span></em><sub>1</sub>, <em><span class="remark">n</span></em>)</code></p><p><code class="code">		∧ (1 ≤ <em><span class="remark">n </span></em>≤ 3) ∧ <em><span class="remark">Szomszédos</span></em>(<em><span class="remark">f</span></em>, <em><span class="remark">cs</span></em><sub>2</sub>, <em><span class="remark">cs</span></em><sub>2</sub>) ∧ <em><span class="remark">Helikális</span></em>(<em><span class="remark">f</span></em>, <em><span class="remark">cs</span></em><sub>2</sub>)</code></p><p>Ilyen típusú szabályt az előbbi fejezetekben látott, attribútumalapú mechanizmusokkal megtanulni, sőt kifejezni sem lehet. A szabály a természetes nyelvben kifejezve:</p><p>Az <span class="emphasis"><em>F</em></span> fehérje a „Négy-helikális fel-és-le köteg” összehajtogatási osztályhoz tartozik, ha egy hosszú <span class="emphasis"><em>cs</em></span><sub>1</sub> helikálist tartalmaz a másodlagos struktúra 1. és 3. közötti pozícióban, valamint <span class="emphasis"><em>cs</em></span><sub>1</sub> a második helikálissal szomszédos.</p><div class="figure"><a id="id734551"/><p class="title"><strong>19.11. ábra - Egy tipikus családfa</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-11.png" alt="Egy tipikus családfa"/></div></div></div><p>Az induktív tanuló program tárgya egy olyan állításhalmaz <span class="emphasis"><em>Hipotézis</em></span>-ként való előállítása, amely a vonzatkényszert kielégíti. Átmenetileg tegyük fel, hogy az ágens nem rendelkezik háttértudással, a <span class="emphasis"><em>Háttértudás</em></span> üres. Akkor egy lehetséges megoldás a <span class="emphasis"><em>Hipotézis</em></span>-re a következő:</p><p><code class="code"><em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>) ⇔[ ∃<em><span class="remark">z </span></em> <em><span class="remark">Anyja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Anyja</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>)]</code></p><p><code class="code">		[∃<em><span class="remark">z </span></em> <em><span class="remark">Anyja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Apja</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>)]</code></p><p><code class="code">		[∃<em><span class="remark">z </span></em> <em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Anyja</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>)]</code></p><p><code class="code">		[∃<em><span class="remark">z</span></em>  <em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Apja</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>)]</code></p><p class="Tartalom3">Vegyük észre, hogy egy attribútumalapú tanuló algoritmus, mint például a <code class="code">DÖNTÉSI-FA-TANULÁS</code> sehogy sem fog ezzel a problémával boldogulni. Ahhoz, hogy a <span class="emphasis"><em>Nagyszülője</em></span>-t attribútumként (azaz egy unáris predikátumként) fejezzük ki, az embereket <span class="emphasis"><em>párosával</em></span> objektumként kell tudnunk kezelni:</p><p><code class="code"><em><span class="remark">Nagyszülője</span></em>(〈<em><span class="remark">Mami</span></em>, <em><span class="remark">Károly</span></em>〉)…</code></p><p>Ezek után ott akadunk el, amikor megkíséreljük egy példa leírását formálisan reprezentálni. Csupán olyan elrettentő attribútumokat tudnánk használni, mint az:</p><p><code class="code"><em><span class="remark">ErzsébetAnyjaAzElsőElem</span></em>(〈<em><span class="remark">Mami</span></em>, <em><span class="remark">Károly</span></em>〉)</code></p><div class="important" title="Fontos" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Fontos</h3><p>A <span class="emphasis"><em>Nagyszülője</em></span>-nek az ilyen attribútumokkal kifejezett definíciója nem lesz más, mint egy nagy diszjunkció, ami az egyes konkrét esetekből áll, és amit lehetetlen az új esetekre általánosítani. Az <span class="emphasis"><em>attribútumalapú tanuló algoritmusok képtelenek relációs predikátumokat megtanulni</em></span>. Az ILP egyik legfontosabb előnye tehát az, hogy a problémák sokkal szélesebb választékában alkalmazhatók, beleértve a relációs problémákat is.</p></div><p>Az olvasó természetesen észreveszi, hogy egy kis háttértudás segítene a <span class="emphasis"><em>Nagyszülője</em></span> definíciójának reprezentációjánál. Így például, ha a <span class="emphasis"><em>Háttértudás</em></span> tartalmazná az alábbi állítást:</p><p><code class="code"><em><span class="remark">Szülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>) ⇔ [<em><span class="remark">Anyja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>) ⋁ <em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)]</code></p><p>akkor a <span class="emphasis"><em>Nagyszülője</em></span> definícióját a:</p><p><code class="code"><em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>) ⇔ [∃<em><span class="remark">z</span></em> <em><span class="remark">Szülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Szülője</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>)]</code></p><p>állításra lehetne redukálni. Ez megmutatja, hogy mennyire tud a háttértudás hozzájárulni a példák megmagyarázásához szükséges hipotézis méretének drasztikus csökkentéséhez.</p><p>Az ILP-algoritmus új predikátumokat is <span class="emphasis"><em>létesíthet,</em></span> hogy a magyarázó jellegű hipotézis kifejezését egyszerűsítse. Az előbbi példát tekintve, teljesen ésszerű egy pótpredikátumot javasolni – amit <span class="emphasis"><em>„Szülője”</em></span>-nek tudnánk nevezni –, hogy a célpredikátum definícióját egyszerűsítsük. Azok az algoritmusok, amelyek új predikátumokat tudnak létesíteni, az ún. <span class="strong"><strong>k</strong></span><span class="strong"><strong>onstruktív indukció</strong></span>s (<span class="strong"><strong>constructive induction</strong></span>) algoritmusok. Világos, hogy a konstruktív indukció a bevezetőben vázolt kumulatív tanulás egy szükséges komponense. A kumulatív tanulás a gépi tanulás egyik legnehezebb problémája, azonban egyes ILP-technikák kellően hatékony mechanizmusnak bizonyultak a megoldására.</p><p>A fejezet hátralévő részében az ILP két alapvető megközelítését fogjuk tanulmányozni. Az első a döntési fák általánosításán, a másik a rezolúciós bizonyítás invertálásán alapul.</p></div><div class="section" title="Felülről lefelé tanulási módszerek"><div class="titlepage"><div><div><h2 class="title"><a id="id736351"/>Felülről lefelé tanulási módszerek</h2></div></div></div><p>Az ILP első megközelítésében egy igen általános szabállyal kezdünk és azt fokozatosan leszűkítjük, hogy az adatokra illeszkedjen. Ez az, ami lényegében a döntési fa tanulásánál történik, ahol a döntési fa fokozatosan növekszik, amíg a megfigyelésekkel konzisztens nem lesz. Hogy az ILP-t magvalósítsuk, elsőrendű literálokat használunk attribútumok helyett, a hipotézis pedig egy klózhalmaz, a döntési fa helyett. Ebben a részben az egyik legelső ILP-programmal, a <code class="code">FOIL</code>-lal foglalkozunk (Quinlan, 1990).</p><p>Tegyük fel, hogy továbbra is a <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) predikátum definícióját szeretnénk megtanulni az előbb közölt családi példák alapján. A döntési fa tanulásához hasonlóan a példákat pozitív és negatív példákra bontjuk. A pozitív példák:</p><p><code class="code">〈<em><span class="remark">György</span></em>, <em><span class="remark">Anna</span></em>〉, 〈<em><span class="remark">Fülöp</span></em>, <em><span class="remark">Péter</span></em>〉, 〈<em><span class="remark">Spencer</span></em>, <em><span class="remark">Harry</span></em>〉, …</code></p><p>míg a negatív példák:</p><p><code class="code">〈<em><span class="remark">György</span></em>, <em><span class="remark">Erzsébet</span></em>〉, 〈<em><span class="remark">Harry</span></em>, <em><span class="remark">Zara</span></em>〉, 〈<em><span class="remark">Károly</span></em>, <em><span class="remark">Fülöp</span></em>〉, …</code></p><p>Figyeljük meg, hogy mindegyik példa egy objektum<span class="emphasis"><em>páros</em></span>, hiszen a <span class="emphasis"><em>Nagyszülője</em></span> egy bináris predikátum. Egészét tekintve a családfában 12 pozitív és 388 negatív (a személyek minden más párosítása) példa található.</p><p>A <code class="code">FOIL</code> program klózok egy halmazát alakítja ki, mindegyik <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>)-nal mint fejjel. A klózoknak a 12 pozitív példát a <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) reláció példányosításának kell osztályozniuk, a többi 388-at viszont kizárni. A klózok Horn-klózok, melyeket negált literálokkal bővítünk ki, ahol a negálást mint kudarcot használjuk, hasonlóan a Prologhoz. Egy üres testű klózzal kezdünk:</p><p><code class="code">⇒<em><span class="remark"> Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p>Mivel ez a választás minden példát pozitívnak sorol be, leszűkítésre szorul. Ez úgy tehető meg, hogy egy lépésben egy literált adunk a bal oldalhoz. A három lehetséges eset:</p><p><code class="code"><em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p><code class="code"><em><span class="remark">Szülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p><code class="code"><em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p>(Vegyük észre, hogy a <span class="emphasis"><em>Szülője</em></span>-t definiáló klózzal a háttértudás már rendelkezik.) E három eset közül az első az összes 12 pozitív példát helytelenül negatívnak sorolja be, így ezt az esetet kizárjuk. A második és a harmadik az összes pozitív példával összhangban van. A második eset azonban a negatív példák nagyobb halmazán – pontosabban kétszer annyi példán – helytelen, mert az anyákat és az apákat is megengedi. Így a választásunk a harmadik esetre esik. </p><p>Most az esetet tovább kell szűkíteni, kizárva azokat az eseteket, amikor <span class="emphasis"><em>x</em></span> valamilyen <span class="emphasis"><em>z</em></span> szülője, de <span class="emphasis"><em>z</em></span> mégsem <span class="emphasis"><em>y</em></span> szülője. Egy egyedi <span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>y</em></span>) literál hozzáadása a következő klózt eredményezi:</p><p><code class="code"><em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Szülője</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p>amely az összes példát helyesen sorolja be. A <code class="code">FOIL</code> képes lesz ezt a literált megtalálni és kiválasztani, és ezzel a tanulási feladatot megoldja. Általánosságban, a helyes megoldás megtalálása előtt, a <code class="code">FOIL</code>-nak számos sikertelen klóz között kell keresnie. Ez a példa a <code class="code">FOIL</code> működésének egyszerű illusztrációja. A teljes algoritmus váza a 19.12. ábrán látható. Az algoritmus lényegében literálról literálra egy klózt konstruál, amíg az meg nem egyezik a pozitív példák valamilyen részhalmazával, és egyik negatív példával sem egyezik. A klóz által lefedett pozitív példákat ekkor a tanító halmazból elhagyjuk, és az eljárást folytatjuk, amíg egyetlen pozitív példa sem marad. Az algoritmus két fő komponense szorul magyarázatra – az <code class="code">ÚJ-LITERÁLOK</code>, amely a klózhoz hozzáadandó összes új literált konstruálja, és a <code class="code">LITERÁL-MEGVÁLASZTÁSA</code>, amely kiválasztja a hozzáadandó literált.</p><div class="figure"><a id="id736642"/><p class="title"><strong>19.12. ábra - A <code class="code">FOIL</code> algoritmus váza, amely példákból elsőrendű Horn-klózokat tanul meg. Az <code class="code">ÚJ-LITERÁLOK</code> és a <code class="code">LITERÁL-MEGVÁLASZTÁSA</code> eljárásokat a szövegben magyarázzuk meg.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-12.png" alt="A FOIL algoritmus váza, amely példákból elsőrendű Horn-klózokat tanul meg. Az ÚJ-LITERÁLOK és a LITERÁL-MEGVÁLASZTÁSA eljárásokat a szövegben magyarázzuk meg."/></div></div></div><p>Az <code class="code">ÚJ-LITERÁLOK</code> egy klózt kap bementként, és minden lehetséges „hasznos” literált konstruál, amit a klózhoz hozzá lehetne adni. Vegyük például az alábbi klózt:</p><p><code class="code"><em><span class="remark">Apja</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p>Háromfajta literált adhatunk hozzá a klózhoz:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="emphasis"><em>Predikátumokat használó literálok:</em></span> a literál lehet negált vagy ponált, minden létező predikátum (a célpredikátumot is beleértve) használható, és minden argumentum csakis változó lehet. A predikátumok argumentumai tetszőleges változók lehetnek, egy kikötéssel: minden literálnak tartalmaznia kell <span class="emphasis"><em>legalább</em></span> egy változót egy korábbi literálból vagy a klóz fejéből. Olyan literálok, mint: <span class="emphasis"><em>Anyja</em></span>(<span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>u</em></span>), <span class="emphasis"><em>Házas</em></span>(<span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>z</em></span>), ¬<span class="emphasis"><em>Férfi</em></span>(<span class="emphasis"><em>y</em></span>) és <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>v</em></span>, <span class="emphasis"><em>x</em></span>) megengedettek, ám <span class="emphasis"><em>Házas</em></span>(<span class="emphasis"><em>u</em></span>, <span class="emphasis"><em>v</em></span>) nem. Megjegyzendő, hogy a klóz fejéből származó predikátumok használata lehetővé teszi, hogy a <code class="code">FOIL</code> a <span class="emphasis"><em>rekurzív</em></span> definíciót is megtanulja.</p></li><li class="listitem"><p><span class="emphasis"><em>Egyenlőségi és egyenlőtlenségi literálok:</em></span> ezek a klózban már szereplő változókat kötik össze. Így például a klózhoz hozzáadhatjuk, hogy: <span class="emphasis"><em>z</em></span> ≠ <span class="emphasis"><em>x</em></span>. Ezekben a literálokban a felhasználó által specifikált konstansok is felhasználhatók. Az aritmetikát tanulva célszerű kitüntetni a 0-t és az 1-et, a listafüggvényeknél pedig az üres [] listát.</p></li><li class="listitem"><p><span class="emphasis"><em>Aritmetikai összehasonlítások:</em></span> folytonos változójú függvények tanulásánál célszerű lehet az olyan literálok hozzáadása, mint az <span class="emphasis"><em>x</em></span> &gt; <span class="emphasis"><em>y</em></span> és az <span class="emphasis"><em>y </em></span>≤<span class="emphasis"><em> z</em></span>. A döntési fa tanulásához hasonlóan egy konstans küszöbértéket is lehet használni, ami a teszt diszkriminációs erejét maximalizálja.</p></li></ol></div><p>Mindez a keresési térben nagyon nagy elágazási tényezőhöz vezet (lásd 19.6. feladat), azonban a Foil implementációiban a típusinformációt is fel lehet használni a hipotézistér leszűkítésére. Az embereket és a számokat tartalmazó tárgytartományban például a típusleszűkítés nem engedné, hogy az <code class="code">ÚJ-LITERÁLOK</code> olyan literálokat generáljon, mint a <span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>n</em></span>), ahol <span class="emphasis"><em>x</em></span> egy ember, <span class="emphasis"><em>n</em></span> viszont egy szám.</p><p>A <code class="code">LITERÁL-MEGVÁLASZTÁSA</code> az információnyereségre (lásd <a class="xref" href="ch18s03.md#ID_761_oldal">„Attribútumteszt-választás”</a> rész) valamilyen mértékben hasonló heurisztikát használ, hogy eldöntse, melyik literált adja hozzá a klózhoz. A részletek itt nem különösen fontosak, ráadásul számos kipróbált változat is létezik. A Foil egyik érdekes járulékos tulajdonsága az Ockham borotvája elvének az alkalmazása bizonyos hipotézisek eliminálására. Ha (egy bizonyos mérték szerint) egy klóz hosszabbnak mutatkozik, mint az általa megmagyarázott pozitív példák összhossza, akkor ezt a klózt a továbbiakban nem tekintjük lehetséges hipotézisnek. Ezzel a technikával elkerülhetjük az adatokban található zajra illeszkedő, túlságosan bonyolult klózok származtatását. A zaj és a klózhossz kapcsolatának magyarázatát lásd a <a class="xref" href="ch20.md#ID_821_oldal">„Statisztikai tanulás”</a> részben.</p><p>A <code class="code">FOIL</code>-t és társait számos definíció megtanulására vetették be. Az egyik leghatásosabb demonstráció (Quinlan és Cameron-Jones, 1993) a listakezelő függvényekre vonatkozó feladatok hosszú sorának a megoldása volt Bratko Prolog-tankönyvéből (Bratko, 1986). A program mindegyik esetben képes volt a függvény helyes definícióját kisszámú példa alapján megtanulni, miközben háttértudásként használta a korábban megoldott függvényeket.</p></div><div class="section" title="Induktív tanulás inverz rezolúcióval"><div class="titlepage"><div><div><h2 class="title"><a id="id736843"/>Induktív tanulás inverz rezolúcióval</h2></div></div></div><p>Az ILP-nek másik fő megközelítése a megszokott deduktív bizonyítási folyamat invertálása. Az <span class="strong"><strong>inverz rezolúció </strong></span>(<span class="strong"><strong>inverse resolution</strong></span>) azon az észrevételen alapul, hogy ha a példa <span class="emphasis"><em>Besorolások</em></span> a <span class="emphasis"><em>Háttértudás</em></span> ∧ <span class="emphasis"><em>Hipotézis</em></span> ∧ <span class="emphasis"><em>Leírások</em></span>-ból következnek, akkor ezt a tényt rezolúcióval be kell tudnunk bizonyítani (hiszen a rezolúció teljes). Ha képesek volnánk a bizonyítást „visszafelé pörgetni”, akkor tudnánk egy olyan <span class="emphasis"><em>Hipotézis</em></span>-t találni, amire a bizonyítás sikeres lesz. A kulcsprobléma tehát, hogy hogyan tudnánk a rezolúciós eljárást invertálni, hogy a bizonyítás visszafelé fusson le.</p><p>Az inverz rezolúció visszafelé haladó bizonyítási eljárását mutatjuk be, amely egyedi visszafelé mutató lépésekből áll. Egy közönséges rezolúciós lépés a <span class="emphasis"><em>C</em></span><sub>1</sub> és <span class="emphasis"><em>C</em></span><sub>2</sub> klózból indul ki, és azokat rezolválja egy <span class="emphasis"><em>C</em></span> <span class="strong"><strong>rezolvens</strong></span>t létrehozva eredményül. Az inverz rezoluciós lépés a <span class="emphasis"><em>C</em></span> rezolvens alapján két klózt, <span class="emphasis"><em>C</em></span><sub>1</sub>-et és <span class="emphasis"><em>C</em></span><sub>2</sub>-t hoz létre úgy, hogy <span class="emphasis"><em>C</em></span> a <span class="emphasis"><em>C</em></span><sub>1</sub> és <span class="emphasis"><em>C</em></span><sub>2</sub> rezolválásának az eredménye, vagy pedig <span class="emphasis"><em>C</em></span> és <span class="emphasis"><em>C</em></span><sub>1</sub> alapján állít elő egy lehetséges <span class="emphasis"><em>C</em></span><sub>2</sub>-t.</p><div class="figure"><a id="id736946"/><p class="title"><strong>19.13. ábra - Az inverz rezolúciós eljárás kezdő lépései. Az árnyékolt klózokat az inverz rezolúciós eljárás generálja a jobb oldalon és az alatta lévő klózokból. A nem árnyékolt klózok a <span class="emphasis"><em>Leírások</em></span>-ból és a <span class="emphasis"><em>Besorolások</em></span>-ból származnak.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-13.png" alt="Az inverz rezolúciós eljárás kezdő lépései. Az árnyékolt klózokat az inverz rezolúciós eljárás generálja a jobb oldalon és az alatta lévő klózokból. A nem árnyékolt klózok a Leírások-ból és a Besorolások-ból származnak."/></div></div></div><p>A 19.13. ábra inverz rezolúciós eljárás kezdő lépéseit mutatja, ahol a figyelem középpontjában a <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>Anna</em></span>) pozitív példa áll. Az eljárás a bizonyítás végén kezd (amit az ábra alján ábrázolunk). A <span class="emphasis"><em>C</em></span> rezolvensnek üres klózt (azaz egy ellentmondást) választunk, <span class="emphasis"><em>C</em></span><sub>2</sub>-nek pedig a ¬<span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>Anna</em></span>)-t, amely a célpélda negálása. Az első inverz lépés <span class="emphasis"><em>C</em></span>-ből és <span class="emphasis"><em>C</em></span><sub>2</sub>-ből <span class="emphasis"><em>C</em></span><sub>1</sub>-nek a <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>Anna</em></span>)-t generálja. A következő lépés e klózt <span class="emphasis"><em>C</em></span>-nek veszi, a <span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>Erzsébet</em></span>, <span class="emphasis"><em>Anna</em></span>) klózt pedig <span class="emphasis"><em>C</em></span><sub>2</sub>-nek, és az alábbi <span class="emphasis"><em>C</em></span><sub>1 </sub>klózt generálja:</p><p><code class="code">¬<em><span class="remark">Szülője</span></em>(<em><span class="remark">Erzsébet</span></em>, <em><span class="remark">y</span></em>) ∨ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">György</span></em>, <em><span class="remark">y</span></em>)</code></p><p>Az utolsó lépés ezt a klózt rezolvensként kezeli. A <span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>Erzsébet</em></span>) klózt <span class="emphasis"><em>C</em></span><sub>2</sub>-nek véve, egy lehetséges <span class="emphasis"><em>C</em></span><sub>1</sub> klóz az alábbi hipotézis lehet:</p><p><code class="code"><em><span class="remark">Szülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">z</span></em>) ∧ <em><span class="remark">Szülője</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>) ⇒ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">x</span></em>, <em><span class="remark">y</span></em>)</code></p><p>Egy rezolúciós bizonyításunk van tehát arra, hogy a hipotézis, a leírások és a háttértudás maga után vonzza a <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>Anna</em></span>) osztályozást.</p><p>Világos, hogy az inverz rezolúció keresést tartalmaz. Minden egyes inverz rezolúciós lépés nemdeterminisztikus, hiszen az adott <span class="emphasis"><em>C</em></span> és <span class="emphasis"><em>C</em></span><sub>1</sub>-hez több, sőt végtelen sok olyan <span class="emphasis"><em>C</em></span><sub>2</sub> klóz lehet, amely kielégíti azt a feltételt, miszerint <span class="emphasis"><em>C</em></span><sub>1</sub>-gyel rezolválva <span class="emphasis"><em>C</em></span>-t ad eredményül. Így a 19.13. ábra utolsó lépésében a ¬<span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>Erzsébet</em></span>, <span class="emphasis"><em>y</em></span>) ∨ <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>y</em></span>) megválasztása helyett az inverz rezolúciós lépés a következő állításokat is tudná generálni:</p><p><code class="code">¬<em><span class="remark">Szülője</span></em>(<em><span class="remark">Erzsébet</span></em>, <em><span class="remark">Anna</span></em>) ∨ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">György</span></em>, <em><span class="remark">Anna</span></em>)</code></p><p><code class="code">¬<em><span class="remark">Szülője</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">Anna</span></em>) ∨ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">György</span></em>, <em><span class="remark">Anna</span></em>)</code></p><p><code class="code">¬<em><span class="remark">Szülője</span></em>(<em><span class="remark">z</span></em>, <em><span class="remark">y</span></em>) ∨ <em><span class="remark">Nagyszülője</span></em>(<em><span class="remark">György</span></em>, <em><span class="remark">y</span></em>)</code></p><p>(Lásd a 19.4. és a 19.5. feladatot.) Az egyes lépésekben részt vevő klózokat meg lehet választani a <span class="emphasis"><em>Háttértudás</em></span>-ból, a példa <span class="emphasis"><em>Leírások</em></span>-ból, a negált <span class="emphasis"><em>Besorolások</em></span>-ból vagy az inverz rezolúciós fában eddig már legenerált hipotézisklózokból. A nagyszámú lehetőség, egyéb kontroll nélkül, nagy elágazási tényezőt (és így kevéssé hatékony keresést) jelent. A keresés kézben tartására több megközelítést probáltak ki az implementált ILP-rendszerekben:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A redundáns választások eliminálhatók – például a legspecifikusabb lehetséges hipotézisek generálásával, valamint megkövetelve, hogy a hipotézisklózok mind konzisztensek legyenek egymással és a megfigyelésekkel. Az utolsó kritérium kizárná az előbbiekben megadott ¬<span class="emphasis"><em>Szülője</em></span>(<span class="emphasis"><em>z</em></span>, <span class="emphasis"><em>y</em></span>) ∨ <span class="emphasis"><em>Nagyszülője</em></span>(<span class="emphasis"><em>György</em></span>, <span class="emphasis"><em>y</em></span>) klózt.</p></li><li class="listitem"><p>A bizonyítási stratégia szintén megszorítható. A 9. fejezetben láttuk például, hogy a <span class="strong"><strong>lineáris rezolúció</strong></span> (<span class="strong"><strong>linear resolution</strong></span>) egy teljes, megszorított stratégia, amely lehetővé teszi, hogy a bizonyítási fáknak csak lineáris elágazási struktúrája lehessen (mint a 19.13. ábrán).</p></li><li class="listitem"><p>A reprezentációs nyelv is megszorítható, a függvényszimbólumok eliminálásával és csak Horn-klózokat megengedve. A <code class="code">PROGOL</code> például Horn-klózokkal dolgozik, <span class="strong"><strong>inverz</strong></span><span class="strong"><strong> vonzatreláció</strong></span>t (<span class="strong"><strong>inverse entailment</strong></span>) alkalmazva. Az ötlet a</p></li></ol></div><p><code class="code">	<em><span class="remark">Háttértudás </span></em>∧<em><span class="remark"> Hipotézis </span></em>∧<em><span class="remark"> Leírások </span></em>⊨<em><span class="remark"> Besorolások</span></em></code></p><p>	vonzatkényszer megváltoztatása a</p><p><code class="code"><em><span class="remark">	Háttértudás </span></em>∧<em><span class="remark"> Leírások </span></em>∧<em><span class="remark"> </span></em>¬<em><span class="remark">Besorolások </span></em>⊨<em><span class="remark"> </span></em>¬<em><span class="remark">Hipotézisek</span></em></code></p><p>	logikailag ekvivalens formára.</p><p>	Ebből a <span class="emphasis"><em>Hipotézisek</em></span> származtatására már a Prolog-beli normál Horn-klóz dedukcióra hasonlító módszert használhatjuk, negálással mint kudarccal. Mivel ez Horn-klózokra korlátozott, így nem teljes módszer, azonban a teljes rezolúciónál hatékonyabb lehet. Inverz vonzatrelációval lehetséges a teljes következtetés alkalmazása is (Inoue, 2001).</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A következtetést modellellenőrzéssel is megvalósíthatjuk a tételbizonyítás helyett. A <code class="code">PROGOL</code> rendszer (Muggleton, 1995) a modellellenőrzés egy formáját használja kereséskorlátozás céljára. Azaz, hasonlóan a válaszhalmaz-programozáshoz, a logikai változók lehetséges értékeit generálja, és a konzisztenciát ellenőrzi.</p></li><li class="listitem"><p>A következtetést az alap ítéletklózokkal is megtehetjük az elsőrendű logika helyett. A <code class="code">LINUS</code>-rendszerben (Lavrac és Dzeroski, 1994) az elsőrendű elméleteket ítéletlogikára fordítják le, ítéletlogikai tanuló rendszerrel oldják meg azokat, majd visszafordítják. Egyes problémák esetén ítéletlogikai állításokkal sokkal hatékonyabban lehet dolgozni, ahogy ezt a 11. fejezetben a <code class="code">SATPLAN</code> esetében már láttuk.</p></li></ol></div></div><div class="section" title="Felfedezés induktív logikai programozással"><div class="titlepage"><div><div><h2 class="title"><a id="id737423"/>Felfedezés induktív logikai programozással</h2></div></div></div><p>Egy teljes rezolúciós stratégiát invertáló inverz rezolúciós eljárás elvben az elsőrendű elméletek tanulásának egy teljes algoritmusa. Ez azt jelenti, hogy ha valamely ismeretlen <span class="emphasis"><em>Hipotézis</em></span> egy sor példát generál, akkor az inverz rezolúciós eljárás a példákból tudja generálni a <span class="emphasis"><em>Hipotézis</em></span>-t. Ez a megfigyelés egy érdekes lehetőséget is sugall. Tegyük fel, hogy a rendelkezésre álló példák szabadon eső testek által leírt trajektóriák egy halmazát tartalmazzák. Lehetséges, hogy egy inverz rezolúciós program elvben képes a gravitáció törvényét megtanulni? A válasz természetesen igen, mert a gravitáció törvénye, megfelelő matematikai háttér mellett, lehetővé teszi a példák magyarázatát. Hasonlóképpen el lehet képzelni, hogy az elektromágneses hullámok elmélete, a kvantummechanika és a relativitáselmélet, mind beletartoznak az ILP-programok hatáskörébe. Persze a gépíró majom hatáskörébe is beletartoznak; jobb heurisztikákra és a keresési teret jobban strukturáló technikákra még mindig szükség van. </p><p>Egy dolgot azért az inverz rezolúciós rendszer meg <span class="emphasis"><em>fog</em></span> tenni a részünkre: új predikátumokat fog kitalálni. Ez a képessége kissé mágikusnak tűnik, hiszen a számítógépre szokás úgy tekinteni, mint ami „csak azzal dolgozik, amit bemenetként kapott”. Tény, hogy az új predikátumok egyenesen az inverz rezolúciós lépésből pottyannak ki. A legegyszerűbb az az eset, amikor egy adott <span class="emphasis"><em>C</em></span> klóz esetén két új klóz, <span class="emphasis"><em>C</em></span><sub>1</sub> és <span class="emphasis"><em>C</em></span><sub>2</sub> létezését kellene felvetni. A <span class="emphasis"><em>C</em></span><sub>1</sub> és <span class="emphasis"><em>C</em></span><sub>2</sub> rezolúciója a két klóz által közösen tartalmazott literált eliminálta, lehetséges hát, hogy az eliminált literálban olyan predikátum is szerepelt, amely <span class="emphasis"><em>C</em></span>-ben már nem lép fel. Visszafelé haladva tehát lehetőségként adódik egy új predikátum létrehozása, amiből viszont a hiányzó literál már rekonstruálható. </p><p>A 19.14. ábra arra mutat példát, ahogy az <span class="emphasis"><em>Őse</em></span> definíciójának tanulása közben egy új <span class="emphasis"><em>P</em></span> predikátumot generálunk. Ha már előállítottuk a <span class="emphasis"><em>P</em></span>-t, akkor ez használható az inverz rezolúció későbbi lépéseiben is. Egy későbbi lépés például feltételezheti, hogy az <span class="emphasis"><em>Anyja</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) ⇒ <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>). Az új predikátum jelentését így a predikátumot felhasználó hipotézis generálása korlátozza. Egy másik példa elvezethet az <span class="emphasis"><em>Apja</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) ⇒ <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>)-ig. Más szóval a <span class="emphasis"><em>P</em></span> predikátum olyan valami, ami minket általában a <span class="emphasis"><em>Szülője</em></span> relációra emlékeztet. Korábban említettük, hogy új predikátumok bevezetése a célpredikátum definíciójának a méretét lényegesen csökkentheti. Az új predikátumok kialakításának beépített képességével, az inverz rezolúciós rendszer sokszor olyan tanulási problémákkal is megbirkózik, amelyekre más módszerek alkalmatlanok.</p><p>A tudomány legmélyebbre ható forradalmai új predikátumok és függvények bevezetésével függnek össze, ilyen például a Galilei felfedezte gyorsulás vagy Joule termikus energiája. Ha ezek a fogalmak már adottak, az új törvények felfedezése (viszonylag) egyszerű. A fő nehézség arra rájönni, hogy egy új entitás bevezetése, amely a létező entitásokkal meghatározott konkrét kapcsolatban van, lehetővé teszi a megfigyelések egész halmazának a korábban lehetségesnél sokkal egyszerűbb és elegánsabb elmélet keretein belül történő magyarázatát.</p><div class="figure"><a id="id737540"/><p class="title"><strong>19.14. ábra - Egy új <span class="emphasis"><em>P</em></span> predikátumot generáló inverz rezolúciós lépés</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/19-14.png" alt="Egy új P predikátumot generáló inverz rezolúciós lépés"/></div></div></div><p>Az ILP-rendszerek egyelőre Galilei- vagy Joule-szintű felfedezéseket nem tettek, a felfedezéseit azonban tudományos irodalomban való publikálásra érdemesnek találták. Így például <span class="emphasis"><em>Journal of Molecular Biology</em></span>-ban Turcotte írja le a fehérje összehajtogatási szabályok automatikus felfedezését a <code class="code">PROGOL</code> ILP programmal (Turcotte és társai, 2001). A Progol által felfedezett szabályok közül sokat az ismert elvekből ugyan le lehetett volna következtetni, a többségét azonban a standard biológiai adatbázisok részeként korábban mégsem publikálták (lásd 19.10. ábra példája). Egy ehhez kapcsolódó kutatás részeként Srinivasan (Srinivasan és társai, 1994) molekula-struktúraalapú szabályok felfedezésével foglalkozott nitroaromatikus komponensek mutagenicitására. Ilyen komponensek a gépkocsik által kibocsátott kipufogógázban találhatók. A standard adatbázisokban lévő komponensek 80%-ában lehetséges a négy fontos jellemzőt azonosítani, és az erre épülő lineáris regresszió jobb az ILP-nél. A maradék 20% esetén a jellemzők önmagukban nem elegendők az előrejelzéshez, az ILP relációkat azonosít, amelyekkel a lineáris regresszió, a neurális hálók és a döntési fák képességein túltesz. King (King és társai, 1992) azt mutatta meg, hogy a különböző gyógyszerek gyógykezelési hatását hogyan lehetne előre jelezni. Ezen esetek mindegyikében úgy tűnik, hogy az ILP nagy hatékonyságához a relációk reprezentálási képessége és a háttértudás használata járulnak hozzá. Az a tény, hogy az ILP által megtalált szabályokat az emberek is képesek interpretálni, inkább segíti ezeknek a technológiáknak az elfogadását a biológiai folyóiratokban, mint a számítógépes tudománnyal foglalkozó folyóiratokban.</p><p>Az ILP a biológián túl más tudományokhoz is hozzájárult. A legfontosabbak egyike a természetes nyelvfeldolgozás, ahol az ILP-t komplex relációs információ szövegekből való kinyerésére alkalmazták. Ezeket az eredményeket a 23. fejezet foglalja össze.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id734125" href="#id734125" class="para">192</a>] </sup> Azt javasoljuk, hogy ezen a ponton az olvasó ismételten fusson végig a 9. fejezetben bemutatott néhány fogalmon, beleértve a Horn-klózokat, a konjunktív normál formát, az egyesítést és a rezolúciót.</p></div></div></div></body></html>
