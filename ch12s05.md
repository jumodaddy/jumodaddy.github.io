<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Végrehajtás monitorozása és újratervezése"><div class="titlepage"><div><div><h1 class="title"><a id="id658482"/>Végrehajtás monitorozása és újratervezése</h1></div></div></div><a id="ID_520_521_oldal"/><p>A <span class="strong"><strong>végrehajtás-monitorozó</strong></span> (<span class="strong"><strong>execution monitoring</strong></span>) ágens érzékelőivel ellenőrzi, hogy minden a terv szerint megy-e. Murphy törvénye alapján az egereknek, embereknek és a feltételes tervkészítő ágenseknek még a legjobban elkészített tervei is gyakran sikertelenek. A probléma a nem korlátos nemdeterminisztikusság, azaz néhány váratlan körülmény mindig felmerül, melyre az ágens cselekvés leírásai helytelenek. A valós környezetekben ezért a végrehajtás-monitorozás elengedhetetlen. Kétféle végrehajtás-monitorozást veszünk számba: az egyszerű, de gyenge <span class="strong"><strong>cselekvésmonitorozás</strong></span>t (<span class="strong"><strong>action monitoring</strong></span>), ahol az ágens a környezet vizsgálatával ellenőrzi, hogy a következő cselekvés működni fog, és az összetettebb, de hatékonyabb <span class="strong"><strong>tervmonitorozás</strong></span>t (<span class="strong"><strong>plan monitoring</strong></span>), melyben az ágens a terv teljes hátralevő részét ellenőrzi. </p><p>Az <span class="strong"><strong>újratervező</strong></span> (<span class="strong"><strong>replanning</strong></span>) ágens tudja, hogy váratlan események esetén mit kell tennie: újra meghívja a tervkészítőt, hogy a cél eléréséhez egy új tervet biztosítson. Annak elkerülésére, hogy túl sok időt töltsünk tervkészítéssel, ez rendszerint a régi terv javításával történik, azaz utat keresünk a fennálló nem várt állapotból vissza, a meglévő tervhez. </p><p>Példaként térjünk vissza a 12.9.<span class="emphasis"><em> </em></span>ábra dupla-Murphy porszívóvilágához. Ebben a világban egy tiszta cellára lépés néha bepiszkolja azt. De mi történik, ha az ágens ezt nem tudja vagy nem foglalkozik vele? Akkor egy nagyon egyszerű megoldással áll elő: [<span class="emphasis"><em>Balra</em></span>]. Ha a terv végrehajtásánál érkezéskor nem történik piszkítás, akkor az ágens a cél elérését detektálja. Ellenkező esetben azonban, mivel az implicit <span class="emphasis"><em>Befejez</em></span> lépés <span class="emphasis"><em>TisztaBal</em></span> előfeltétele nem teljesül, az ágens új tervet készít: [<span class="emphasis"><em>Szív</em></span>]. Ennek a tervnek a végrehajtása mindig sikeres.</p><p>A végrehajtás-monitorozás és újratervezés együttesen egy általános stratégia, ami mind a teljesen, mind pedig a részben megfigyelhető környezetekre alkalmazható a tervkészítési reprezentációk széles körén, beleértve az állapottér-, a részben rendezett és a feltételes terveket. A 12.13.<span class="emphasis"><em> </em></span>ábra az állapottér-tervkészítésre mutat be egy egyszerű megközelítést. A tervkészítő ágens egy céllal indít, és kiinduló tervet készít ennek eléréséhez. Ellentétben más tervkészítő ágensekkel, az újratervező ágens követi mind a hátralevő, még végrehajtatlan <span class="emphasis"><em>terv</em></span> részletet, valamint a teljes eredeti tervet <span class="emphasis"><em>teljes_terv-</em></span>et. <span class="strong"><strong>Cselekvésmonitorozás</strong></span>t (<span class="strong"><strong>action monitoring</strong></span>) használ: a <span class="emphasis"><em>terv</em></span> következő cselekvésének végrehajtása előtt az ágens megvizsgálja az érzékelőit, hogy megbizonyosodjon arról, hogy a terv előfeltételei nem váltak-e váratlanul kielégítetlenné. Ha igen, akkor az ágens egy cselekvéssorozat újratervezésével megpróbál a <span class="emphasis"><em>teljes_terv</em></span> egy pontjára visszajutni.</p><div class="figure"><a id="id658582"/><p class="title"><strong>12.13. ábra - Egy cselekvésmonitorozó és -újratervező ágens. Ez szubrutinként a <code class="code">TERVKÉSZÍTŐ</code> teljes állapottér tervkészítő algoritmust használja. Ha a következő cselekvés előfeltételei nem teljesülnek, az ágens a <span class="emphasis"><em>teljes_terv</em></span> lehetséges <span class="emphasis"><em>p</em></span> pontjain iterál olyat keresve, amelyhez a <code class="code">TERVKÉSZÍTŐ</code> útvonalat tud tervezni. Ezt az útvonalat hívjuk <span class="emphasis"><em>javításnak</em></span>. Ha a <code class="code">TERVKÉSZÍTŐ</code> sikeres a javításban, az új terv készítéséhez összefűzi a javítást és a terv <span class="emphasis"><em>p</em></span> utáni részét. Az ágens ezután a terv első lépését adja vissza.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-13.png" alt="Egy cselekvésmonitorozó és -újratervező ágens. Ez szubrutinként a TERVKÉSZÍTŐ teljes állapottér tervkészítő algoritmust használja. Ha a következő cselekvés előfeltételei nem teljesülnek, az ágens a teljes_terv lehetséges p pontjain iterál olyat keresve, amelyhez a TERVKÉSZÍTŐ útvonalat tud tervezni. Ezt az útvonalat hívjuk javításnak. Ha a TERVKÉSZÍTŐ sikeres a javításban, az új terv készítéséhez összefűzi a javítást és a terv p utáni részét. Az ágens ezután a terv első lépését adja vissza."/></div></div></div><p>A 12.14.<span class="emphasis"><em> </em></span>ábra a folyamat sematikus illusztrációja. Az újratervező észreveszi, hogy a <span class="emphasis"><em>terv</em></span> első cselekvésének előfeltételeit az aktuális állapot nem elégíti ki. Ezután meghívja a tervkészítőt, hogy készítsen egy új <span class="emphasis"><em>javítás</em></span>-nak nevezett résztervet, amely az aktuális állapotból a <span class="emphasis"><em>teljes_terv</em></span> valamely <span class="emphasis"><em>s</em></span> állapotába vezet vissza. Ebben a példában az <span class="emphasis"><em>s</em></span> történetesen egylépésnyi visszalépést jelent az aktuális hátralévő <span class="emphasis"><em>terv</em></span>-ből. (Ez az oka, hogy a hátralévő terv helyett a teljes tervet figyeljük.) Általánosságban <span class="emphasis"><em>s</em></span>-et a jelen állapothoz a lehető legközelebbre választjuk. Az új terv a <span class="emphasis"><em>javítás</em></span> és a <span class="emphasis"><em>teljes_terv</em></span> <span class="emphasis"><em>s</em></span>-től hátralevő része — amit <span class="emphasis"><em>folytatás</em></span>-nak nevezünk — összefűzéséből adódik, mellyel az ágens készen áll a végrehajtás folytatására.</p><p>Térjünk vissza az asztal és a szék azonos színűre festésének problémájához, ez alkalommal újratervezéssel. Feltételezzük a teljesen megfigyelhető környezetet. A kiinduló állapotban a szék kék, az asztal zöld, valamint 1 doboz kék és 1 doboz zöld festék áll rendelkezésünkre. Ez a következő probléma definícióhoz vezet: </p><div class="figure"><a id="id658664"/><p class="title"><strong>12.14. ábra - A végrehajtás előtt a tervkészítő egy <span class="emphasis"><em>teljes_terv</em></span>-nek nevezett tervet készít, mely <span class="emphasis"><em>S</em></span>-ből <span class="emphasis"><em>G</em></span>-be vezet. Az ágens az <span class="emphasis"><em>E</em></span>-vel jelölt pontig végrehajtja a tervet. A <span class="emphasis"><em>terv</em></span> hátralevő részének végrehajtása előtt a szokásos módon ellenőrzi az előfeltételeket, és azt találja, hogy valójában az <span class="emphasis"><em>O</em></span> állapotban van, és nem az <span class="emphasis"><em>E</em></span>-ben. Ezután meghívja a tervkészítő algoritmust, hogy készítsen egy <span class="emphasis"><em>javítás</em></span>-t, mely egy terv az <span class="emphasis"><em>O</em></span>-ból az eredeti <span class="emphasis"><em>teljes_terv</em></span> egy <span class="emphasis"><em>P</em></span> pontjához. Az új <span class="emphasis"><em>terv</em></span> ezután a <span class="emphasis"><em>javítás</em></span> és a <span class="emphasis"><em>folytatás</em></span> (az eredeti <span class="emphasis"><em>teljes_terv</em></span> maradék része) összefűzéséből adódik.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/12-14.png" alt="A végrehajtás előtt a tervkészítő egy teljes_terv-nek nevezett tervet készít, mely S-ből G-be vezet. Az ágens az E-vel jelölt pontig végrehajtja a tervet. A terv hátralevő részének végrehajtása előtt a szokásos módon ellenőrzi az előfeltételeket, és azt találja, hogy valójában az O állapotban van, és nem az E-ben. Ezután meghívja a tervkészítő algoritmust, hogy készítsen egy javítás-t, mely egy terv az O-ból az eredeti teljes_terv egy P pontjához. Az új terv ezután a javítás és a folytatás (az eredeti teljes_terv maradék része) összefűzéséből adódik."/></div></div></div><div class="informaltable"><table border="0"><colgroup><col width="11.1pt" class="col1"/><col width="237.0pt" class="col2"/></colgroup><tbody><tr><td colspan="2" style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Kiindulás(Színe(Szék, Kék) ∧ Színe(Asztal, Zöld)</code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">∧ SzíntTartalmaz(BC, Kék) ∧ FestékDoboz (BC) </code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">∧ SzíntTartalmaz(RC, Piros) ∧ FestékDoboz (RC)</code></p></td></tr><tr><td colspan="2" style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Cél(Színe(Szék, x) ∧ Színe(Asztal, x))</code></p></td></tr><tr><td colspan="2" style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Cselekvés(Fest(tárgy, szín),</code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Előfeltétel:VanFesték(szín)</code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Következmény:Színe(tárgy, szín))</code></p></td></tr><tr><td colspan="2" style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Cselekvés(Nyit(doboz),</code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Előfeltétel:FestékDoboz(doboz) ∧ Színe(doboz, szín)</code></p></td></tr><tr><td style="text-align: justify" valign="top"> </td><td style="text-align: justify" valign="top"><p class="Táblázatcím"><code class="code">Következmény:Színe(szín))</code></p></td></tr></tbody></table></div><p>Az ágens <code class="code">TERVKÉSZÍTŐ</code>-jének a következő tervvel kellene előállnia:</p><p><code class="code">[<em><span class="remark">Indít</span></em>; <em><span class="remark">Nyit</span></em>(<em><span class="remark">BC</span></em>); <em><span class="remark">Fest</span></em>(<em><span class="remark">Asztal</span></em>, <em><span class="remark">Kék</span></em>); <em><span class="remark">Befejez</span></em>]</code></p><p>Az ágens most készen áll a terv végrehajtására. Tegyük fel, hogy minden jól megy, és az ágens kinyitja a kék festéket és az asztalra keni. Az előző alfejezet ágensei a terv lépésének befejezése után győzelmet kiáltanának. A végrehajtás-monitorozó ágensnek ellenben először ellenőriznie kell a <span class="emphasis"><em>Befejez</em></span> lépés előfeltételét, ami azt mondja, hogy a két bútornak azonos színűnek kell lennie. Tegyük fel, hogy az ágens azt érzékeli, hogy a bútorok nem azonos színűek, mivel a festés hiányossága miatt az asztalon egy zöld folt maradt. Az ágensnek ezután keresnie kell egy célpontot a <span class="emphasis"><em>teljes_terv</em></span>-ben, amelyet megcélozhat, és egy javító cselekvéssorozatot kell kidolgoznia, hogy ide jusson. Az ágens észreveszi, hogy az aktuális állapot azonos a <span class="emphasis"><em>Fest</em></span> cselekvés előfeltételeivel, így a <span class="emphasis"><em>javító</em></span> egy üres sorozat, és a <span class="emphasis"><em>terv</em></span> azonos az épp végrehajtott [<span class="emphasis"><em>Fest</em></span>,<span class="emphasis"><em> Befejez</em></span>] sorozattal. Ezzel az új tervvel a monitorozás végrehajtása folytatódik, és a <span class="emphasis"><em>Fest</em></span> cselekvés újra végrehajtásra kerül. Ez a viselkedés addig ismétlődik, amíg az asztalt teljesen lefestettnek nem érzékeljük. Vegyük észre, hogy a ciklus a terv–végrehajtás–újratervezés folyamat során alakult ki, nem pedig egy explicit ciklus az eredeti tervben.</p><a id="ID_523_524_oldal"/><p>A cselekvésmonitorozás a végrehajtás-monitorozás nagyon egyszerű módszere, de néha kevésbé intelligens viselkedéshez vezethet. Például tegyük fel, hogy az ágens olyan tervet készít, amelyben az asztalt és a széket is pirosra festi. Ekkor kinyitja a piros festéket, és azt találja, hogy nincs elegendő festék a székhez. A cselekvésmonitorozás nem érzékelné ezt a sikertelenséget, csak <span class="emphasis"><em>miután</em></span> a széket befestettük, amikor is a <span class="emphasis"><em>VanFesték</em></span>(<span class="emphasis"><em>Piros</em></span>) hamissá válik. Amire valójában szükségünk van, az az, hogy akkor érzékeljük a hibát, amikor olyan állapotba jutunk, ahonnan a terv hátralevő része már nem működik. A <span class="strong"><strong>tervmonitorozás</strong></span> (<span class="strong"><strong>plan monitoring</strong></span>) ezt úgy éri el, hogy a teljes hátralevő tervben szereplő előfeltételek sikerességét ellenőrzi, azaz a terv minden lépésének előfeltételeit, kivéve azokat, amelyeket a hátralévő terv egy másik lépésével ér el. A tervmonitorozás a hibás terv végrehajtását a lehető leghamarabb megszakítja, azaz nem várja meg, míg a hiba valójában fellép.<sup>[<a id="id659026" href="#ftn.id659026" class="footnote">130</a>]</sup> Néhány esetben ez az ágenst a teljes bukástól mentheti meg, amikor a hibás terv egy olyan zsákutcába vezetne, melyből a cél már elérhetetlen.</p><p>Elég kézenfekvő a tervkészítő algoritmus módosítása, hogy az a terv minden pontján tartalmazza a hátralevő terv sikeréhez szükséges előfeltételeket. Ha a tervmonitorozást kiterjesztjük, hogy az aktuális pont helyett az összes jövőbeni pontra ellenőrizze, hogy az aktuális állapot kielégíti-e a terv előfeltételeit, akkor a tervmonitorozás kihasználhatja a <span class="strong"><strong>szerencsés rábukkanás</strong></span>t (<span class="strong"><strong>serendipity</strong></span>), azaz a véletlenszerű sikert. Ha valaki arra jártában pirosra festi az asztalt ugyanabban az időben, amikor az ágens a széket festi pirosra, akkor a végső terv előfeltételei teljesülnek (a cél teljesül), és az ágens korábban megpihenhet.</p><p>Eddig a monitorozást és újratervezést a teljesen megfigyelhető környezetek esetére mutattuk be. A részlegesen megfigyelhető környezetek esetén jóval komplikáltabb problémák léphetnek fel. Először is olyan hibák léphetnek fel, amelyet az ágens nem tud érzékelni. Másodszor „az előfeltételek ellenőrzése” érzékelő cselekvések végrehajtását teheti szükségessé, amelyet tervezni kell vagy a tervkészítési időben, ami a feltételes tervkészítéshez vezet vissza, vagy a végrehajtási időben. A legrosszabb esetben az érzékelési cselekvések végrehajtása összetett tervet igényel, melyhez monitorozás, így további érzékelési cselekvések szükségesek. És ez így megy tovább. Ha az ágens ragaszkodik minden előfeltétel ellenőrzéséhez, akkor elképzelhető, hogy sohasem jut hozzá, hogy valójában <span class="emphasis"><em>tegyen</em></span> is valamit. Az ágensnek csak a fontos változók ellenőrzését kellene szem előtt tartani, melyek jó eséllyel okoznak hibát, és nem túl drága a megfigyelésük. Ez lehetőséget ad az ágensnek, hogy megfelelőképpen reagáljon a fontos fenyegetésekre, de ne vesztegessen időt annak ellenőrizgetésére, hogy összeomlik-e az ég. </p><p>Miután bemutattuk a monitorozás és újratervezés módszerét, meg kell kérdeznünk: „Működik?” Ez meglepően becsapós kérdés. Ha a kérdést úgy értelmezzük, hogy „Garantálni tudjuk-e, hogy az ágens mindig, még nem korlátos nemdeterminisztikusság esetén is célt ér?”, akkor a válasz nem, hiszen az ágens figyelmetlenségből zsákutcába juthat, csakúgy, mint a 4.5.<span class="emphasis"><em> </em></span>alfejezetben bemutatott online keresés. Például lehet, hogy a porszívóágens nem tudja, hogy az elemei kifogyhatnak. Zárjuk ki a zsákutcákat, azaz tételezzük fel, hogy az ágens olyan tervet tud létrehozni, amelyben a célt a környezet <span class="emphasis"><em>bármely</em></span> állapotából eléri. Ha feltételezzük, hogy a környezet valóban nemdeterminisztikus, abban az értelemben, hogy egy ilyen tervnek egy adott végrehajtása esetén mindig van <span class="emphasis"><em>valamekkora</em></span> esélye a sikerre, akkor az ágens szükségszerűen célt ér. Az újratervező ágens képességei ezért megfelelnek a feltételes tervkészítő ágens képességeinek. Valójában módosíthatjuk a feltételes tervkészítőt, hogy csak részleges megoldást készítsen, amely „<span class="strong"><strong>if</strong></span> &lt;<span class="emphasis"><em>teszt</em></span>&gt; <span class="strong"><strong>then</strong></span> <span class="emphasis"><em>terv_A </em></span><span class="strong"><strong>else</strong></span> <span class="emphasis"><em>újratervez</em></span>” formájú lépéseket tartalmaz. Az említett korlátozásokkal egy ilyen terv megfelelő megoldása lehet az eredeti problémának, és elkészítése szintén sokkal olcsóbb lehet, mint a teljes feltételes tervnek. </p><p>Hiba akkor lép fel, ha az ágens ismételt kísérletei is sikertelenek a cél elérésében, azaz valamilyen, számára ismeretlen előfeltétel vagy következmény blokkolja. Például ha az ágens rossz kulcskártyát kap a hotelszobájához, akkor nincs az a beillesztési és eltávolítási próbálkozás, ami kinyitná az ajtót.<sup>[<a id="id659092" href="#ftn.id659092" class="footnote">131</a>]</sup> Egy megoldás, hogy ugyanazon terv ismételgetése helyett véletlenszerűen választunk egy lehetséges javítóterv halmazból. Ebben az esetben egy új kulcskártya kérése a recepcióról hasznos alternatív javító terv. Mivel nem biztos, hogy az ágens képes a valóban nemdeterminisztikus esetet és a hiábavalóság esetét megkülönböztetni, egy kis változatosság a javításban általánosságban is jó ötlet. </p><p>A helytelen cselekvés problémájára egy másik megoldás a <span class="strong"><strong>tanulás</strong></span>. Néhány próbálkozás után a tanuló ágensnek képesnek kell lennie a cselekvésleírás módosítására, hogy az igényelje, hogy a kulcs nyissa az ajtót. Ezen a ponton az újratervező automatikusan egy új tervvel áll elő, mint egy új kulcs megszerzése. A 21.<span class="emphasis"><em> </em></span>fejezet ezt a fajta tanulást mutatja be.</p><p>Az újratervező ágensnek még ezekkel a lehetséges javításokkal is vannak további hátrányai. Nem hatékony a valós idejű környezetekben, és nincs korlát az újratervezési időre, ezáltal nincs korlát a cselekvésről való döntés idejére sem. Szintén képtelen saját célokat kialakítani vagy a meglévő célokhoz új célokat fogadni, azaz nem lehet hosszú életű egy összetett környezetben. Ezeket a hátrányokat kezeljük a következő fejezetben.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id659026" href="#id659026" class="para">130</a>] </sup> A tervmonitorozás okosabbá teszi az ágensünket egy ganajtúró bogárnál (lásd <a class="xref" href="ch02s02.md#ID_71_oldal">„Mindentudás, tanulás és autonómia”</a> részben). Az ágensünk észrevenné, hogy a ganaj már nincs a lábainál, újratervezne, hogy szerezzen egy másikat, és azzal zárná le a lyukat.</p></div><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id659092" href="#id659092" class="para">131</a>] </sup> A tervjavítás hatástalan ismétlése pontosan megfelel a szöcskeölő darázs viselkedésének (lásd <a class="xref" href="ch02s02.md#ID_72_oldal">„Mindentudás, tanulás és autonómia”</a> részben).</p></div></div></div></body></html>
