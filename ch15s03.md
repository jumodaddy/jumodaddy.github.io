<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/></head><body><div class="section" title="Rejtett Markov-modellek"><div class="titlepage"><div><div><h1 class="title"><a id="id692568"/>Rejtett Markov-modellek</h1></div></div></div><p>Az előző fejezet időbeli valószínűségi következtetésre szolgáló algoritmusokat vezetett be egy általános keretben, ami független volt az állapotátmenet- és az érzékelő modellek speciális formájától. Ebben és a következő két alfejezetben, olyan konkrétabb modelleket és alkalmazásokat tárgyalunk meg, amelyek bemutatják az alapalgoritmusok erejét, és bizonyos esetekben további tökéletesítéseket tesznek lehetővé.</p><p>A <span class="strong"><strong>rejtett Markov-modell</strong></span>ekkel (<span class="strong"><strong>RMM</strong></span>) (<span class="strong"><strong>hidden Markov model</strong></span>, <span class="strong"><strong>HMM</strong></span>) kezdjük. Egy RMM egy olyan időbeli valószínűségi modell, amelyben a folyamat állapotát egyetlen diszkrét valószínűségi változó írja le. [A modell karakterisztikus tulajdonsága tehát a rejtett állapot, azaz a (sztochasztikus) állapotfejlődés és annak passzív (sztochasztikus) megfigyelése. Az index időértelmezése helyett bármely szekvenciális értelmezés lehetséges, gyakori például az indexnek mint egy egydimenziós pozíciónak az értelmezése is – <span class="emphasis"><em>a ford.</em></span>] A változó lehetséges értékei a világ lehetséges állapotai. Az előző fejezetben leírt esernyős példa ezért egy RMM, mivel csak egyetlen állapotváltozója van az Esőt. Az RMM keretei között további állapotváltozók csak úgy adhatók hozzá az időbeli modellhez, hogy az összes állapotváltozót egyetlen „megaváltozóba” kombináljuk, amelynek az értékei az egyes állapotváltozók értékeinek minden lehetséges kombinációja. Látni fogjuk, hogy az RMM-ek korlátozott struktúrája lehetővé teszi az összes alapalgoritmus egy nagyon egyszerű és elegáns mátrixos átfordítását.<sup>[<a id="id692599" href="#ftn.id692599" class="footnote">158</a>]</sup> A 15.6. alfejezet bemutatja az RMM-ek használatát a beszédfelismerésben.</p><div class="section" title="Egyszerűsített mátrix algoritmusok"><div class="titlepage"><div><div><h2 class="title"><a id="id692605"/>Egyszerűsített mátrix algoritmusok</h2></div></div></div><p>Egyetlen, diszkrét <span class="emphasis"><em>X<sub>t</sub></em></span> állapotváltozó esetén konkrét forma adható az állapotátmenet-modell, az érzékelő modell és az előre és hátra üzenetek reprezentációira. Jelöljük az <span class="emphasis"><em>X<sub>t </sub></em></span>állapotváltozó értékeit 1, …, <span class="emphasis"><em>S</em></span> egészekkel, ahol <span class="emphasis"><em>S</em></span> a lehetséges állapotok száma. A <span class="strong"><strong>P</strong></span>(<span class="emphasis"><em>X<sub>t</sub></em></span> |<span class="emphasis"><em>X</em></span><sub>t–1</sub>) állapotátmenet-modell ekkor egy <span class="strong"><strong>T S</strong></span> × <span class="emphasis"><em>S</em></span> mátrix, ahol</p><p><code class="code"><em><span class="remark">T</span></em><sub>ij </sub>= <em><span class="remark">P</span></em>(<em><span class="remark">X<sub>t </sub></span></em>= <em><span class="remark">j</span></em>|<em><span class="remark">X</span></em><sub>t–1 </sub>= <em><span class="remark">i</span></em>) </code></p><p>Azaz <span class="strong"><strong>T</strong></span><sub>ij</sub> az átmenet valószínűsége <span class="emphasis"><em>i</em></span>-ből <span class="emphasis"><em>j</em></span>-be. Például az esernyős világban az állapotátmenet-mátrix</p><p><span class="inlinemediaobject"><img src="math/mi-15-0013.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>Az érzékelő modellt szintén mátrixalakra hozzuk. Ebben az esetben mivel az <span class="emphasis"><em>E<sub>t</sub></em></span> bizonyítékváltozó értéke ismert, mondjuk <span class="emphasis"><em>e<sub>t</sub></em></span>, így a modellnek csak azt a részét használjuk, ami az <span class="emphasis"><em>e<sub>t</sub></em></span> megjelenésének valószínűségét meghatározza. Minden <span class="emphasis"><em>t</em></span> időpontra konstruálunk egy <span class="strong"><strong>O</strong></span><sub>t</sub> diagonális mátrixot, aminek az átlóbeli elemeit a <span class="emphasis"><em>P</em></span>(<span class="emphasis"><em>e<sub>t</sub></em></span>|<span xml:lang="it" class="emphasis"><em>X<sub>t </sub></em></span>= <span class="emphasis"><em>i</em></span>)<span class="emphasis"><em> </em></span>értékek adják, a többi értéke pedig 0. Például az esernyős világban az 1. napon az <span class="emphasis"><em>U</em></span><sub>1 </sub>= <span class="emphasis"><em>igaz</em></span>, így a 15.2. ábra szerint azt kapjuk, hogy</p><p><span class="inlinemediaobject"><img src="math/mi-15-0014.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>Most oszlopvektort használva az előre és hátra üzenetek reprezentálására, a számítások egyszerű mátrix-vektor műveletekké válnak. A (15.3) előrefelé egyenlet ekkor</p><p><code class="code"><em><span class="remark">f</span></em><sub>1:<em><span class="remark">t</span></em> + 1</sub> = α<em><span class="remark">O</span></em><sub><em><span class="remark">t </span></em>+ 1</sub><em><span class="remark">T</span></em> <sup>⊤</sup><em><span class="remark">f</span></em><sub>1:<em><span class="remark">t	</span></em></sub>(15.10)</code></p><p>és a (15.7) visszafelé egyenlet pedig</p><p><code class="code"><em><span class="remark">b</span></em><sub><em><span class="remark">k</span></em> + 1:<em><span class="remark">t</span></em></sub><em><span class="remark"> = </span></em><em><span class="remark">TO</span></em><sub><em><span class="remark">k</span></em> + 1</sub><em><span class="remark">b</span></em><sub><em><span class="remark">k</span></em> + 2:<em><span class="remark">t	</span></em></sub>(15.11)</code></p><p>Ezekből az egyenletekből látható, hogy az előre-hátra algoritmus (lásd 15.4. ábra) időkomplexitása egy <span class="emphasis"><em>t</em></span> hosszúságú sorozatra történő alkalmazásnál <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>S</em></span><sup>2</sup><span class="emphasis"><em>t</em></span>),<span class="emphasis"><em> </em></span>mivel minden lépés egy <span class="emphasis"><em>S</em></span> elemű vektor szorzását igényli egy <span class="emphasis"><em>S</em></span> × <span class="emphasis"><em>S</em></span> mátrixszal. A tárigény pedig <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>St</em></span>), mivel az előrefelé fázis <span class="emphasis"><em>t</em></span> darab <span class="emphasis"><em>S</em></span> méretű vektort tárol el.</p><p>Amellett hogy a mátrixos jelölés az RMM-ek esetében a szűrés és a simítás algoritmusaira egy elegáns leírásmódot kínál, ez javított algoritmusokra is jelez lehetőségeket. Az első az előre-hátra algoritmus egy egyszerű változata, ami simítás elvégzését teszi lehetővé <span class="emphasis"><em>állandó</em></span> tárigény mellett, a sorozat hosszától függetlenül. Az ötlet az, hogy egy konkrét <span class="emphasis"><em>k</em></span> időpillanatban a simítás mind az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>k</em></span></sub> előre, mind a <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>k</em></span>+1:<span class="emphasis"><em>t</em></span> </sub>hátra üzenetek egyidejű jelenlétét igényli a (15.6) egyenlet szerint. Az előre-hátra algoritmus ezt úgy biztosítja, hogy az előrefelé fázisban tárolja az <span class="strong"><strong>f</strong></span>-eket, hogy a hátrafelé fázisban elérhetők legyenek. Egy másik módszer szerint ez úgy érhető el, hogy egyetlen menetben mind <span class="strong"><strong>f</strong></span>-et, mind <span class="strong"><strong>b</strong></span>-t ugyanabban az irányban terjesztjük. Például az <span class="strong"><strong>f </strong></span>„előre” üzenet terjeszthető hátrafelé, ha átrendezzük a (15.10) egyenletet, hogy a másik irányban működjön:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0015.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>A módosított szűrési algoritmus úgy működik, hogy először lefut egy szabványos előre fázis, kiszámítva <span class="strong"><strong>f</strong></span><sub><span class="emphasis"><em>t</em></span>:<span class="emphasis"><em>t</em></span></sub>-t (elfelejtve az összes közbenső eredményt), majd lefut egy visszafelé fázis együtt <span class="strong"><strong>b</strong></span>-re<span class="strong"><strong> </strong></span>és <span class="strong"><strong>f</strong></span>-re, kiszámítva a simított becslést minden időpontban. Mivel mindegyik üzenetnek csak egy példánya szükséges, a tárigény állandó (azaz független <span class="emphasis"><em>t</em></span>-től, a sorozat hosszától). Az algoritmusra egyetlen jelentős megkötés vonatkozik: az állapotátmenet-mátrixnak invertálhatónak kell lennie, és az érzékelő modellben nem lehetnek nullák – azaz minden megfigyelésnek lehetségesnek kell lenni minden állapotban.</p><p>A második terület, ahol a mátrixjelölés javítást jelez, a menet közben történő (online) simítás állandó időkülönbözettel. Az a tény, hogy a simítás elvégezhető állandó tárigénnyel azt jelzi, hogy léteznie kell egy hatékony rekurzív algoritmusnak menet közbeni simításra – azaz olyan algoritmusnak amelynek az időkomplexitása független az időkülönbözet hosszától. Tegyük fel, hogy az időkülönbözet <span class="emphasis"><em>d</em></span>; azaz a simítást <span class="emphasis"><em>t</em></span> – <span class="emphasis"><em>d</em></span> időpontban végezzük, ahol <span class="emphasis"><em>t</em></span> a jelenlegi időpont. A (15.6) egyenlet szerint ki kell számolnunk a <span class="emphasis"><em>t </em></span>– <span class="emphasis"><em>d</em></span> időpontra az</p><p><code class="code">α <em><span class="remark">f</span></em><sub>1:<em><span class="remark">t–d</span></em></sub> <em><span class="remark">b</span></em><sub><em><span class="remark">t–d</span></em>+1:<em><span class="remark">t</span></em></sub></code></p><p>értékét. Majd amikor az új megfigyelés beérkezik, a <span class="emphasis"><em>t</em></span> – <span class="emphasis"><em>d</em></span> + 1 időpontra kell kiszámítanunk az</p><p><code class="code">α <em><span class="remark">f</span></em><sub>1:<em><span class="remark">t–d</span></em>+1</sub> <em><span class="remark">b</span></em><sub><em><span class="remark">t–d</span></em>+2:<em><span class="remark">t</span></em>+1</sub></code></p><p>értéket. Hogyan tehető ez meg inkrementálisan? Először is, az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>t</em></span>–<span class="emphasis"><em>d</em></span>+1</sub> kiszámítható az <span class="strong"><strong>f</strong></span><sub>1:<span class="emphasis"><em>t</em></span>–<span class="emphasis"><em>d</em></span></sub>-ből a szabványos szűrés műveletét használva a (15.3) egyenlet szerint.</p><p>A visszafelé üzenet inkrementális kiszámítása trükkösebb, mivel nincs egyszerű kapcsolat a régi <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>t–d</em></span>+1:<span class="emphasis"><em>t</em></span></sub> visszafelé üzenet és az új <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>t–d+2</em></span>:<span class="emphasis"><em>t</em></span>+1 </sub>visszafelé üzenet között. Ehelyett, a régi <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>t–d</em></span>+1:<span class="emphasis"><em>t</em></span></sub> visszafelé üzenet  és a sorozat kezdő <span class="strong"><strong>b</strong></span><sub><span class="emphasis"><em>t</em></span>+1:<span class="emphasis"><em>t</em></span></sub><span class="emphasis"><em><sub> </sub></em></span>visszafelé üzenete közötti kapcsolatot fogjuk megvizsgálni. Ennek eléréséhez alkalmazzuk a (15.11) egyenletet <span class="emphasis"><em>d</em></span> alkalommal, és azt kapjuk, hogy</p><p><span class="inlinemediaobject"><img src="math/mi-15-0016.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>ahol a <span class="strong"><strong>B</strong></span><sub><span class="emphasis"><em>t</em></span>–<span class="emphasis"><em>d+</em></span>1<span class="emphasis"><em>:t</em></span> </sub>mátrix a <span class="strong"><strong>T</strong></span> és az <span class="strong"><strong>O</strong></span> mátrixok sorozatának a szorzata. A <span class="strong"><strong>B</strong></span>-t felfoghatjuk egy „transzformációs operátornak”, ami egy későbbi visszafelé üzenetet egy korábbiba alakít. Egy hasonló egyenlet áll fenn az új visszafelé üzenetekre a következő megfigyelés beérkezése után:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0017.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>Ha a (15.12) és a (15.13) egyenletben megvizsgáljuk a szorzatokat, láthatjuk, hogy egyszerű kapcsolat van közöttük: a második szorzathoz el kell „osztani” az első szorzatot <span class="strong"><strong>TO</strong></span><sub><span class="emphasis"><em>t</em></span>–<span class="emphasis"><em>d</em></span>+1</sub>-gyel, és megszorozni az új utolsó elemmel <span class="strong"><strong>TO</strong></span><sub><span class="emphasis"><em>t</em></span>+1</sub>-gyel. Mátrixjelöléssel ekkor a régi és az új <span class="strong"><strong>B</strong></span> mátrixok között egy egyszerű kapcsolat van:</p><p><span class="inlinemediaobject"><img src="math/mi-15-0018.gif" alt="Egyszerűsített mátrix algoritmusok"/></span></p><p>Ez az egyenlet a <span class="strong"><strong>B</strong></span> mátrix egy inkrementális frissítését adja, amely viszont (a (15.3) egyenlet által) lehetővé teszi az új <span class="strong"><strong>b</strong></span><sub>t–d+2:t+1 </sub>visszafelé üzenet kiszámítását. A teljes algoritmus, ami az <span class="strong"><strong>f</strong></span> és <span class="strong"><strong>B</strong></span> tárolását és frissítését igényli, a 15.6. ábrán látható.</p><div class="figure"><a id="id695126"/><p class="title"><strong>15.6. ábra - Egy állandó <span class="emphasis"><em>d</em></span> lépésnyi időkülönbözettel simító algoritmus, folyamatos működésű (online) algoritmusként megvalósítva: egy új időpontbeli megfigyelésre kiadja az új simított becslést</strong></p><div class="figure-contents"><div class="mediaobject"><img src="kepek/15-06.png" alt="Egy állandó d lépésnyi időkülönbözettel simító algoritmus, folyamatos működésű (online) algoritmusként megvalósítva: egy új időpontbeli megfigyelésre kiadja az új simított becslést"/></div></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p class="footnote text"><sup>[<a id="ftn.id692599" href="#id692599" class="para">158</a>] </sup> A vektor- és mátrixművelekben járatlan olvasó számára hasznos lehet az A) függeléket átnézni, mielőtt a fejezetben továbbhaladna.</p></div></div></div></body></html>
